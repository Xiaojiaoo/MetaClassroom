import {
  __commonJS,
  require_babylon
} from "./chunk-UUUTRKNT.js";

// node_modules/babylonjs-loaders/babylonjs.loaders.js
var require_babylonjs_loaders = __commonJS({
  "node_modules/babylonjs-loaders/babylonjs.loaders.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_babylon());
      else if (typeof define === "function" && define.amd)
        define("babylonjs-loaders", ["babylonjs"], factory);
      else if (typeof exports === "object")
        exports["babylonjs-loaders"] = factory(require_babylon());
      else
        root["LOADERS"] = factory(root["BABYLON"]);
    })(typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : exports, (__WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_observable__) => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = {
            /***/
            "../../../dev/loaders/src/OBJ/index.ts": (
              /*!*********************************************!*\
                !*** ../../../dev/loaders/src/OBJ/index.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    _mtlFileLoader__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    _objFileLoader__WEBPACK_IMPORTED_MODULE_3__.OBJFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    _solidParser__WEBPACK_IMPORTED_MODULE_2__.SolidParser
                  )
                  /* harmony export */
                });
                var _mtlFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./mtlFileLoader */
                  "../../../dev/loaders/src/OBJ/mtlFileLoader.ts"
                );
                var _objLoadingOptions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./objLoadingOptions */
                  "../../../dev/loaders/src/OBJ/objLoadingOptions.ts"
                );
                var _solidParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./solidParser */
                  "../../../dev/loaders/src/OBJ/solidParser.ts"
                );
                var _objFileLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./objFileLoader */
                  "../../../dev/loaders/src/OBJ/objFileLoader.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/mtlFileLoader.ts": (
              /*!*****************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/mtlFileLoader.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* binding */
                    MTLFileLoader
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/standardMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
                var MTLFileLoader = (
                  /** @class */
                  function() {
                    function MTLFileLoader2() {
                      this.materials = [];
                    }
                    MTLFileLoader2.prototype.parseMTL = function(scene, data, rootUrl, assetContainer) {
                      if (data instanceof ArrayBuffer) {
                        return;
                      }
                      var lines = data.split("\n");
                      var delimiter_pattern = /\s+/;
                      var color;
                      var material = null;
                      for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim();
                        if (line.length === 0 || line.charAt(0) === "#") {
                          continue;
                        }
                        var pos = line.indexOf(" ");
                        var key = pos >= 0 ? line.substring(0, pos) : line;
                        key = key.toLowerCase();
                        var value = pos >= 0 ? line.substring(pos + 1).trim() : "";
                        if (key === "newmtl") {
                          if (material) {
                            this.materials.push(material);
                          }
                          scene._blockEntityCollection = !!assetContainer;
                          material = new babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(value, scene);
                          material._parentContainer = assetContainer;
                          scene._blockEntityCollection = false;
                        } else if (key === "kd" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.diffuseColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ka" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.ambientColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ks" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.specularColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ke" && material) {
                          color = value.split(delimiter_pattern, 3).map(parseFloat);
                          material.emissiveColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(color);
                        } else if (key === "ns" && material) {
                          material.specularPower = parseFloat(value);
                        } else if (key === "d" && material) {
                          material.alpha = parseFloat(value);
                        } else if (key === "map_ka" && material) {
                          material.ambientTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "map_kd" && material) {
                          material.diffuseTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "map_ks" && material) {
                          material.specularTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "map_ns") {
                        } else if (key === "map_bump" && material) {
                          var values = value.split(delimiter_pattern);
                          var bumpMultiplierIndex = values.indexOf("-bm");
                          var bumpMultiplier = null;
                          if (bumpMultiplierIndex >= 0) {
                            bumpMultiplier = values[bumpMultiplierIndex + 1];
                            values.splice(bumpMultiplierIndex, 2);
                          }
                          material.bumpTexture = MTLFileLoader2._GetTexture(rootUrl, values.join(" "), scene);
                          if (material.bumpTexture && bumpMultiplier !== null) {
                            material.bumpTexture.level = parseFloat(bumpMultiplier);
                          }
                        } else if (key === "map_d" && material) {
                          material.opacityTexture = MTLFileLoader2._GetTexture(rootUrl, value, scene);
                        } else if (key === "illum") {
                          if (value === "0") {
                          } else if (value === "1") {
                          } else if (value === "2") {
                          } else if (value === "3") {
                          } else if (value === "4") {
                          } else if (value === "5") {
                          } else if (value === "6") {
                          } else if (value === "7") {
                          } else if (value === "8") {
                          } else if (value === "9") {
                          } else if (value === "10") {
                          }
                        } else {
                        }
                      }
                      if (material) {
                        this.materials.push(material);
                      }
                    };
                    MTLFileLoader2._GetTexture = function(rootUrl, value, scene) {
                      if (!value) {
                        return null;
                      }
                      var url = rootUrl;
                      if (rootUrl === "file:") {
                        var lastDelimiter = value.lastIndexOf("\\");
                        if (lastDelimiter === -1) {
                          lastDelimiter = value.lastIndexOf("/");
                        }
                        if (lastDelimiter > -1) {
                          url += value.substr(lastDelimiter + 1);
                        } else {
                          url += value;
                        }
                      } else {
                        url += value;
                      }
                      return new babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Texture(url, scene, false, MTLFileLoader2.INVERT_TEXTURE_Y);
                    };
                    MTLFileLoader2.INVERT_TEXTURE_Y = true;
                    return MTLFileLoader2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/objFileLoader.ts": (
              /*!*****************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/objFileLoader.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* binding */
                    OBJFileLoader
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/assetContainer */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _mtlFileLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./mtlFileLoader */
                  "../../../dev/loaders/src/OBJ/mtlFileLoader.ts"
                );
                var _solidParser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./solidParser */
                  "../../../dev/loaders/src/OBJ/solidParser.ts"
                );
                var OBJFileLoader = (
                  /** @class */
                  function() {
                    function OBJFileLoader2(loadingOptions) {
                      this.name = "obj";
                      this.extensions = ".obj";
                      this._assetContainer = null;
                      this._loadingOptions = loadingOptions || OBJFileLoader2._DefaultLoadingOptions;
                    }
                    Object.defineProperty(OBJFileLoader2, "INVERT_TEXTURE_Y", {
                      /**
                       * Invert Y-Axis of referenced textures on load
                       */
                      get: function() {
                        return _mtlFileLoader__WEBPACK_IMPORTED_MODULE_1__.MTLFileLoader.INVERT_TEXTURE_Y;
                      },
                      set: function(value) {
                        _mtlFileLoader__WEBPACK_IMPORTED_MODULE_1__.MTLFileLoader.INVERT_TEXTURE_Y = value;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(OBJFileLoader2, "_DefaultLoadingOptions", {
                      get: function() {
                        return {
                          computeNormals: OBJFileLoader2.COMPUTE_NORMALS,
                          optimizeNormals: OBJFileLoader2.OPTIMIZE_NORMALS,
                          importVertexColors: OBJFileLoader2.IMPORT_VERTEX_COLORS,
                          invertY: OBJFileLoader2.INVERT_Y,
                          invertTextureY: OBJFileLoader2.INVERT_TEXTURE_Y,
                          // eslint-disable-next-line @typescript-eslint/naming-convention
                          UVScaling: OBJFileLoader2.UV_SCALING,
                          materialLoadingFailsSilently: OBJFileLoader2.MATERIAL_LOADING_FAILS_SILENTLY,
                          optimizeWithUV: OBJFileLoader2.OPTIMIZE_WITH_UV,
                          skipMaterials: OBJFileLoader2.SKIP_MATERIALS
                        };
                      },
                      enumerable: false,
                      configurable: true
                    });
                    OBJFileLoader2.prototype._loadMTL = function(url, rootUrl, onSuccess, onFailure) {
                      var pathOfFile = rootUrl + url;
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadFile(pathOfFile, onSuccess, void 0, void 0, false, function(request, exception) {
                        onFailure(pathOfFile, exception);
                      });
                    };
                    OBJFileLoader2.prototype.createPlugin = function() {
                      return new OBJFileLoader2(OBJFileLoader2._DefaultLoadingOptions);
                    };
                    OBJFileLoader2.prototype.canDirectLoad = function() {
                      return false;
                    };
                    OBJFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl) {
                      return this._parseSolid(meshesNames, scene, data, rootUrl).then(function(meshes) {
                        return {
                          meshes,
                          particleSystems: [],
                          skeletons: [],
                          animationGroups: [],
                          transformNodes: [],
                          geometries: [],
                          lights: []
                        };
                      });
                    };
                    OBJFileLoader2.prototype.loadAsync = function(scene, data, rootUrl) {
                      return this.importMeshAsync(null, scene, data, rootUrl).then(function() {
                      });
                    };
                    OBJFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl) {
                      var _this = this;
                      var container = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                      this._assetContainer = container;
                      return this.importMeshAsync(null, scene, data, rootUrl).then(function(result) {
                        result.meshes.forEach(function(mesh) {
                          return container.meshes.push(mesh);
                        });
                        result.meshes.forEach(function(mesh) {
                          var material = mesh.material;
                          if (material) {
                            if (container.materials.indexOf(material) == -1) {
                              container.materials.push(material);
                              var textures = material.getActiveTextures();
                              textures.forEach(function(t) {
                                if (container.textures.indexOf(t) == -1) {
                                  container.textures.push(t);
                                }
                              });
                            }
                          }
                        });
                        _this._assetContainer = null;
                        return container;
                      }).catch(function(ex) {
                        _this._assetContainer = null;
                        throw ex;
                      });
                    };
                    OBJFileLoader2.prototype._parseSolid = function(meshesNames, scene, data, rootUrl) {
                      var _this = this;
                      var fileToLoad = "";
                      var materialsFromMTLFile = new _mtlFileLoader__WEBPACK_IMPORTED_MODULE_1__.MTLFileLoader();
                      var materialToUse = [];
                      var babylonMeshesArray = [];
                      var solidParser = new _solidParser__WEBPACK_IMPORTED_MODULE_2__.SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);
                      solidParser.parse(meshesNames, data, scene, this._assetContainer, function(fileName) {
                        fileToLoad = fileName;
                      });
                      var mtlPromises = [];
                      if (fileToLoad !== "" && !this._loadingOptions.skipMaterials) {
                        mtlPromises.push(new Promise(function(resolve, reject) {
                          _this._loadMTL(fileToLoad, rootUrl, function(dataLoaded) {
                            try {
                              materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, _this._assetContainer);
                              for (var n = 0; n < materialsFromMTLFile.materials.length; n++) {
                                var startIndex = 0;
                                var _indices = [];
                                var _index = void 0;
                                while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {
                                  _indices.push(_index);
                                  startIndex = _index + 1;
                                }
                                if (_index === -1 && _indices.length === 0) {
                                  materialsFromMTLFile.materials[n].dispose();
                                } else {
                                  for (var o = 0; o < _indices.length; o++) {
                                    var mesh = babylonMeshesArray[_indices[o]];
                                    var material = materialsFromMTLFile.materials[n];
                                    mesh.material = material;
                                    if (!mesh.getTotalIndices()) {
                                      material.pointsCloud = true;
                                    }
                                  }
                                }
                              }
                              resolve();
                            } catch (e) {
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Error processing MTL file: '".concat(fileToLoad, "'"));
                              if (_this._loadingOptions.materialLoadingFailsSilently) {
                                resolve();
                              } else {
                                reject(e);
                              }
                            }
                          }, function(pathOfFile, exception) {
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Error downloading MTL file: '".concat(fileToLoad, "'"));
                            if (_this._loadingOptions.materialLoadingFailsSilently) {
                              resolve();
                            } else {
                              reject(exception);
                            }
                          });
                        }));
                      }
                      return Promise.all(mtlPromises).then(function() {
                        return babylonMeshesArray;
                      });
                    };
                    OBJFileLoader2.OPTIMIZE_WITH_UV = true;
                    OBJFileLoader2.INVERT_Y = false;
                    OBJFileLoader2.IMPORT_VERTEX_COLORS = false;
                    OBJFileLoader2.COMPUTE_NORMALS = false;
                    OBJFileLoader2.OPTIMIZE_NORMALS = false;
                    OBJFileLoader2.UV_SCALING = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);
                    OBJFileLoader2.SKIP_MATERIALS = false;
                    OBJFileLoader2.MATERIAL_LOADING_FAILS_SILENTLY = true;
                    return OBJFileLoader2;
                  }()
                );
                if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SceneLoader) {
                  babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SceneLoader.RegisterPlugin(new OBJFileLoader());
                }
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/objLoadingOptions.ts": (
              /*!*********************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/objLoadingOptions.ts ***!
                \*********************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/OBJ/solidParser.ts": (
              /*!***************************************************!*\
                !*** ../../../dev/loaders/src/OBJ/solidParser.ts ***!
                \***************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  SolidParser: () => (
                    /* binding */
                    SolidParser
                  )
                  /* harmony export */
                });
                var babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Meshes/mesh.vertexData */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__);
                var SolidParser = (
                  /** @class */
                  function() {
                    function SolidParser2(materialToUse, babylonMeshesArray, loadingOptions) {
                      this._positions = [];
                      this._normals = [];
                      this._uvs = [];
                      this._colors = [];
                      this._meshesFromObj = [];
                      this._indicesForBabylon = [];
                      this._wrappedPositionForBabylon = [];
                      this._wrappedUvsForBabylon = [];
                      this._wrappedColorsForBabylon = [];
                      this._wrappedNormalsForBabylon = [];
                      this._tuplePosNorm = [];
                      this._curPositionInIndices = 0;
                      this._hasMeshes = false;
                      this._unwrappedPositionsForBabylon = [];
                      this._unwrappedColorsForBabylon = [];
                      this._unwrappedNormalsForBabylon = [];
                      this._unwrappedUVForBabylon = [];
                      this._triangles = [];
                      this._materialNameFromObj = "";
                      this._objMeshName = "";
                      this._increment = 1;
                      this._isFirstMaterial = true;
                      this._grayColor = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(0.5, 0.5, 0.5, 1);
                      this._materialToUse = materialToUse;
                      this._babylonMeshesArray = babylonMeshesArray;
                      this._loadingOptions = loadingOptions;
                    }
                    SolidParser2.prototype._isInArray = function(arr, obj) {
                      if (!arr[obj[0]]) {
                        arr[obj[0]] = { normals: [], idx: [] };
                      }
                      var idx = arr[obj[0]].normals.indexOf(obj[1]);
                      return idx === -1 ? -1 : arr[obj[0]].idx[idx];
                    };
                    SolidParser2.prototype._isInArrayUV = function(arr, obj) {
                      if (!arr[obj[0]]) {
                        arr[obj[0]] = { normals: [], idx: [], uv: [] };
                      }
                      var idx = arr[obj[0]].normals.indexOf(obj[1]);
                      if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {
                        return arr[obj[0]].idx[idx];
                      }
                      return -1;
                    };
                    SolidParser2.prototype._setData = function(indicePositionFromObj, indiceUvsFromObj, indiceNormalFromObj, positionVectorFromOBJ, textureVectorFromOBJ, normalsVectorFromOBJ, positionColorsFromOBJ) {
                      var _index;
                      if (this._loadingOptions.optimizeWithUV) {
                        _index = this._isInArrayUV(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj, indiceUvsFromObj]);
                      } else {
                        _index = this._isInArray(this._tuplePosNorm, [indicePositionFromObj, indiceNormalFromObj]);
                      }
                      if (_index === -1) {
                        this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);
                        this._wrappedPositionForBabylon.push(positionVectorFromOBJ);
                        this._wrappedUvsForBabylon.push(textureVectorFromOBJ);
                        this._wrappedNormalsForBabylon.push(normalsVectorFromOBJ);
                        if (positionColorsFromOBJ !== void 0) {
                          this._wrappedColorsForBabylon.push(positionColorsFromOBJ);
                        }
                        this._tuplePosNorm[indicePositionFromObj].normals.push(indiceNormalFromObj);
                        this._tuplePosNorm[indicePositionFromObj].idx.push(this._curPositionInIndices++);
                        if (this._loadingOptions.optimizeWithUV) {
                          this._tuplePosNorm[indicePositionFromObj].uv.push(indiceUvsFromObj);
                        }
                      } else {
                        this._indicesForBabylon.push(_index);
                      }
                    };
                    SolidParser2.prototype._unwrapData = function() {
                      for (var l = 0; l < this._wrappedPositionForBabylon.length; l++) {
                        this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);
                        this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);
                        this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y);
                        if (this._loadingOptions.importVertexColors) {
                          this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);
                        }
                      }
                      this._wrappedPositionForBabylon.length = 0;
                      this._wrappedNormalsForBabylon.length = 0;
                      this._wrappedUvsForBabylon.length = 0;
                      this._wrappedColorsForBabylon.length = 0;
                      this._tuplePosNorm.length = 0;
                      this._curPositionInIndices = 0;
                    };
                    SolidParser2.prototype._getTriangles = function(faces, v) {
                      for (var faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {
                        this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);
                      }
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern1 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var indicePositionFromObj = parseInt(this._triangles[k]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          0,
                          0,
                          // In the pattern 1, normals and uvs are not defined
                          this._positions[indicePositionFromObj],
                          // Get the vectors data
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(),
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(),
                          // Create default vectors
                          this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : void 0
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern2 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("/");
                        var indicePositionFromObj = parseInt(point[0]) - 1;
                        var indiceUvsFromObj = parseInt(point[1]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          indiceUvsFromObj,
                          0,
                          //Default value for normals
                          this._positions[indicePositionFromObj],
                          //Get the values for each element
                          this._uvs[indiceUvsFromObj],
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Up(),
                          //Default value for normals
                          this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : void 0
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern3 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("/");
                        var indicePositionFromObj = parseInt(point[0]) - 1;
                        var indiceUvsFromObj = parseInt(point[1]) - 1;
                        var indiceNormalFromObj = parseInt(point[2]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          indiceUvsFromObj,
                          indiceNormalFromObj,
                          this._positions[indicePositionFromObj],
                          this._uvs[indiceUvsFromObj],
                          this._normals[indiceNormalFromObj]
                          //Set the vector for each component
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern4 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("//");
                        var indicePositionFromObj = parseInt(point[0]) - 1;
                        var indiceNormalFromObj = parseInt(point[1]) - 1;
                        this._setData(
                          indicePositionFromObj,
                          1,
                          //Default value for uv
                          indiceNormalFromObj,
                          this._positions[indicePositionFromObj],
                          //Get each vector of data
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2.Zero(),
                          this._normals[indiceNormalFromObj],
                          this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : void 0
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._setDataForCurrentFaceWithPattern5 = function(face, v) {
                      this._getTriangles(face, v);
                      for (var k = 0; k < this._triangles.length; k++) {
                        var point = this._triangles[k].split("/");
                        var indicePositionFromObj = this._positions.length + parseInt(point[0]);
                        var indiceUvsFromObj = this._uvs.length + parseInt(point[1]);
                        var indiceNormalFromObj = this._normals.length + parseInt(point[2]);
                        this._setData(
                          indicePositionFromObj,
                          indiceUvsFromObj,
                          indiceNormalFromObj,
                          this._positions[indicePositionFromObj],
                          this._uvs[indiceUvsFromObj],
                          this._normals[indiceNormalFromObj],
                          //Set the vector for each component
                          this._loadingOptions.importVertexColors ? this._colors[indicePositionFromObj] : void 0
                        );
                      }
                      this._triangles.length = 0;
                    };
                    SolidParser2.prototype._addPreviousObjMesh = function() {
                      if (this._meshesFromObj.length > 0) {
                        this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
                        this._unwrapData();
                        this._indicesForBabylon.reverse();
                        this._handledMesh.indices = this._indicesForBabylon.slice();
                        this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();
                        this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();
                        this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();
                        if (this._loadingOptions.importVertexColors) {
                          this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();
                        }
                        this._indicesForBabylon.length = 0;
                        this._unwrappedPositionsForBabylon.length = 0;
                        this._unwrappedColorsForBabylon.length = 0;
                        this._unwrappedNormalsForBabylon.length = 0;
                        this._unwrappedUVForBabylon.length = 0;
                      }
                    };
                    SolidParser2.prototype._optimizeNormals = function(mesh) {
                      var positions = mesh.getVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                      var normals = mesh.getVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                      var mapVertices = {};
                      if (!positions || !normals) {
                        return;
                      }
                      for (var i = 0; i < positions.length / 3; i++) {
                        var x = positions[i * 3 + 0];
                        var y = positions[i * 3 + 1];
                        var z = positions[i * 3 + 2];
                        var key = x + "_" + y + "_" + z;
                        var lst = mapVertices[key];
                        if (!lst) {
                          lst = [];
                          mapVertices[key] = lst;
                        }
                        lst.push(i);
                      }
                      var normal = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                      for (var key in mapVertices) {
                        var lst = mapVertices[key];
                        if (lst.length < 2) {
                          continue;
                        }
                        var v0Idx = lst[0];
                        for (var i = 1; i < lst.length; ++i) {
                          var vIdx = lst[i];
                          normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];
                          normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];
                          normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];
                        }
                        normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);
                        normal.normalize();
                        for (var i = 0; i < lst.length; ++i) {
                          var vIdx = lst[i];
                          normals[vIdx * 3 + 0] = normal.x;
                          normals[vIdx * 3 + 1] = normal.y;
                          normals[vIdx * 3 + 2] = normal.z;
                        }
                      }
                      mesh.setVerticesData(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
                    };
                    SolidParser2.prototype.parse = function(meshesNames, data, scene, assetContainer, onFileToLoadFound) {
                      var _a;
                      var lines = data.split("\n");
                      for (var i = 0; i < lines.length; i++) {
                        var line = lines[i].trim().replace(/\s\s/g, " ");
                        var result = void 0;
                        if (line.length === 0 || line.charAt(0) === "#") {
                          continue;
                        } else if (SolidParser2.VertexPattern.test(line)) {
                          result = line.match(/[^ ]+/g);
                          this._positions.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
                          if (this._loadingOptions.importVertexColors) {
                            if (result.length >= 7) {
                              var r = parseFloat(result[4]);
                              var g = parseFloat(result[5]);
                              var b = parseFloat(result[6]);
                              this._colors.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === void 0 ? 1 : parseFloat(result[7])));
                            } else {
                              this._colors.push(this._grayColor);
                            }
                          }
                        } else if ((result = SolidParser2.NormalPattern.exec(line)) !== null) {
                          this._normals.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));
                        } else if ((result = SolidParser2.UVPattern.exec(line)) !== null) {
                          this._uvs.push(new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));
                        } else if ((result = SolidParser2.FacePattern3.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern3(
                            result[1].trim().split(" "),
                            // ["1/1/1", "2/2/2", "3/3/3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern4.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern4(
                            result[1].trim().split(" "),
                            // ["1//1", "2//2", "3//3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern5.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern5(
                            result[1].trim().split(" "),
                            // ["-1/-1/-1", "-2/-2/-2", "-3/-3/-3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern2.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern2(
                            result[1].trim().split(" "),
                            // ["1/1", "2/2", "3/3"]
                            1
                          );
                        } else if ((result = SolidParser2.FacePattern1.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern1(
                            result[1].trim().split(" "),
                            // ["1", "2", "3"]
                            1
                          );
                        } else if ((result = SolidParser2.LinePattern1.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern1(
                            result[1].trim().split(" "),
                            // ["1", "2"]
                            0
                          );
                        } else if ((result = SolidParser2.LinePattern2.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern2(
                            result[1].trim().split(" "),
                            // ["1/1", "2/2"]
                            0
                          );
                        } else if ((result = SolidParser2.LinePattern3.exec(line)) !== null) {
                          this._setDataForCurrentFaceWithPattern3(
                            result[1].trim().split(" "),
                            // ["1/1/1", "2/2/2"]
                            0
                          );
                        } else if (SolidParser2.GroupDescriptor.test(line) || SolidParser2.ObjectDescriptor.test(line)) {
                          var objMesh = {
                            name: line.substring(2).trim(),
                            indices: void 0,
                            positions: void 0,
                            normals: void 0,
                            uvs: void 0,
                            colors: void 0,
                            materialName: this._materialNameFromObj
                          };
                          this._addPreviousObjMesh();
                          this._meshesFromObj.push(objMesh);
                          this._hasMeshes = true;
                          this._isFirstMaterial = true;
                          this._increment = 1;
                        } else if (SolidParser2.UseMtlDescriptor.test(line)) {
                          this._materialNameFromObj = line.substring(7).trim();
                          if (!this._isFirstMaterial || !this._hasMeshes) {
                            this._addPreviousObjMesh();
                            var objMesh = (
                              //Set the name of the current obj mesh
                              {
                                name: (this._objMeshName || "mesh") + "_mm" + this._increment.toString(),
                                indices: void 0,
                                positions: void 0,
                                normals: void 0,
                                uvs: void 0,
                                colors: void 0,
                                materialName: this._materialNameFromObj
                              }
                            );
                            this._increment++;
                            this._meshesFromObj.push(objMesh);
                            this._hasMeshes = true;
                          }
                          if (this._hasMeshes && this._isFirstMaterial) {
                            this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;
                            this._isFirstMaterial = false;
                          }
                        } else if (SolidParser2.MtlLibGroupDescriptor.test(line)) {
                          onFileToLoadFound(line.substring(7).trim());
                        } else if (SolidParser2.SmoothDescriptor.test(line)) {
                        } else {
                          console.log("Unhandled expression at line : " + line);
                        }
                      }
                      if (this._hasMeshes) {
                        this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];
                        this._indicesForBabylon.reverse();
                        this._unwrapData();
                        this._handledMesh.indices = this._indicesForBabylon;
                        this._handledMesh.positions = this._unwrappedPositionsForBabylon;
                        this._handledMesh.normals = this._unwrappedNormalsForBabylon;
                        this._handledMesh.uvs = this._unwrappedUVForBabylon;
                        if (this._loadingOptions.importVertexColors) {
                          this._handledMesh.colors = this._unwrappedColorsForBabylon;
                        }
                      }
                      if (!this._hasMeshes) {
                        var newMaterial = null;
                        if (this._indicesForBabylon.length) {
                          this._indicesForBabylon.reverse();
                          this._unwrapData();
                        } else {
                          for (var _i = 0, _b = this._positions; _i < _b.length; _i++) {
                            var pos = _b[_i];
                            this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);
                          }
                          if (this._normals.length) {
                            for (var _c = 0, _d = this._normals; _c < _d.length; _c++) {
                              var normal = _d[_c];
                              this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);
                            }
                          }
                          if (this._uvs.length) {
                            for (var _e = 0, _f = this._uvs; _e < _f.length; _e++) {
                              var uv = _f[_e];
                              this._unwrappedUVForBabylon.push(uv.x, uv.y);
                            }
                          }
                          if (this._colors.length) {
                            for (var _g = 0, _h = this._colors; _g < _h.length; _g++) {
                              var color = _h[_g];
                              this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);
                            }
                          }
                          if (!this._materialNameFromObj) {
                            newMaterial = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.StandardMaterial(babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Geometry.RandomId(), scene);
                            newMaterial.pointsCloud = true;
                            this._materialNameFromObj = newMaterial.name;
                            if (!this._normals.length) {
                              newMaterial.disableLighting = true;
                              newMaterial.emissiveColor = babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                            }
                          }
                        }
                        this._meshesFromObj.push({
                          name: babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Geometry.RandomId(),
                          indices: this._indicesForBabylon,
                          positions: this._unwrappedPositionsForBabylon,
                          colors: this._unwrappedColorsForBabylon,
                          normals: this._unwrappedNormalsForBabylon,
                          uvs: this._unwrappedUVForBabylon,
                          materialName: this._materialNameFromObj,
                          directMaterial: newMaterial
                        });
                      }
                      for (var j = 0; j < this._meshesFromObj.length; j++) {
                        if (meshesNames && this._meshesFromObj[j].name) {
                          if (meshesNames instanceof Array) {
                            if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {
                              continue;
                            }
                          } else {
                            if (this._meshesFromObj[j].name !== meshesNames) {
                              continue;
                            }
                          }
                        }
                        this._handledMesh = this._meshesFromObj[j];
                        scene._blockEntityCollection = !!assetContainer;
                        var babylonMesh = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.Mesh(this._meshesFromObj[j].name, scene);
                        babylonMesh._parentContainer = assetContainer;
                        scene._blockEntityCollection = false;
                        this._materialToUse.push(this._meshesFromObj[j].materialName);
                        if (((_a = this._handledMesh.positions) === null || _a === void 0 ? void 0 : _a.length) === 0) {
                          this._babylonMeshesArray.push(babylonMesh);
                          continue;
                        }
                        var vertexData = new babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexData();
                        vertexData.uvs = this._handledMesh.uvs;
                        vertexData.indices = this._handledMesh.indices;
                        vertexData.positions = this._handledMesh.positions;
                        if (this._loadingOptions.computeNormals) {
                          var normals = new Array();
                          babylonjs_Buffers_buffer__WEBPACK_IMPORTED_MODULE_0__.VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);
                          vertexData.normals = normals;
                        } else {
                          vertexData.normals = this._handledMesh.normals;
                        }
                        if (this._loadingOptions.importVertexColors) {
                          vertexData.colors = this._handledMesh.colors;
                        }
                        vertexData.applyToMesh(babylonMesh);
                        if (this._loadingOptions.invertY) {
                          babylonMesh.scaling.y *= -1;
                        }
                        if (this._loadingOptions.optimizeNormals) {
                          this._optimizeNormals(babylonMesh);
                        }
                        this._babylonMeshesArray.push(babylonMesh);
                        if (this._handledMesh.directMaterial) {
                          babylonMesh.material = this._handledMesh.directMaterial;
                        }
                      }
                    };
                    SolidParser2.ObjectDescriptor = /^o/;
                    SolidParser2.GroupDescriptor = /^g/;
                    SolidParser2.MtlLibGroupDescriptor = /^mtllib /;
                    SolidParser2.UseMtlDescriptor = /^usemtl /;
                    SolidParser2.SmoothDescriptor = /^s /;
                    SolidParser2.VertexPattern = /^v(\s+[\d|.|+|\-|e|E]+){3,7}/;
                    SolidParser2.NormalPattern = /^vn(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
                    SolidParser2.UVPattern = /^vt(\s+[\d|.|+|\-|e|E]+)( +[\d|.|+|\-|e|E]+)/;
                    SolidParser2.FacePattern1 = /^f\s+(([\d]{1,}[\s]?){3,})+/;
                    SolidParser2.FacePattern2 = /^f\s+((([\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.FacePattern3 = /^f\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.FacePattern4 = /^f\s+((([\d]{1,}\/\/[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.FacePattern5 = /^f\s+(((-[\d]{1,}\/-[\d]{1,}\/-[\d]{1,}[\s]?){3,})+)/;
                    SolidParser2.LinePattern1 = /^l\s+(([\d]{1,}[\s]?){2,})+/;
                    SolidParser2.LinePattern2 = /^l\s+((([\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
                    SolidParser2.LinePattern3 = /^l\s+((([\d]{1,}\/[\d]{1,}\/[\d]{1,}[\s]?){2,})+)/;
                    return SolidParser2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/STL/index.ts": (
              /*!*********************************************!*\
                !*** ../../../dev/loaders/src/STL/index.ts ***!
                \*********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    _stlFileLoader__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader
                  )
                  /* harmony export */
                });
                var _stlFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./stlFileLoader */
                  "../../../dev/loaders/src/STL/stlFileLoader.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/STL/stlFileLoader.ts": (
              /*!*****************************************************!*\
                !*** ../../../dev/loaders/src/STL/stlFileLoader.ts ***!
                \*****************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoader: () => (
                    /* binding */
                    STLFileLoader
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/assetContainer */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__);
                var STLFileLoader = (
                  /** @class */
                  function() {
                    function STLFileLoader2() {
                      this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g;
                      this.facetsPattern = /facet([\s\S]*?)endfacet/g;
                      this.normalPattern = /normal[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
                      this.vertexPattern = /vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
                      this.name = "stl";
                      this.extensions = {
                        ".stl": { isBinary: true }
                      };
                    }
                    STLFileLoader2.prototype.importMesh = function(meshesNames, scene, data, rootUrl, meshes) {
                      var matches;
                      if (typeof data !== "string") {
                        if (this._isBinary(data)) {
                          var babylonMesh = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Mesh("stlmesh", scene);
                          this._parseBinary(babylonMesh, data);
                          if (meshes) {
                            meshes.push(babylonMesh);
                          }
                          return true;
                        }
                        data = new TextDecoder().decode(new Uint8Array(data));
                      }
                      while (matches = this.solidPattern.exec(data)) {
                        var meshName = matches[1];
                        var meshNameFromEnd = matches[3];
                        if (meshNameFromEnd && meshName != meshNameFromEnd) {
                          babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.Error("Error in STL, solid name != endsolid name");
                          return false;
                        }
                        if (meshesNames && meshName) {
                          if (meshesNames instanceof Array) {
                            if (!meshesNames.indexOf(meshName)) {
                              continue;
                            }
                          } else {
                            if (meshName !== meshesNames) {
                              continue;
                            }
                          }
                        }
                        meshName = meshName || "stlmesh";
                        var babylonMesh = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Mesh(meshName, scene);
                        this._parseASCII(babylonMesh, matches[2]);
                        if (meshes) {
                          meshes.push(babylonMesh);
                        }
                      }
                      return true;
                    };
                    STLFileLoader2.prototype.load = function(scene, data, rootUrl) {
                      var result = this.importMesh(null, scene, data, rootUrl, null);
                      return result;
                    };
                    STLFileLoader2.prototype.loadAssetContainer = function(scene, data, rootUrl) {
                      var container = new babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                      scene._blockEntityCollection = true;
                      this.importMesh(null, scene, data, rootUrl, container.meshes);
                      scene._blockEntityCollection = false;
                      return container;
                    };
                    STLFileLoader2.prototype._isBinary = function(data) {
                      var reader = new DataView(data);
                      if (reader.byteLength <= 80) {
                        return false;
                      }
                      var faceSize = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
                      var nFaces = reader.getUint32(80, true);
                      if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {
                        return true;
                      }
                      var ascii = [115, 111, 108, 105, 100];
                      for (var off = 0; off < 5; off++) {
                        if (reader.getUint8(off) !== ascii[off]) {
                          return true;
                        }
                      }
                      return false;
                    };
                    STLFileLoader2.prototype._parseBinary = function(mesh, data) {
                      var reader = new DataView(data);
                      var faces = reader.getUint32(80, true);
                      var dataOffset = 84;
                      var faceLength = 12 * 4 + 2;
                      var offset = 0;
                      var positions = new Float32Array(faces * 3 * 3);
                      var normals = new Float32Array(faces * 3 * 3);
                      var indices = new Uint32Array(faces * 3);
                      var indicesCount = 0;
                      for (var face = 0; face < faces; face++) {
                        var start = dataOffset + face * faceLength;
                        var normalX = reader.getFloat32(start, true);
                        var normalY = reader.getFloat32(start + 4, true);
                        var normalZ = reader.getFloat32(start + 8, true);
                        for (var i = 1; i <= 3; i++) {
                          var vertexstart = start + i * 12;
                          positions[offset] = reader.getFloat32(vertexstart, true);
                          normals[offset] = normalX;
                          if (!STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                            positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);
                            positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);
                            normals[offset + 2] = normalY;
                            normals[offset + 1] = normalZ;
                          } else {
                            positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);
                            positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);
                            normals[offset + 1] = normalY;
                            normals[offset + 2] = normalZ;
                          }
                          offset += 3;
                        }
                        if (STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                          indices[indicesCount] = indicesCount;
                          indices[indicesCount + 1] = indicesCount + 2;
                          indices[indicesCount + 2] = indicesCount + 1;
                          indicesCount += 3;
                        } else {
                          indices[indicesCount] = indicesCount++;
                          indices[indicesCount] = indicesCount++;
                          indices[indicesCount] = indicesCount++;
                        }
                      }
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, positions);
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
                      mesh.setIndices(indices);
                      mesh.computeWorldMatrix(true);
                    };
                    STLFileLoader2.prototype._parseASCII = function(mesh, solidData) {
                      var positions = [];
                      var normals = [];
                      var indices = [];
                      var indicesCount = 0;
                      var matches;
                      while (matches = this.facetsPattern.exec(solidData)) {
                        var facet = matches[1];
                        var normalMatches = this.normalPattern.exec(facet);
                        this.normalPattern.lastIndex = 0;
                        if (!normalMatches) {
                          continue;
                        }
                        var normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];
                        var vertexMatch = void 0;
                        while (vertexMatch = this.vertexPattern.exec(facet)) {
                          if (!STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                            positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));
                            normals.push(normal[0], normal[1], normal[2]);
                          } else {
                            positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));
                            normals.push(normal[0], normal[2], normal[1]);
                          }
                        }
                        if (STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES) {
                          indices.push(indicesCount, indicesCount + 2, indicesCount + 1);
                          indicesCount += 3;
                        } else {
                          indices.push(indicesCount++, indicesCount++, indicesCount++);
                        }
                        this.vertexPattern.lastIndex = 0;
                      }
                      this.facetsPattern.lastIndex = 0;
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, positions);
                      mesh.setVerticesData(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, normals);
                      mesh.setIndices(indices);
                      mesh.computeWorldMatrix(true);
                    };
                    STLFileLoader2.DO_NOT_ALTER_FILE_COORDINATES = false;
                    return STLFileLoader2;
                  }()
                );
                if (babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.SceneLoader) {
                  babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.SceneLoader.RegisterPlugin(new STLFileLoader());
                }
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFBinaryExtension: () => (
                    /* binding */
                    GLTFBinaryExtension
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts"
                );
                var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFLoaderUtils */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts"
                );
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var BinaryExtensionBufferName = "binary_glTF";
                var GLTFBinaryExtension = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_3__.__extends)(GLTFBinaryExtension2, _super);
                    function GLTFBinaryExtension2() {
                      return _super.call(this, "KHR_binary_glTF") || this;
                    }
                    GLTFBinaryExtension2.prototype.loadRuntimeAsync = function(scene, data, rootUrl, onSuccess) {
                      var extensionsUsed = data.json.extensionsUsed;
                      if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
                        return false;
                      }
                      this._bin = data.bin;
                      onSuccess(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
                      return true;
                    };
                    GLTFBinaryExtension2.prototype.loadBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
                        return false;
                      }
                      if (id !== BinaryExtensionBufferName) {
                        return false;
                      }
                      this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, function(error) {
                        return onError(error.message);
                      });
                      return true;
                    };
                    GLTFBinaryExtension2.prototype.loadTextureBufferAsync = function(gltfRuntime, id, onSuccess) {
                      var texture = gltfRuntime.textures[id];
                      var source = gltfRuntime.images[texture.source];
                      if (!source.extensions || !(this.name in source.extensions)) {
                        return false;
                      }
                      var sourceExt = source.extensions[this.name];
                      var bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
                      var buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType.UNSIGNED_BYTE);
                      onSuccess(buffer);
                      return true;
                    };
                    GLTFBinaryExtension2.prototype.loadShaderStringAsync = function(gltfRuntime, id, onSuccess) {
                      var shader = gltfRuntime.shaders[id];
                      if (!shader.extensions || !(this.name in shader.extensions)) {
                        return false;
                      }
                      var binaryExtensionShader = shader.extensions[this.name];
                      var bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
                      var shaderBytes = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType.UNSIGNED_BYTE);
                      setTimeout(function() {
                        var shaderString = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_1__.GLTFUtils.DecodeBufferToText(shaderBytes);
                        onSuccess(shaderString);
                      });
                      return true;
                    };
                    return GLTFBinaryExtension2;
                  }(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderExtension)
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(new GLTFBinaryExtension());
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFLoader.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFLoader: () => (
                    /* binding */
                    GLTFLoader
                  ),
                  /* harmony export */
                  GLTFLoaderBase: () => (
                    /* binding */
                    GLTFLoaderBase
                  ),
                  /* harmony export */
                  GLTFLoaderExtension: () => (
                    /* binding */
                    GLTFLoaderExtension
                  )
                  /* harmony export */
                });
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Engines/constants */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
                var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderUtils */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts"
                );
                var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ../glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var ETokenType;
                (function(ETokenType2) {
                  ETokenType2[ETokenType2["IDENTIFIER"] = 1] = "IDENTIFIER";
                  ETokenType2[ETokenType2["UNKNOWN"] = 2] = "UNKNOWN";
                  ETokenType2[ETokenType2["END_OF_INPUT"] = 3] = "END_OF_INPUT";
                })(ETokenType || (ETokenType = {}));
                var Tokenizer = (
                  /** @class */
                  function() {
                    function Tokenizer2(toParse) {
                      this._pos = 0;
                      this.currentToken = ETokenType.UNKNOWN;
                      this.currentIdentifier = "";
                      this.currentString = "";
                      this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
                      this._toParse = toParse;
                      this._maxPos = toParse.length;
                    }
                    Tokenizer2.prototype.getNextToken = function() {
                      if (this.isEnd()) {
                        return ETokenType.END_OF_INPUT;
                      }
                      this.currentString = this.read();
                      this.currentToken = ETokenType.UNKNOWN;
                      if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
                        this.currentToken = ETokenType.IDENTIFIER;
                        this.currentIdentifier = this.currentString;
                        while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
                          this.currentIdentifier += this.currentString;
                          this.forward();
                        }
                      }
                      return this.currentToken;
                    };
                    Tokenizer2.prototype.peek = function() {
                      return this._toParse[this._pos];
                    };
                    Tokenizer2.prototype.read = function() {
                      return this._toParse[this._pos++];
                    };
                    Tokenizer2.prototype.forward = function() {
                      this._pos++;
                    };
                    Tokenizer2.prototype.isEnd = function() {
                      return this._pos >= this._maxPos;
                    };
                    return Tokenizer2;
                  }()
                );
                var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
                var babylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
                var glTFAnimationPaths = ["translation", "rotation", "scale"];
                var babylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
                var parseBuffers = function(parsedBuffers, gltfRuntime) {
                  for (var buf in parsedBuffers) {
                    var parsedBuffer = parsedBuffers[buf];
                    gltfRuntime.buffers[buf] = parsedBuffer;
                    gltfRuntime.buffersCount++;
                  }
                };
                var parseShaders = function(parsedShaders, gltfRuntime) {
                  for (var sha in parsedShaders) {
                    var parsedShader = parsedShaders[sha];
                    gltfRuntime.shaders[sha] = parsedShader;
                    gltfRuntime.shaderscount++;
                  }
                };
                var parseObject = function(parsedObjects, runtimeProperty, gltfRuntime) {
                  for (var object in parsedObjects) {
                    var parsedObject = parsedObjects[object];
                    gltfRuntime[runtimeProperty][object] = parsedObject;
                  }
                };
                var normalizeUVs = function(buffer) {
                  if (!buffer) {
                    return;
                  }
                  for (var i = 0; i < buffer.length / 2; i++) {
                    buffer[i * 2 + 1] = 1 - buffer[i * 2 + 1];
                  }
                };
                var getAttribute = function(attributeParameter) {
                  if (attributeParameter.semantic === "NORMAL") {
                    return "normal";
                  } else if (attributeParameter.semantic === "POSITION") {
                    return "position";
                  } else if (attributeParameter.semantic === "JOINT") {
                    return "matricesIndices";
                  } else if (attributeParameter.semantic === "WEIGHT") {
                    return "matricesWeights";
                  } else if (attributeParameter.semantic === "COLOR") {
                    return "color";
                  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
                    var channel = Number(attributeParameter.semantic.split("_")[1]);
                    return "uv" + (channel === 0 ? "" : channel + 1);
                  }
                  return null;
                };
                var loadAnimations = function(gltfRuntime) {
                  for (var anim in gltfRuntime.animations) {
                    var animation = gltfRuntime.animations[anim];
                    if (!animation.channels || !animation.samplers) {
                      continue;
                    }
                    var lastAnimation = null;
                    for (var i = 0; i < animation.channels.length; i++) {
                      var channel = animation.channels[i];
                      var sampler = animation.samplers[channel.sampler];
                      if (!sampler) {
                        continue;
                      }
                      var inputData = null;
                      var outputData = null;
                      if (animation.parameters) {
                        inputData = animation.parameters[sampler.input];
                        outputData = animation.parameters[sampler.output];
                      } else {
                        inputData = sampler.input;
                        outputData = sampler.output;
                      }
                      var bufferInput = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
                      var bufferOutput = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
                      var targetId = channel.target.id;
                      var targetNode = gltfRuntime.scene.getNodeById(targetId);
                      if (targetNode === null) {
                        targetNode = gltfRuntime.scene.getNodeByName(targetId);
                      }
                      if (targetNode === null) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetId + " to attach to");
                        continue;
                      }
                      var isBone = targetNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone;
                      var targetPath = channel.target.path;
                      var targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
                      if (targetPathIndex !== -1) {
                        targetPath = babylonAnimationPaths[targetPathIndex];
                      }
                      var animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_MATRIX;
                      if (!isBone) {
                        if (targetPath === "rotationQuaternion") {
                          animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_QUATERNION;
                          targetNode.rotationQuaternion = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                        } else {
                          animationType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONTYPE_VECTOR3;
                        }
                      }
                      var babylonAnimation = null;
                      var keys = [];
                      var arrayOffset = 0;
                      var modifyKey = false;
                      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
                        babylonAnimation = lastAnimation;
                        modifyKey = true;
                      }
                      if (!modifyKey) {
                        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                        babylonAnimation = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Animation.ANIMATIONLOOPMODE_CYCLE);
                        gltfRuntime.scene._blockEntityCollection = false;
                      }
                      for (var j = 0; j < bufferInput.length; j++) {
                        var value = null;
                        if (targetPath === "rotationQuaternion") {
                          value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
                          arrayOffset += 4;
                        } else {
                          value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
                          arrayOffset += 3;
                        }
                        if (isBone) {
                          var bone = targetNode;
                          var translation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
                          var rotationQuaternion = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                          var scaling = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero();
                          var mat = bone.getBaseMatrix();
                          if (modifyKey && lastAnimation) {
                            mat = lastAnimation.getKeys()[j].value;
                          }
                          mat.decompose(scaling, rotationQuaternion, translation);
                          if (targetPath === "position") {
                            translation = value;
                          } else if (targetPath === "rotationQuaternion") {
                            rotationQuaternion = value;
                          } else {
                            scaling = value;
                          }
                          value = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Compose(scaling, rotationQuaternion, translation);
                        }
                        if (!modifyKey) {
                          keys.push({
                            frame: bufferInput[j],
                            value
                          });
                        } else if (lastAnimation) {
                          lastAnimation.getKeys()[j].value = value;
                        }
                      }
                      if (!modifyKey && babylonAnimation) {
                        babylonAnimation.setKeys(keys);
                        targetNode.animations.push(babylonAnimation);
                      }
                      lastAnimation = babylonAnimation;
                      gltfRuntime.scene.stopAnimation(targetNode);
                      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1);
                    }
                  }
                };
                var configureBoneTransformation = function(node) {
                  var mat = null;
                  if (node.translation || node.rotation || node.scale) {
                    var scale = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.scale || [1, 1, 1]);
                    var rotation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
                    var position = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.translation || [0, 0, 0]);
                    mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Compose(scale, rotation, position);
                  } else {
                    mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.FromArray(node.matrix);
                  }
                  return mat;
                };
                var getParentBone = function(gltfRuntime, skins, jointName, newSkeleton) {
                  for (var i = 0; i < newSkeleton.bones.length; i++) {
                    if (newSkeleton.bones[i].name === jointName) {
                      return newSkeleton.bones[i];
                    }
                  }
                  var nodes = gltfRuntime.nodes;
                  for (var nde in nodes) {
                    var node = nodes[nde];
                    if (!node.jointName) {
                      continue;
                    }
                    var children = node.children;
                    for (var i = 0; i < children.length; i++) {
                      var child = gltfRuntime.nodes[children[i]];
                      if (!child.jointName) {
                        continue;
                      }
                      if (child.jointName === jointName) {
                        var mat = configureBoneTransformation(node);
                        var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.name || "", newSkeleton, getParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
                        bone.id = nde;
                        return bone;
                      }
                    }
                  }
                  return null;
                };
                var getNodeToRoot = function(nodesToRoot, id) {
                  for (var i = 0; i < nodesToRoot.length; i++) {
                    var nodeToRoot = nodesToRoot[i];
                    for (var j = 0; j < nodeToRoot.node.children.length; j++) {
                      var child = nodeToRoot.node.children[j];
                      if (child === id) {
                        return nodeToRoot.bone;
                      }
                    }
                  }
                  return null;
                };
                var getJointNode = function(gltfRuntime, jointName) {
                  var nodes = gltfRuntime.nodes;
                  var node = nodes[jointName];
                  if (node) {
                    return {
                      node,
                      id: jointName
                    };
                  }
                  for (var nde in nodes) {
                    node = nodes[nde];
                    if (node.jointName === jointName) {
                      return {
                        node,
                        id: nde
                      };
                    }
                  }
                  return null;
                };
                var nodeIsInJoints = function(skins, id) {
                  for (var i = 0; i < skins.jointNames.length; i++) {
                    if (skins.jointNames[i] === id) {
                      return true;
                    }
                  }
                  return false;
                };
                var getNodesToRoot = function(gltfRuntime, newSkeleton, skins, nodesToRoot) {
                  for (var nde in gltfRuntime.nodes) {
                    var node = gltfRuntime.nodes[nde];
                    var id = nde;
                    if (!node.jointName || nodeIsInJoints(skins, node.jointName)) {
                      continue;
                    }
                    var mat = configureBoneTransformation(node);
                    var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.name || "", newSkeleton, null, mat);
                    bone.id = id;
                    nodesToRoot.push({ bone, node, id });
                  }
                  for (var i = 0; i < nodesToRoot.length; i++) {
                    var nodeToRoot = nodesToRoot[i];
                    var children = nodeToRoot.node.children;
                    for (var j = 0; j < children.length; j++) {
                      var child = null;
                      for (var k = 0; k < nodesToRoot.length; k++) {
                        if (nodesToRoot[k].id === children[j]) {
                          child = nodesToRoot[k];
                          break;
                        }
                      }
                      if (child) {
                        child.bone._parent = nodeToRoot.bone;
                        nodeToRoot.bone.children.push(child.bone);
                      }
                    }
                  }
                };
                var importSkeleton = function(gltfRuntime, skins, mesh, newSkeleton) {
                  if (!newSkeleton) {
                    newSkeleton = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Skeleton(skins.name || "", "", gltfRuntime.scene);
                  }
                  if (!skins.babylonSkeleton) {
                    return newSkeleton;
                  }
                  var nodesToRoot = [];
                  var nodesToRootToAdd = [];
                  getNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
                  newSkeleton.bones = [];
                  for (var i = 0; i < skins.jointNames.length; i++) {
                    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
                    if (!jointNode) {
                      continue;
                    }
                    var node = jointNode.node;
                    if (!node) {
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
                      continue;
                    }
                    var id = jointNode.id;
                    var existingBone = gltfRuntime.scene.getBoneById(id);
                    if (existingBone) {
                      newSkeleton.bones.push(existingBone);
                      continue;
                    }
                    var foundBone = false;
                    var parentBone = null;
                    for (var j = 0; j < i; j++) {
                      var jointNode_1 = getJointNode(gltfRuntime, skins.jointNames[j]);
                      if (!jointNode_1) {
                        continue;
                      }
                      var joint = jointNode_1.node;
                      if (!joint) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
                        continue;
                      }
                      var children = joint.children;
                      if (!children) {
                        continue;
                      }
                      foundBone = false;
                      for (var k = 0; k < children.length; k++) {
                        if (children[k] === id) {
                          parentBone = getParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
                          foundBone = true;
                          break;
                        }
                      }
                      if (foundBone) {
                        break;
                      }
                    }
                    var mat = configureBoneTransformation(node);
                    if (!parentBone && nodesToRoot.length > 0) {
                      parentBone = getNodeToRoot(nodesToRoot, id);
                      if (parentBone) {
                        if (nodesToRootToAdd.indexOf(parentBone) === -1) {
                          nodesToRootToAdd.push(parentBone);
                        }
                      }
                    }
                    var bone = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Bone(node.jointName || "", newSkeleton, parentBone, mat);
                    bone.id = id;
                  }
                  var bones = newSkeleton.bones;
                  newSkeleton.bones = [];
                  for (var i = 0; i < skins.jointNames.length; i++) {
                    var jointNode = getJointNode(gltfRuntime, skins.jointNames[i]);
                    if (!jointNode) {
                      continue;
                    }
                    for (var j = 0; j < bones.length; j++) {
                      if (bones[j].id === jointNode.id) {
                        newSkeleton.bones.push(bones[j]);
                        break;
                      }
                    }
                  }
                  newSkeleton.prepare();
                  for (var i = 0; i < nodesToRootToAdd.length; i++) {
                    newSkeleton.bones.push(nodesToRootToAdd[i]);
                  }
                  return newSkeleton;
                };
                var importMesh = function(gltfRuntime, node, meshes, id, newMesh) {
                  if (!newMesh) {
                    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                    newMesh = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh(node.name || "", gltfRuntime.scene);
                    newMesh._parentContainer = gltfRuntime.assetContainer;
                    gltfRuntime.scene._blockEntityCollection = false;
                    newMesh.id = id;
                  }
                  if (!node.babylonNode) {
                    return newMesh;
                  }
                  var subMaterials = [];
                  var vertexData = null;
                  var verticesStarts = [];
                  var verticesCounts = [];
                  var indexStarts = [];
                  var indexCounts = [];
                  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
                    var meshId = meshes[meshIndex];
                    var mesh = gltfRuntime.meshes[meshId];
                    if (!mesh) {
                      continue;
                    }
                    for (var i = 0; i < mesh.primitives.length; i++) {
                      var tempVertexData = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.VertexData();
                      var primitive = mesh.primitives[i];
                      if (primitive.mode !== 4) {
                      }
                      var attributes = primitive.attributes;
                      var accessor = null;
                      var buffer = null;
                      for (var semantic in attributes) {
                        accessor = gltfRuntime.accessors[attributes[semantic]];
                        buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                        if (semantic === "NORMAL") {
                          tempVertexData.normals = new Float32Array(buffer.length);
                          tempVertexData.normals.set(buffer);
                        } else if (semantic === "POSITION") {
                          if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.HomogeneousCoordinates) {
                            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
                            for (var j = 0; j < buffer.length; j += 4) {
                              tempVertexData.positions[j] = buffer[j];
                              tempVertexData.positions[j + 1] = buffer[j + 1];
                              tempVertexData.positions[j + 2] = buffer[j + 2];
                            }
                          } else {
                            tempVertexData.positions = new Float32Array(buffer.length);
                            tempVertexData.positions.set(buffer);
                          }
                          verticesCounts.push(tempVertexData.positions.length);
                        } else if (semantic.indexOf("TEXCOORD_") !== -1) {
                          var channel = Number(semantic.split("_")[1]);
                          var uvKind = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
                          var uvs = new Float32Array(buffer.length);
                          uvs.set(buffer);
                          normalizeUVs(uvs);
                          tempVertexData.set(uvs, uvKind);
                        } else if (semantic === "JOINT") {
                          tempVertexData.matricesIndices = new Float32Array(buffer.length);
                          tempVertexData.matricesIndices.set(buffer);
                        } else if (semantic === "WEIGHT") {
                          tempVertexData.matricesWeights = new Float32Array(buffer.length);
                          tempVertexData.matricesWeights.set(buffer);
                        } else if (semantic === "COLOR") {
                          tempVertexData.colors = new Float32Array(buffer.length);
                          tempVertexData.colors.set(buffer);
                        }
                      }
                      accessor = gltfRuntime.accessors[primitive.indices];
                      if (accessor) {
                        buffer = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
                        tempVertexData.indices = new Int32Array(buffer.length);
                        tempVertexData.indices.set(buffer);
                        indexCounts.push(tempVertexData.indices.length);
                      } else {
                        var indices = [];
                        for (var j = 0; j < tempVertexData.positions.length / 3; j++) {
                          indices.push(j);
                        }
                        tempVertexData.indices = new Int32Array(indices);
                        indexCounts.push(tempVertexData.indices.length);
                      }
                      if (!vertexData) {
                        vertexData = tempVertexData;
                      } else {
                        vertexData.merge(tempVertexData);
                      }
                      var material_1 = gltfRuntime.scene.getMaterialById(primitive.material);
                      subMaterials.push(material_1 === null ? _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material_1);
                      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
                      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
                    }
                  }
                  var material;
                  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                  if (subMaterials.length > 1) {
                    material = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.MultiMaterial("multimat" + id, gltfRuntime.scene);
                    material.subMaterials = subMaterials;
                  } else {
                    material = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial("multimat" + id, gltfRuntime.scene);
                  }
                  if (subMaterials.length === 1) {
                    material = subMaterials[0];
                  }
                  material._parentContainer = gltfRuntime.assetContainer;
                  if (!newMesh.material) {
                    newMesh.material = material;
                  }
                  new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
                  newMesh.computeWorldMatrix(true);
                  gltfRuntime.scene._blockEntityCollection = false;
                  newMesh.subMeshes = [];
                  var index = 0;
                  for (var meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
                    var meshId = meshes[meshIndex];
                    var mesh = gltfRuntime.meshes[meshId];
                    if (!mesh) {
                      continue;
                    }
                    for (var i = 0; i < mesh.primitives.length; i++) {
                      if (mesh.primitives[i].mode !== 4) {
                      }
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
                      index++;
                    }
                  }
                  return newMesh;
                };
                var configureNode = function(newNode, position, rotation, scaling) {
                  if (newNode.position) {
                    newNode.position = position;
                  }
                  if (newNode.rotationQuaternion || newNode.rotation) {
                    newNode.rotationQuaternion = rotation;
                  }
                  if (newNode.scaling) {
                    newNode.scaling = scaling;
                  }
                };
                var configureNodeFromMatrix = function(newNode, node) {
                  if (node.matrix) {
                    var position = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                    var rotation = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
                    var scaling = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0);
                    var mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.FromArray(node.matrix);
                    mat.decompose(scaling, rotation, position);
                    configureNode(newNode, position, rotation, scaling);
                  } else if (node.translation && node.rotation && node.scale) {
                    configureNode(newNode, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.translation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(node.rotation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(node.scale));
                  }
                  newNode.computeWorldMatrix(true);
                };
                var importNode = function(gltfRuntime, node, id) {
                  var lastNode = null;
                  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
                    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
                      return null;
                    }
                  }
                  if (node.skin) {
                    if (node.meshes) {
                      var skin = gltfRuntime.skins[node.skin];
                      var newMesh = importMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
                      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);
                      if (newMesh.skeleton === null) {
                        newMesh.skeleton = importSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);
                        if (!skin.babylonSkeleton) {
                          skin.babylonSkeleton = newMesh.skeleton;
                        }
                      }
                      lastNode = newMesh;
                    }
                  } else if (node.meshes) {
                    var newMesh = importMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
                    lastNode = newMesh;
                  } else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
                    var light = gltfRuntime.lights[node.light];
                    if (light) {
                      if (light.type === "ambient") {
                        var ambienLight = light[light.type];
                        var hemiLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.HemisphericLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                        hemiLight.name = node.name || "";
                        if (ambienLight.color) {
                          hemiLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(ambienLight.color);
                        }
                        lastNode = hemiLight;
                      } else if (light.type === "directional") {
                        var directionalLight = light[light.type];
                        var dirLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                        dirLight.name = node.name || "";
                        if (directionalLight.color) {
                          dirLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(directionalLight.color);
                        }
                        lastNode = dirLight;
                      } else if (light.type === "point") {
                        var pointLight = light[light.type];
                        var ptLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.PointLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene);
                        ptLight.name = node.name || "";
                        if (pointLight.color) {
                          ptLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(pointLight.color);
                        }
                        lastNode = ptLight;
                      } else if (light.type === "spot") {
                        var spotLight = light[light.type];
                        var spLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SpotLight(node.light, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), 0, 0, gltfRuntime.scene);
                        spLight.name = node.name || "";
                        if (spotLight.color) {
                          spLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(spotLight.color);
                        }
                        if (spotLight.fallOfAngle) {
                          spLight.angle = spotLight.fallOfAngle;
                        }
                        if (spotLight.fallOffExponent) {
                          spLight.exponent = spotLight.fallOffExponent;
                        }
                        lastNode = spLight;
                      }
                    }
                  } else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
                    var camera = gltfRuntime.cameras[node.camera];
                    if (camera) {
                      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                      if (camera.type === "orthographic") {
                        var orthoCamera = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.FreeCamera(node.camera, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene, false);
                        orthoCamera.name = node.name || "";
                        orthoCamera.mode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Camera.ORTHOGRAPHIC_CAMERA;
                        orthoCamera.attachControl();
                        lastNode = orthoCamera;
                        orthoCamera._parentContainer = gltfRuntime.assetContainer;
                      } else if (camera.type === "perspective") {
                        var perspectiveCamera = camera[camera.type];
                        var persCamera = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.FreeCamera(node.camera, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero(), gltfRuntime.scene, false);
                        persCamera.name = node.name || "";
                        persCamera.attachControl();
                        if (!perspectiveCamera.aspectRatio) {
                          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
                        }
                        if (perspectiveCamera.znear && perspectiveCamera.zfar) {
                          persCamera.maxZ = perspectiveCamera.zfar;
                          persCamera.minZ = perspectiveCamera.znear;
                        }
                        lastNode = persCamera;
                        persCamera._parentContainer = gltfRuntime.assetContainer;
                      }
                      gltfRuntime.scene._blockEntityCollection = false;
                    }
                  }
                  if (!node.jointName) {
                    if (node.babylonNode) {
                      return node.babylonNode;
                    } else if (lastNode === null) {
                      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                      var dummy = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh(node.name || "", gltfRuntime.scene);
                      dummy._parentContainer = gltfRuntime.assetContainer;
                      gltfRuntime.scene._blockEntityCollection = false;
                      node.babylonNode = dummy;
                      lastNode = dummy;
                    }
                  }
                  if (lastNode !== null) {
                    if (node.matrix && lastNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
                      configureNodeFromMatrix(lastNode, node);
                    } else {
                      var translation = node.translation || [0, 0, 0];
                      var rotation = node.rotation || [0, 0, 0, 1];
                      var scale = node.scale || [1, 1, 1];
                      configureNode(lastNode, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(translation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Quaternion.FromArray(rotation), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(scale));
                    }
                    lastNode.updateCache(true);
                    node.babylonNode = lastNode;
                  }
                  return lastNode;
                };
                var traverseNodes = function(gltfRuntime, id, parent, meshIncluded) {
                  if (meshIncluded === void 0) {
                    meshIncluded = false;
                  }
                  var node = gltfRuntime.nodes[id];
                  var newNode = null;
                  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
                    if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
                      meshIncluded = true;
                    } else {
                      meshIncluded = false;
                    }
                  } else {
                    meshIncluded = true;
                  }
                  if (!node.jointName && meshIncluded) {
                    newNode = importNode(gltfRuntime, node, id);
                    if (newNode !== null) {
                      newNode.id = id;
                      newNode.parent = parent;
                    }
                  }
                  if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                      traverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
                    }
                  }
                };
                var postLoad = function(gltfRuntime) {
                  var currentScene = gltfRuntime.currentScene;
                  if (currentScene) {
                    for (var i = 0; i < currentScene.nodes.length; i++) {
                      traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                    }
                  } else {
                    for (var thing in gltfRuntime.scenes) {
                      currentScene = gltfRuntime.scenes[thing];
                      for (var i = 0; i < currentScene.nodes.length; i++) {
                        traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                      }
                    }
                  }
                  loadAnimations(gltfRuntime);
                  for (var i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
                    var skeleton = gltfRuntime.scene.skeletons[i];
                    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1);
                  }
                };
                var onBindShaderMaterial = function(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) {
                  var materialValues = material.values || technique.parameters;
                  for (var unif in unTreatedUniforms) {
                    var uniform = unTreatedUniforms[unif];
                    var type = uniform.type;
                    if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT2 || type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT3 || type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT4) {
                      if (uniform.semantic && !uniform.source && !uniform.node) {
                        _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
                      } else if (uniform.semantic && (uniform.source || uniform.node)) {
                        var source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
                        if (source === null) {
                          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || "");
                        }
                        if (source === null) {
                          continue;
                        }
                        _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
                      }
                    } else {
                      var value = materialValues[technique.uniforms[unif]];
                      if (!value) {
                        continue;
                      }
                      if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                        var texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
                        if (texture === null || texture === void 0) {
                          continue;
                        }
                        shaderMaterial.getEffect().setTexture(unif, texture);
                      } else {
                        _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
                      }
                    }
                  }
                  onSuccess(shaderMaterial);
                };
                var prepareShaderMaterialUniforms = function(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) {
                  var materialValues = material.values || technique.parameters;
                  var techniqueUniforms = technique.uniforms;
                  var _loop_1 = function(unif2) {
                    var uniform = unTreatedUniforms[unif2];
                    var type = uniform.type;
                    var value = materialValues[techniqueUniforms[unif2]];
                    if (value === void 0) {
                      value = uniform.value;
                    }
                    if (!value) {
                      return "continue";
                    }
                    var onLoadTexture = function(uniformName) {
                      return function(texture) {
                        if (uniform.value && uniformName) {
                          shaderMaterial.setTexture(uniformName, texture);
                          delete unTreatedUniforms[uniformName];
                        }
                      };
                    };
                    if (type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif2), function() {
                        return onLoadTexture(null);
                      });
                    } else {
                      if (uniform.value && _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.SetUniform(shaderMaterial, unif2, material.values ? value : uniform.value, type)) {
                        delete unTreatedUniforms[unif2];
                      }
                    }
                  };
                  for (var unif in unTreatedUniforms) {
                    _loop_1(unif);
                  }
                };
                var onShaderCompileError = function(program, shaderMaterial, onError) {
                  return function(effect, error) {
                    shaderMaterial.dispose(true);
                    onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
                  };
                };
                var onShaderCompileSuccess = function(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) {
                  return function(_) {
                    prepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
                    shaderMaterial.onBind = function(mesh) {
                      onBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
                    };
                  };
                };
                var parseShaderUniforms = function(tokenizer, technique, unTreatedUniforms) {
                  for (var unif in technique.uniforms) {
                    var uniform = technique.uniforms[unif];
                    var uniformParameter = technique.parameters[uniform];
                    if (tokenizer.currentIdentifier === unif) {
                      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
                        var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                        if (transformIndex !== -1) {
                          delete unTreatedUniforms[unif];
                          return babylonTransforms[transformIndex];
                        }
                      }
                    }
                  }
                  return tokenizer.currentIdentifier;
                };
                var importMaterials = function(gltfRuntime) {
                  for (var mat in gltfRuntime.materials) {
                    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, function() {
                    }, function() {
                    });
                  }
                };
                var GLTFLoaderBase = (
                  /** @class */
                  function() {
                    function GLTFLoaderBase2() {
                    }
                    GLTFLoaderBase2.CreateRuntime = function(parsedData, scene, rootUrl) {
                      var gltfRuntime = {
                        extensions: {},
                        accessors: {},
                        buffers: {},
                        bufferViews: {},
                        meshes: {},
                        lights: {},
                        cameras: {},
                        nodes: {},
                        images: {},
                        textures: {},
                        shaders: {},
                        programs: {},
                        samplers: {},
                        techniques: {},
                        materials: {},
                        animations: {},
                        skins: {},
                        extensionsUsed: [],
                        scenes: {},
                        buffersCount: 0,
                        shaderscount: 0,
                        scene,
                        rootUrl,
                        loadedBufferCount: 0,
                        loadedBufferViews: {},
                        loadedShaderCount: 0,
                        importOnlyMeshes: false,
                        dummyNodes: [],
                        assetContainer: null
                      };
                      if (parsedData.extensions) {
                        parseObject(parsedData.extensions, "extensions", gltfRuntime);
                      }
                      if (parsedData.extensionsUsed) {
                        parseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
                      }
                      if (parsedData.buffers) {
                        parseBuffers(parsedData.buffers, gltfRuntime);
                      }
                      if (parsedData.bufferViews) {
                        parseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
                      }
                      if (parsedData.accessors) {
                        parseObject(parsedData.accessors, "accessors", gltfRuntime);
                      }
                      if (parsedData.meshes) {
                        parseObject(parsedData.meshes, "meshes", gltfRuntime);
                      }
                      if (parsedData.lights) {
                        parseObject(parsedData.lights, "lights", gltfRuntime);
                      }
                      if (parsedData.cameras) {
                        parseObject(parsedData.cameras, "cameras", gltfRuntime);
                      }
                      if (parsedData.nodes) {
                        parseObject(parsedData.nodes, "nodes", gltfRuntime);
                      }
                      if (parsedData.images) {
                        parseObject(parsedData.images, "images", gltfRuntime);
                      }
                      if (parsedData.textures) {
                        parseObject(parsedData.textures, "textures", gltfRuntime);
                      }
                      if (parsedData.shaders) {
                        parseShaders(parsedData.shaders, gltfRuntime);
                      }
                      if (parsedData.programs) {
                        parseObject(parsedData.programs, "programs", gltfRuntime);
                      }
                      if (parsedData.samplers) {
                        parseObject(parsedData.samplers, "samplers", gltfRuntime);
                      }
                      if (parsedData.techniques) {
                        parseObject(parsedData.techniques, "techniques", gltfRuntime);
                      }
                      if (parsedData.materials) {
                        parseObject(parsedData.materials, "materials", gltfRuntime);
                      }
                      if (parsedData.animations) {
                        parseObject(parsedData.animations, "animations", gltfRuntime);
                      }
                      if (parsedData.skins) {
                        parseObject(parsedData.skins, "skins", gltfRuntime);
                      }
                      if (parsedData.scenes) {
                        gltfRuntime.scenes = parsedData.scenes;
                      }
                      if (parsedData.scene && parsedData.scenes) {
                        gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
                      }
                      return gltfRuntime;
                    };
                    GLTFLoaderBase2.LoadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
                      var buffer = gltfRuntime.buffers[id];
                      if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(buffer.uri)) {
                        setTimeout(function() {
                          return onSuccess(new Uint8Array(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.DecodeBase64(buffer.uri)));
                        });
                      } else {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, function(data) {
                          return onSuccess(new Uint8Array(data));
                        }, onProgress, void 0, true, function(request) {
                          if (request) {
                            onError(request.status + " " + request.statusText);
                          }
                        });
                      }
                    };
                    GLTFLoaderBase2.LoadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var texture = gltfRuntime.textures[id];
                      if (!texture || !texture.source) {
                        onError("");
                        return;
                      }
                      if (texture.babylonTexture) {
                        onSuccess(null);
                        return;
                      }
                      var source = gltfRuntime.images[texture.source];
                      if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(source.uri)) {
                        setTimeout(function() {
                          return onSuccess(new Uint8Array(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.DecodeBase64(source.uri)));
                        });
                      } else {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + source.uri, function(data) {
                          return onSuccess(new Uint8Array(data));
                        }, void 0, void 0, true, function(request) {
                          if (request) {
                            onError(request.status + " " + request.statusText);
                          }
                        });
                      }
                    };
                    GLTFLoaderBase2.CreateTextureAsync = function(gltfRuntime, id, buffer, onSuccess) {
                      var texture = gltfRuntime.textures[id];
                      if (texture.babylonTexture) {
                        onSuccess(texture.babylonTexture);
                        return;
                      }
                      var sampler = gltfRuntime.samplers[texture.sampler];
                      var createMipMaps = sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_LINEAR;
                      var samplingMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.BILINEAR_SAMPLINGMODE;
                      var blob = buffer == null ? new Blob() : new Blob([buffer]);
                      var blobURL = URL.createObjectURL(blob);
                      var revokeBlobURL = function() {
                        return URL.revokeObjectURL(blobURL);
                      };
                      var newTexture = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
                      if (sampler.wrapS !== void 0) {
                        newTexture.wrapU = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetWrapMode(sampler.wrapS);
                      }
                      if (sampler.wrapT !== void 0) {
                        newTexture.wrapV = _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_2__.GLTFUtils.GetWrapMode(sampler.wrapT);
                      }
                      newTexture.name = id;
                      texture.babylonTexture = newTexture;
                      onSuccess(newTexture);
                    };
                    GLTFLoaderBase2.LoadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var shader = gltfRuntime.shaders[id];
                      if (babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.IsBase64(shader.uri)) {
                        var shaderString = atob(shader.uri.split(",")[1]);
                        if (onSuccess) {
                          onSuccess(shaderString);
                        }
                      } else {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, void 0, void 0, false, function(request) {
                          if (request && onError) {
                            onError(request.status + " " + request.statusText);
                          }
                        });
                      }
                    };
                    GLTFLoaderBase2.LoadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var material = gltfRuntime.materials[id];
                      if (!material.technique) {
                        if (onError) {
                          onError("No technique found.");
                        }
                        return;
                      }
                      var technique = gltfRuntime.techniques[material.technique];
                      if (!technique) {
                        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
                        var defaultMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial(id, gltfRuntime.scene);
                        defaultMaterial._parentContainer = gltfRuntime.assetContainer;
                        gltfRuntime.scene._blockEntityCollection = false;
                        defaultMaterial.diffuseColor = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3(0.5, 0.5, 0.5);
                        defaultMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
                        onSuccess(defaultMaterial);
                        return;
                      }
                      var program = gltfRuntime.programs[technique.program];
                      var states = technique.states;
                      var vertexShader = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.vertexShader + "VertexShader"];
                      var pixelShader = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.fragmentShader + "PixelShader"];
                      var newVertexShader = "";
                      var newPixelShader = "";
                      var vertexTokenizer = new Tokenizer(vertexShader);
                      var pixelTokenizer = new Tokenizer(pixelShader);
                      var unTreatedUniforms = {};
                      var uniforms = [];
                      var attributes = [];
                      var samplers = [];
                      for (var unif in technique.uniforms) {
                        var uniform = technique.uniforms[unif];
                        var uniformParameter = technique.parameters[uniform];
                        unTreatedUniforms[unif] = uniformParameter;
                        if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
                          var transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
                          if (transformIndex !== -1) {
                            uniforms.push(babylonTransforms[transformIndex]);
                            delete unTreatedUniforms[unif];
                          } else {
                            uniforms.push(unif);
                          }
                        } else if (uniformParameter.type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.SAMPLER_2D) {
                          samplers.push(unif);
                        } else {
                          uniforms.push(unif);
                        }
                      }
                      for (var attr in technique.attributes) {
                        var attribute = technique.attributes[attr];
                        var attributeParameter = technique.parameters[attribute];
                        if (attributeParameter.semantic) {
                          var name_1 = getAttribute(attributeParameter);
                          if (name_1) {
                            attributes.push(name_1);
                          }
                        }
                      }
                      while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
                        var tokenType = vertexTokenizer.currentToken;
                        if (tokenType !== ETokenType.IDENTIFIER) {
                          newVertexShader += vertexTokenizer.currentString;
                          continue;
                        }
                        var foundAttribute = false;
                        for (var attr in technique.attributes) {
                          var attribute = technique.attributes[attr];
                          var attributeParameter = technique.parameters[attribute];
                          if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
                            newVertexShader += getAttribute(attributeParameter);
                            foundAttribute = true;
                            break;
                          }
                        }
                        if (foundAttribute) {
                          continue;
                        }
                        newVertexShader += parseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
                      }
                      while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
                        var tokenType = pixelTokenizer.currentToken;
                        if (tokenType !== ETokenType.IDENTIFIER) {
                          newPixelShader += pixelTokenizer.currentString;
                          continue;
                        }
                        newPixelShader += parseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
                      }
                      var shaderPath = {
                        vertex: program.vertexShader + id,
                        fragment: program.fragmentShader + id
                      };
                      var options = {
                        attributes,
                        uniforms,
                        samplers,
                        needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
                      };
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
                      babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
                      var shaderMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
                      shaderMaterial.onError = onShaderCompileError(program, shaderMaterial, onError);
                      shaderMaterial.onCompiled = onShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
                      shaderMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
                      if (states && states.functions) {
                        var functions = states.functions;
                        if (functions.cullFace && functions.cullFace[0] !== _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ECullingType.BACK) {
                          shaderMaterial.backFaceCulling = false;
                        }
                        var blendFunc = functions.blendFuncSeparate;
                        if (blendFunc) {
                          if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_COMBINE;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_ONEONE;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_ADD;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_SUBTRACT;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.DST_COLOR && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ZERO && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_MULTIPLY;
                          } else if (blendFunc[0] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.SRC_ALPHA && blendFunc[1] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE && blendFunc[3] === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EBlendingFunction.ONE) {
                            shaderMaterial.alphaMode = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Constants.ALPHA_MAXIMIZED;
                          }
                        }
                      }
                    };
                    return GLTFLoaderBase2;
                  }()
                );
                var GLTFLoader = (
                  /** @class */
                  function() {
                    function GLTFLoader2() {
                    }
                    GLTFLoader2.RegisterExtension = function(extension) {
                      if (GLTFLoader2.Extensions[extension.name]) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error('Tool with the same name "' + extension.name + '" already exists');
                        return;
                      }
                      GLTFLoader2.Extensions[extension.name] = extension;
                    };
                    GLTFLoader2.prototype.dispose = function() {
                    };
                    GLTFLoader2.prototype._importMeshAsync = function(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {
                      var _this = this;
                      scene.useRightHandedSystem = true;
                      GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function(gltfRuntime) {
                        gltfRuntime.assetContainer = assetContainer;
                        gltfRuntime.importOnlyMeshes = true;
                        if (meshesNames === "") {
                          gltfRuntime.importMeshesNames = [];
                        } else if (typeof meshesNames === "string") {
                          gltfRuntime.importMeshesNames = [meshesNames];
                        } else if (meshesNames && !(meshesNames instanceof Array)) {
                          gltfRuntime.importMeshesNames = [meshesNames];
                        } else {
                          gltfRuntime.importMeshesNames = [];
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn("Argument meshesNames must be of type string or string[]");
                        }
                        _this._createNodes(gltfRuntime);
                        var meshes = [];
                        var skeletons = [];
                        for (var nde in gltfRuntime.nodes) {
                          var node = gltfRuntime.nodes[nde];
                          if (node.babylonNode instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.AbstractMesh) {
                            meshes.push(node.babylonNode);
                          }
                        }
                        for (var skl in gltfRuntime.skins) {
                          var skin = gltfRuntime.skins[skl];
                          if (skin.babylonSkeleton instanceof babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Skeleton) {
                            skeletons.push(skin.babylonSkeleton);
                          }
                        }
                        _this._loadBuffersAsync(gltfRuntime, function() {
                          _this._loadShadersAsync(gltfRuntime, function() {
                            importMaterials(gltfRuntime);
                            postLoad(gltfRuntime);
                            if (!_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading && onSuccess) {
                              onSuccess(meshes, skeletons);
                            }
                          });
                        });
                        if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading && onSuccess) {
                          onSuccess(meshes, skeletons);
                        }
                      }, onError);
                      return true;
                    };
                    GLTFLoader2.prototype.importMeshAsync = function(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {
                      var _this = this;
                      return new Promise(function(resolve, reject) {
                        _this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, function(meshes, skeletons) {
                          resolve({
                            meshes,
                            particleSystems: [],
                            skeletons,
                            animationGroups: [],
                            lights: [],
                            transformNodes: [],
                            geometries: []
                          });
                        }, onProgress, function(message) {
                          reject(new Error(message));
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadAsync = function(scene, data, rootUrl, onSuccess, onProgress, onError) {
                      var _this = this;
                      scene.useRightHandedSystem = true;
                      GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, function(gltfRuntime) {
                        GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, function() {
                          _this._createNodes(gltfRuntime);
                          _this._loadBuffersAsync(gltfRuntime, function() {
                            _this._loadShadersAsync(gltfRuntime, function() {
                              importMaterials(gltfRuntime);
                              postLoad(gltfRuntime);
                              if (!_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading) {
                                onSuccess();
                              }
                            });
                          });
                          if (_glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader.IncrementalLoading) {
                            onSuccess();
                          }
                        }, onError);
                      }, onError);
                    };
                    GLTFLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress) {
                      var _this = this;
                      return new Promise(function(resolve, reject) {
                        _this._loadAsync(scene, data, rootUrl, function() {
                          resolve();
                        }, onProgress, function(message) {
                          reject(new Error(message));
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadShadersAsync = function(gltfRuntime, onload) {
                      var hasShaders = false;
                      var processShader = function(sha2, shader2) {
                        GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha2, function(shaderString) {
                          if (shaderString instanceof ArrayBuffer) {
                            return;
                          }
                          gltfRuntime.loadedShaderCount++;
                          if (shaderString) {
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore[sha2 + (shader2.type === _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
                          }
                          if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
                            onload();
                          }
                        }, function() {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Error when loading shader program named " + sha2 + " located at " + shader2.uri);
                        });
                      };
                      for (var sha in gltfRuntime.shaders) {
                        hasShaders = true;
                        var shader = gltfRuntime.shaders[sha];
                        if (shader) {
                          processShader.bind(this, sha, shader)();
                        } else {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("No shader named: " + sha);
                        }
                      }
                      if (!hasShaders) {
                        onload();
                      }
                    };
                    GLTFLoader2.prototype._loadBuffersAsync = function(gltfRuntime, onLoad) {
                      var hasBuffers = false;
                      var processBuffer = function(buf2, buffer2) {
                        GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf2, function(bufferView) {
                          gltfRuntime.loadedBufferCount++;
                          if (bufferView) {
                            if (bufferView.byteLength != gltfRuntime.buffers[buf2].byteLength) {
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Buffer named " + buf2 + " is length " + bufferView.byteLength + ". Expected: " + buffer2.byteLength);
                            }
                            gltfRuntime.loadedBufferViews[buf2] = bufferView;
                          }
                          if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
                            onLoad();
                          }
                        }, function() {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("Error when loading buffer named " + buf2 + " located at " + buffer2.uri);
                        });
                      };
                      for (var buf in gltfRuntime.buffers) {
                        hasBuffers = true;
                        var buffer = gltfRuntime.buffers[buf];
                        if (buffer) {
                          processBuffer.bind(this, buf, buffer)();
                        } else {
                          babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Error("No buffer named: " + buf);
                        }
                      }
                      if (!hasBuffers) {
                        onLoad();
                      }
                    };
                    GLTFLoader2.prototype._createNodes = function(gltfRuntime) {
                      var currentScene = gltfRuntime.currentScene;
                      if (currentScene) {
                        for (var i = 0; i < currentScene.nodes.length; i++) {
                          traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                        }
                      } else {
                        for (var thing in gltfRuntime.scenes) {
                          currentScene = gltfRuntime.scenes[thing];
                          for (var i = 0; i < currentScene.nodes.length; i++) {
                            traverseNodes(gltfRuntime, currentScene.nodes[i], null);
                          }
                        }
                      }
                    };
                    GLTFLoader2.Extensions = {};
                    return GLTFLoader2;
                  }()
                );
                var GLTFLoaderExtension = (
                  /** @class */
                  function() {
                    function GLTFLoaderExtension2(name) {
                      this._name = name;
                    }
                    Object.defineProperty(GLTFLoaderExtension2.prototype, "name", {
                      get: function() {
                        return this._name;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFLoaderExtension2.prototype.loadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.createTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.prototype.loadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      return false;
                    };
                    GLTFLoaderExtension2.LoadRuntimeAsync = function(scene, data, rootUrl, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
                      }, function() {
                        setTimeout(function() {
                          if (!onSuccess) {
                            return;
                          }
                          onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
                        });
                      });
                    };
                    GLTFLoaderExtension2.LoadRuntimeExtensionsAsync = function(gltfRuntime, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
                      }, function() {
                        setTimeout(function() {
                          onSuccess();
                        });
                      });
                    };
                    GLTFLoaderExtension2.LoadBufferAsync = function(gltfRuntime, id, onSuccess, onError, onProgress) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
                      }, function() {
                        GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
                      });
                    };
                    GLTFLoaderExtension2.LoadTextureAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._LoadTextureBufferAsync(gltfRuntime, id, function(buffer) {
                        if (buffer) {
                          GLTFLoaderExtension2._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
                        }
                      }, onError);
                    };
                    GLTFLoaderExtension2.LoadShaderStringAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
                      });
                    };
                    GLTFLoaderExtension2.LoadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
                      });
                    };
                    GLTFLoaderExtension2._LoadTextureBufferAsync = function(gltfRuntime, id, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
                      });
                    };
                    GLTFLoaderExtension2._CreateTextureAsync = function(gltfRuntime, id, buffer, onSuccess, onError) {
                      GLTFLoaderExtension2._ApplyExtensions(function(loaderExtension) {
                        return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
                      }, function() {
                        GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);
                      });
                    };
                    GLTFLoaderExtension2._ApplyExtensions = function(func, defaultFunc) {
                      for (var extensionName in GLTFLoader.Extensions) {
                        var loaderExtension = GLTFLoader.Extensions[extensionName];
                        if (func(loaderExtension)) {
                          return;
                        }
                      }
                      defaultFunc();
                    };
                    return GLTFLoaderExtension2;
                  }()
                );
                _glTFFileLoader__WEBPACK_IMPORTED_MODULE_3__.GLTFFileLoader._CreateGLTF1Loader = function() {
                  return new GLTFLoader();
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts": (
              /*!*****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts ***!
                \*****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EBlendingFunction: () => (
                    /* binding */
                    EBlendingFunction
                  ),
                  /* harmony export */
                  EComponentType: () => (
                    /* binding */
                    EComponentType
                  ),
                  /* harmony export */
                  ECullingType: () => (
                    /* binding */
                    ECullingType
                  ),
                  /* harmony export */
                  EParameterType: () => (
                    /* binding */
                    EParameterType
                  ),
                  /* harmony export */
                  EShaderType: () => (
                    /* binding */
                    EShaderType
                  ),
                  /* harmony export */
                  ETextureFilterType: () => (
                    /* binding */
                    ETextureFilterType
                  ),
                  /* harmony export */
                  ETextureFormat: () => (
                    /* binding */
                    ETextureFormat
                  ),
                  /* harmony export */
                  ETextureWrapMode: () => (
                    /* binding */
                    ETextureWrapMode
                  )
                  /* harmony export */
                });
                var EComponentType;
                (function(EComponentType2) {
                  EComponentType2[EComponentType2["BYTE"] = 5120] = "BYTE";
                  EComponentType2[EComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
                  EComponentType2[EComponentType2["SHORT"] = 5122] = "SHORT";
                  EComponentType2[EComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
                  EComponentType2[EComponentType2["FLOAT"] = 5126] = "FLOAT";
                })(EComponentType || (EComponentType = {}));
                var EShaderType;
                (function(EShaderType2) {
                  EShaderType2[EShaderType2["FRAGMENT"] = 35632] = "FRAGMENT";
                  EShaderType2[EShaderType2["VERTEX"] = 35633] = "VERTEX";
                })(EShaderType || (EShaderType = {}));
                var EParameterType;
                (function(EParameterType2) {
                  EParameterType2[EParameterType2["BYTE"] = 5120] = "BYTE";
                  EParameterType2[EParameterType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
                  EParameterType2[EParameterType2["SHORT"] = 5122] = "SHORT";
                  EParameterType2[EParameterType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
                  EParameterType2[EParameterType2["INT"] = 5124] = "INT";
                  EParameterType2[EParameterType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
                  EParameterType2[EParameterType2["FLOAT"] = 5126] = "FLOAT";
                  EParameterType2[EParameterType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
                  EParameterType2[EParameterType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
                  EParameterType2[EParameterType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
                  EParameterType2[EParameterType2["INT_VEC2"] = 35667] = "INT_VEC2";
                  EParameterType2[EParameterType2["INT_VEC3"] = 35668] = "INT_VEC3";
                  EParameterType2[EParameterType2["INT_VEC4"] = 35669] = "INT_VEC4";
                  EParameterType2[EParameterType2["BOOL"] = 35670] = "BOOL";
                  EParameterType2[EParameterType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
                  EParameterType2[EParameterType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
                  EParameterType2[EParameterType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
                  EParameterType2[EParameterType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
                  EParameterType2[EParameterType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
                  EParameterType2[EParameterType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
                  EParameterType2[EParameterType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
                })(EParameterType || (EParameterType = {}));
                var ETextureWrapMode;
                (function(ETextureWrapMode2) {
                  ETextureWrapMode2[ETextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
                  ETextureWrapMode2[ETextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
                  ETextureWrapMode2[ETextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
                })(ETextureWrapMode || (ETextureWrapMode = {}));
                var ETextureFilterType;
                (function(ETextureFilterType2) {
                  ETextureFilterType2[ETextureFilterType2["NEAREST"] = 9728] = "NEAREST";
                  ETextureFilterType2[ETextureFilterType2["LINEAR"] = 9728] = "LINEAR";
                  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
                  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
                  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
                  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
                })(ETextureFilterType || (ETextureFilterType = {}));
                var ETextureFormat;
                (function(ETextureFormat2) {
                  ETextureFormat2[ETextureFormat2["ALPHA"] = 6406] = "ALPHA";
                  ETextureFormat2[ETextureFormat2["RGB"] = 6407] = "RGB";
                  ETextureFormat2[ETextureFormat2["RGBA"] = 6408] = "RGBA";
                  ETextureFormat2[ETextureFormat2["LUMINANCE"] = 6409] = "LUMINANCE";
                  ETextureFormat2[ETextureFormat2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
                })(ETextureFormat || (ETextureFormat = {}));
                var ECullingType;
                (function(ECullingType2) {
                  ECullingType2[ECullingType2["FRONT"] = 1028] = "FRONT";
                  ECullingType2[ECullingType2["BACK"] = 1029] = "BACK";
                  ECullingType2[ECullingType2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
                })(ECullingType || (ECullingType = {}));
                var EBlendingFunction;
                (function(EBlendingFunction2) {
                  EBlendingFunction2[EBlendingFunction2["ZERO"] = 0] = "ZERO";
                  EBlendingFunction2[EBlendingFunction2["ONE"] = 1] = "ONE";
                  EBlendingFunction2[EBlendingFunction2["SRC_COLOR"] = 768] = "SRC_COLOR";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
                  EBlendingFunction2[EBlendingFunction2["DST_COLOR"] = 774] = "DST_COLOR";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
                  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["DST_ALPHA"] = 772] = "DST_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
                  EBlendingFunction2[EBlendingFunction2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
                  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
                })(EBlendingFunction || (EBlendingFunction = {}));
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts": (
              /*!************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts ***!
                \************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFUtils: () => (
                    /* binding */
                    GLTFUtils
                  )
                  /* harmony export */
                });
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/texture */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
                var GLTFUtils = (
                  /** @class */
                  function() {
                    function GLTFUtils2() {
                    }
                    GLTFUtils2.SetMatrix = function(scene, source, parameter, uniformName, shaderMaterial) {
                      var mat = null;
                      if (parameter.semantic === "MODEL") {
                        mat = source.getWorldMatrix();
                      } else if (parameter.semantic === "PROJECTION") {
                        mat = scene.getProjectionMatrix();
                      } else if (parameter.semantic === "VIEW") {
                        mat = scene.getViewMatrix();
                      } else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
                        mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
                      } else if (parameter.semantic === "MODELVIEW") {
                        mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
                      } else if (parameter.semantic === "MODELVIEWPROJECTION") {
                        mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
                      } else if (parameter.semantic === "MODELINVERSE") {
                        mat = source.getWorldMatrix().invert();
                      } else if (parameter.semantic === "VIEWINVERSE") {
                        mat = scene.getViewMatrix().invert();
                      } else if (parameter.semantic === "PROJECTIONINVERSE") {
                        mat = scene.getProjectionMatrix().invert();
                      } else if (parameter.semantic === "MODELVIEWINVERSE") {
                        mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
                      } else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
                        mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
                      } else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
                        mat = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.Transpose(source.getWorldMatrix().invert());
                      }
                      if (mat) {
                        switch (parameter.type) {
                          case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT2:
                            shaderMaterial.setMatrix2x2(uniformName, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.GetAsMatrix2x2(mat));
                            break;
                          case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT3:
                            shaderMaterial.setMatrix3x3(uniformName, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Matrix.GetAsMatrix3x3(mat));
                            break;
                          case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_MAT4:
                            shaderMaterial.setMatrix(uniformName, mat);
                            break;
                          default:
                            break;
                        }
                      }
                    };
                    GLTFUtils2.SetUniform = function(shaderMaterial, uniform, value, type) {
                      switch (type) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT:
                          shaderMaterial.setFloat(uniform, value);
                          return true;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC2:
                          shaderMaterial.setVector2(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2.FromArray(value));
                          return true;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC3:
                          shaderMaterial.setVector3(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.FromArray(value));
                          return true;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EParameterType.FLOAT_VEC4:
                          shaderMaterial.setVector4(uniform, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector4.FromArray(value));
                          return true;
                        default:
                          return false;
                      }
                    };
                    GLTFUtils2.GetWrapMode = function(mode) {
                      switch (mode) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.CLAMP_TO_EDGE:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.CLAMP_ADDRESSMODE;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.MIRRORED_REPEAT:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.MIRROR_ADDRESSMODE;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureWrapMode.REPEAT:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_ADDRESSMODE;
                        default:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.WRAP_ADDRESSMODE;
                      }
                    };
                    GLTFUtils2.GetByteStrideFromType = function(accessor) {
                      var type = accessor.type;
                      switch (type) {
                        case "VEC2":
                          return 2;
                        case "VEC3":
                          return 3;
                        case "VEC4":
                          return 4;
                        case "MAT2":
                          return 4;
                        case "MAT3":
                          return 9;
                        case "MAT4":
                          return 16;
                        default:
                          return 1;
                      }
                    };
                    GLTFUtils2.GetTextureFilterMode = function(mode) {
                      switch (mode) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR:
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_NEAREST:
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.LINEAR_MIPMAP_LINEAR:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.TRILINEAR_SAMPLINGMODE;
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST:
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.ETextureFilterType.NEAREST_MIPMAP_NEAREST:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.NEAREST_SAMPLINGMODE;
                        default:
                          return babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Texture.BILINEAR_SAMPLINGMODE;
                      }
                    };
                    GLTFUtils2.GetBufferFromBufferView = function(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
                      byteOffset = bufferView.byteOffset + byteOffset;
                      var loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
                      if (byteOffset + byteLength > loadedBufferView.byteLength) {
                        throw new Error("Buffer access is out of range");
                      }
                      var buffer = loadedBufferView.buffer;
                      byteOffset += loadedBufferView.byteOffset;
                      switch (componentType) {
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.BYTE:
                          return new Int8Array(buffer, byteOffset, byteLength);
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.UNSIGNED_BYTE:
                          return new Uint8Array(buffer, byteOffset, byteLength);
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.SHORT:
                          return new Int16Array(buffer, byteOffset, byteLength);
                        case _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_0__.EComponentType.UNSIGNED_SHORT:
                          return new Uint16Array(buffer, byteOffset, byteLength);
                        default:
                          return new Float32Array(buffer, byteOffset, byteLength);
                      }
                    };
                    GLTFUtils2.GetBufferFromAccessor = function(gltfRuntime, accessor) {
                      var bufferView = gltfRuntime.bufferViews[accessor.bufferView];
                      var byteLength = accessor.count * GLTFUtils2.GetByteStrideFromType(accessor);
                      return GLTFUtils2.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
                    };
                    GLTFUtils2.DecodeBufferToText = function(view) {
                      var result = "";
                      var length = view.byteLength;
                      for (var i = 0; i < length; ++i) {
                        result += String.fromCharCode(view[i]);
                      }
                      return result;
                    };
                    GLTFUtils2.GetDefaultMaterial = function(scene) {
                      if (!GLTFUtils2._DefaultMaterial) {
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
                          "precision highp float;",
                          "",
                          "uniform mat4 worldView;",
                          "uniform mat4 projection;",
                          "",
                          "attribute vec3 position;",
                          "",
                          "void main(void)",
                          "{",
                          "    gl_Position = projection * worldView * vec4(position, 1.0);",
                          "}"
                        ].join("\n");
                        babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
                          "precision highp float;",
                          "",
                          "uniform vec4 u_emission;",
                          "",
                          "void main(void)",
                          "{",
                          "    gl_FragColor = u_emission;",
                          "}"
                        ].join("\n");
                        var shaderPath = {
                          vertex: "GLTFDefaultMaterial",
                          fragment: "GLTFDefaultMaterial"
                        };
                        var options = {
                          attributes: ["position"],
                          uniforms: ["worldView", "projection", "u_emission"],
                          samplers: new Array(),
                          needAlphaBlending: false
                        };
                        GLTFUtils2._DefaultMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
                        GLTFUtils2._DefaultMaterial.setColor4("u_emission", new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color4(0.5, 0.5, 0.5, 1));
                      }
                      return GLTFUtils2._DefaultMaterial;
                    };
                    GLTFUtils2._DefaultMaterial = null;
                    return GLTFUtils2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts": (
              /*!*************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts ***!
                \*************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFMaterialsCommonExtension: () => (
                    /* binding */
                    GLTFMaterialsCommonExtension
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Lights/spotLight */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__);
                var GLTFMaterialsCommonExtension = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(GLTFMaterialsCommonExtension2, _super);
                    function GLTFMaterialsCommonExtension2() {
                      return _super.call(this, "KHR_materials_common") || this;
                    }
                    GLTFMaterialsCommonExtension2.prototype.loadRuntimeExtensionsAsync = function(gltfRuntime) {
                      if (!gltfRuntime.extensions) {
                        return false;
                      }
                      var extension = gltfRuntime.extensions[this.name];
                      if (!extension) {
                        return false;
                      }
                      var lights = extension.lights;
                      if (lights) {
                        for (var thing in lights) {
                          var light = lights[thing];
                          switch (light.type) {
                            case "ambient": {
                              var ambientLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.HemisphericLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0), gltfRuntime.scene);
                              var ambient = light.ambient;
                              if (ambient) {
                                ambientLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(ambient.color || [1, 1, 1]);
                              }
                              break;
                            }
                            case "point": {
                              var pointLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.PointLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(10, 10, 10), gltfRuntime.scene);
                              var point = light.point;
                              if (point) {
                                pointLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(point.color || [1, 1, 1]);
                              }
                              break;
                            }
                            case "directional": {
                              var dirLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), gltfRuntime.scene);
                              var directional = light.directional;
                              if (directional) {
                                dirLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(directional.color || [1, 1, 1]);
                              }
                              break;
                            }
                            case "spot": {
                              var spot = light.spot;
                              if (spot) {
                                var spotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.SpotLight(light.name, new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 10, 0), new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0, gltfRuntime.scene);
                                spotLight.diffuse = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(spot.color || [1, 1, 1]);
                              }
                              break;
                            }
                            default:
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Tools.Warn('GLTF Material Common extension: light type "' + light.type + " not supported");
                              break;
                          }
                        }
                      }
                      return false;
                    };
                    GLTFMaterialsCommonExtension2.prototype.loadMaterialAsync = function(gltfRuntime, id, onSuccess, onError) {
                      var material = gltfRuntime.materials[id];
                      if (!material || !material.extensions) {
                        return false;
                      }
                      var extension = material.extensions[this.name];
                      if (!extension) {
                        return false;
                      }
                      var standardMaterial = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.StandardMaterial(id, gltfRuntime.scene);
                      standardMaterial.sideOrientation = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Material.CounterClockWiseSideOrientation;
                      if (extension.technique === "CONSTANT") {
                        standardMaterial.disableLighting = true;
                      }
                      standardMaterial.backFaceCulling = extension.doubleSided === void 0 ? false : !extension.doubleSided;
                      standardMaterial.alpha = extension.values.transparency === void 0 ? 1 : extension.values.transparency;
                      standardMaterial.specularPower = extension.values.shininess === void 0 ? 0 : extension.values.shininess;
                      if (typeof extension.values.ambient === "string") {
                        this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
                      } else {
                        standardMaterial.ambientColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.ambient || [0, 0, 0]);
                      }
                      if (typeof extension.values.diffuse === "string") {
                        this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
                      } else {
                        standardMaterial.diffuseColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
                      }
                      if (typeof extension.values.emission === "string") {
                        this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
                      } else {
                        standardMaterial.emissiveColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.emission || [0, 0, 0]);
                      }
                      if (typeof extension.values.specular === "string") {
                        this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
                      } else {
                        standardMaterial.specularColor = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_1__.Color3.FromArray(extension.values.specular || [0, 0, 0]);
                      }
                      return true;
                    };
                    GLTFMaterialsCommonExtension2.prototype._loadTexture = function(gltfRuntime, id, material, propertyPath, onError) {
                      _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, function(buffer) {
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, function(texture) {
                          return material[propertyPath] = texture;
                        });
                      }, onError);
                    };
                    return GLTFMaterialsCommonExtension2;
                  }(_glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderExtension)
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/1.0/index.ts": (
              /*!**************************************************!*\
                !*** ../../../dev/loaders/src/glTF/1.0/index.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EBlendingFunction: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EBlendingFunction
                  ),
                  /* harmony export */
                  EComponentType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EComponentType
                  ),
                  /* harmony export */
                  ECullingType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ECullingType
                  ),
                  /* harmony export */
                  EParameterType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EParameterType
                  ),
                  /* harmony export */
                  EShaderType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.EShaderType
                  ),
                  /* harmony export */
                  ETextureFilterType: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureFilterType
                  ),
                  /* harmony export */
                  ETextureFormat: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureFormat
                  ),
                  /* harmony export */
                  ETextureWrapMode: () => (
                    /* reexport safe */
                    _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__.ETextureWrapMode
                  ),
                  /* harmony export */
                  GLTFBinaryExtension: () => (
                    /* reexport safe */
                    _glTFBinaryExtension__WEBPACK_IMPORTED_MODULE_0__.GLTFBinaryExtension
                  ),
                  /* harmony export */
                  GLTFLoader: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader
                  ),
                  /* harmony export */
                  GLTFLoaderBase: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderBase
                  ),
                  /* harmony export */
                  GLTFLoaderExtension: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderExtension
                  ),
                  /* harmony export */
                  GLTFMaterialsCommonExtension: () => (
                    /* reexport safe */
                    _glTFMaterialsCommonExtension__WEBPACK_IMPORTED_MODULE_4__.GLTFMaterialsCommonExtension
                  ),
                  /* harmony export */
                  GLTFUtils: () => (
                    /* reexport safe */
                    _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_3__.GLTFUtils
                  )
                  /* harmony export */
                });
                var _glTFBinaryExtension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFBinaryExtension */
                  "../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts"
                );
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoader.ts"
                );
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts"
                );
                var _glTFLoaderUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./glTFLoaderUtils */
                  "../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts"
                );
                var _glTFMaterialsCommonExtension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./glTFMaterialsCommonExtension */
                  "../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_lights_image_based: () => (
                    /* binding */
                    EXT_lights_image_based
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/rawCubeTexture */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "EXT_lights_image_based";
                var EXT_lights_image_based = (
                  /** @class */
                  function() {
                    function EXT_lights_image_based2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    EXT_lights_image_based2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._lights;
                    };
                    EXT_lights_image_based2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._lights = extension.lights;
                      }
                    };
                    EXT_lights_image_based2.prototype.loadSceneAsync = function(context, scene) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function(extensionContext, extension) {
                        _this._loader._allMaterialsDirtyRequired = true;
                        var promises = new Array();
                        promises.push(_this._loader.loadSceneAsync(context, scene));
                        _this._loader.logOpen("".concat(extensionContext));
                        var light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/light"), _this._lights, extension.light);
                        promises.push(_this._loadLightAsync("/extensions/".concat(_this.name, "/lights/").concat(extension.light), light).then(function(texture) {
                          _this._loader.babylonScene.environmentTexture = texture;
                        }));
                        _this._loader.logClose();
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    EXT_lights_image_based2.prototype._loadLightAsync = function(context, light) {
                      var _this = this;
                      if (!light._loaded) {
                        var promises = new Array();
                        this._loader.logOpen("".concat(context));
                        var imageData_1 = new Array(light.specularImages.length);
                        var _loop_1 = function(mipmap2) {
                          var faces = light.specularImages[mipmap2];
                          imageData_1[mipmap2] = new Array(faces.length);
                          var _loop_2 = function(face2) {
                            var specularImageContext = "".concat(context, "/specularImages/").concat(mipmap2, "/").concat(face2);
                            this_1._loader.logOpen("".concat(specularImageContext));
                            var index = faces[face2];
                            var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(specularImageContext, this_1._loader.gltf.images, index);
                            promises.push(this_1._loader.loadImageAsync("/images/".concat(index), image).then(function(data) {
                              imageData_1[mipmap2][face2] = data;
                            }));
                            this_1._loader.logClose();
                          };
                          for (var face = 0; face < faces.length; face++) {
                            _loop_2(face);
                          }
                        };
                        var this_1 = this;
                        for (var mipmap = 0; mipmap < light.specularImages.length; mipmap++) {
                          _loop_1(mipmap);
                        }
                        this._loader.logClose();
                        light._loaded = Promise.all(promises).then(function() {
                          var babylonTexture = new babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.RawCubeTexture(_this._loader.babylonScene, null, light.specularImageSize);
                          babylonTexture.name = light.name || "environment";
                          light._babylonTexture = babylonTexture;
                          if (light.intensity != void 0) {
                            babylonTexture.level = light.intensity;
                          }
                          if (light.rotation) {
                            var rotation = babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(light.rotation);
                            if (!_this._loader.babylonScene.useRightHandedSystem) {
                              rotation = babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Inverse(rotation);
                            }
                            babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());
                          }
                          if (!light.irradianceCoefficients) {
                            throw new Error("".concat(context, ": Irradiance coefficients are missing"));
                          }
                          var sphericalHarmonics = babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.SphericalHarmonics.FromArray(light.irradianceCoefficients);
                          sphericalHarmonics.scaleInPlace(light.intensity);
                          sphericalHarmonics.convertIrradianceToLambertianRadiance();
                          var sphericalPolynomial = babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.SphericalPolynomial.FromHarmonics(sphericalHarmonics);
                          var lodGenerationScale = (imageData_1.length - 1) / babylonjs_Maths_math_scalar__WEBPACK_IMPORTED_MODULE_0__.Scalar.Log2(light.specularImageSize);
                          return babylonTexture.updateRGBDAsync(imageData_1, sphericalPolynomial, lodGenerationScale);
                        });
                      }
                      return light._loaded.then(function() {
                        return light._babylonTexture;
                      });
                    };
                    return EXT_lights_image_based2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new EXT_lights_image_based(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_mesh_gpu_instancing: () => (
                    /* binding */
                    EXT_mesh_gpu_instancing
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Meshes/thinInstanceMesh */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "EXT_mesh_gpu_instancing";
                var EXT_mesh_gpu_instancing = (
                  /** @class */
                  function() {
                    function EXT_mesh_gpu_instancing2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    EXT_mesh_gpu_instancing2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_mesh_gpu_instancing2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        _this._loader._disableInstancedMesh++;
                        var promise = _this._loader.loadNodeAsync("/nodes/".concat(node.index), node, assign);
                        _this._loader._disableInstancedMesh--;
                        if (!node._primitiveBabylonMeshes) {
                          return promise;
                        }
                        var promises = new Array();
                        var instanceCount = 0;
                        var loadAttribute = function(attribute) {
                          if (extension.attributes[attribute] == void 0) {
                            promises.push(Promise.resolve(null));
                            return;
                          }
                          var accessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/attributes/").concat(attribute), _this._loader.gltf.accessors, extension.attributes[attribute]);
                          promises.push(_this._loader._loadFloatAccessorAsync("/accessors/".concat(accessor.bufferView), accessor));
                          if (instanceCount === 0) {
                            instanceCount = accessor.count;
                          } else if (instanceCount !== accessor.count) {
                            throw new Error("".concat(extensionContext, "/attributes: Instance buffer accessors do not have the same count."));
                          }
                        };
                        loadAttribute("TRANSLATION");
                        loadAttribute("ROTATION");
                        loadAttribute("SCALE");
                        return promise.then(function(babylonTransformNode) {
                          return Promise.all(promises).then(function(_a) {
                            var translationBuffer = _a[0], rotationBuffer = _a[1], scaleBuffer = _a[2];
                            var matrices = new Float32Array(instanceCount * 16);
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1);
                            babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);
                            for (var i = 0; i < instanceCount; ++i) {
                              translationBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(translationBuffer, i * 3, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0]);
                              rotationBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArrayToRef(rotationBuffer, i * 4, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0]);
                              scaleBuffer && babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArrayToRef(scaleBuffer, i * 3, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1]);
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Matrix.ComposeToRef(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Quaternion[0], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0], babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0]);
                              babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Matrix[0].copyToArray(matrices, i * 16);
                            }
                            for (var _i = 0, _b = node._primitiveBabylonMeshes; _i < _b.length; _i++) {
                              var babylonMesh = _b[_i];
                              babylonMesh.thinInstanceSetBuffer("matrix", matrices, 16, true);
                            }
                            return babylonTransformNode;
                          });
                        });
                      });
                    };
                    return EXT_mesh_gpu_instancing2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new EXT_mesh_gpu_instancing(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_meshopt_compression: () => (
                    /* binding */
                    EXT_meshopt_compression
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Meshes/Compression/meshoptCompression */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__);
                var NAME = "EXT_meshopt_compression";
                var EXT_meshopt_compression = (
                  /** @class */
                  function() {
                    function EXT_meshopt_compression2(loader) {
                      this.name = NAME;
                      this.enabled = loader.isExtensionUsed(NAME);
                      this._loader = loader;
                    }
                    EXT_meshopt_compression2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_meshopt_compression2.prototype.loadBufferViewAsync = function(context, bufferView) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, bufferView, this.name, function(extensionContext, extension) {
                        var bufferViewMeshopt = bufferView;
                        if (bufferViewMeshopt._meshOptData) {
                          return bufferViewMeshopt._meshOptData;
                        }
                        var buffer = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/buffer"), _this._loader.gltf.buffers, extension.buffer);
                        bufferViewMeshopt._meshOptData = _this._loader.loadBufferAsync("/buffers/".concat(buffer.index), buffer, extension.byteOffset || 0, extension.byteLength).then(function(buffer2) {
                          return babylonjs_Meshes_Compression_meshoptCompression__WEBPACK_IMPORTED_MODULE_1__.MeshoptCompression.Default.decodeGltfBufferAsync(buffer2, extension.count, extension.byteStride, extension.mode, extension.filter);
                        });
                        return bufferViewMeshopt._meshOptData;
                      });
                    };
                    return EXT_meshopt_compression2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new EXT_meshopt_compression(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_texture_webp: () => (
                    /* binding */
                    EXT_texture_webp
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "EXT_texture_webp";
                var EXT_texture_webp = (
                  /** @class */
                  function() {
                    function EXT_texture_webp2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    EXT_texture_webp2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    EXT_texture_webp2.prototype._loadTextureAsync = function(context, texture, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
                        var sampler = texture.sampler == void 0 ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), _this._loader.gltf.samplers, texture.sampler);
                        var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), _this._loader.gltf.images, extension.source);
                        return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
                          assign(babylonTexture);
                        }, void 0, !texture._textureInfo.nonColorData);
                      });
                    };
                    return EXT_texture_webp2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new EXT_texture_webp(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  ExtrasAsMetadata: () => (
                    /* binding */
                    ExtrasAsMetadata
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "ExtrasAsMetadata";
                var ExtrasAsMetadata = (
                  /** @class */
                  function() {
                    function ExtrasAsMetadata2(loader) {
                      this.name = NAME;
                      this.enabled = true;
                      this._loader = loader;
                    }
                    ExtrasAsMetadata2.prototype._assignExtras = function(babylonObject, gltfProp) {
                      if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {
                        var metadata = babylonObject.metadata = babylonObject.metadata || {};
                        var gltf = metadata.gltf = metadata.gltf || {};
                        gltf.extras = gltfProp.extras;
                      }
                    };
                    ExtrasAsMetadata2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    ExtrasAsMetadata2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return this._loader.loadNodeAsync(context, node, function(babylonTransformNode) {
                        _this._assignExtras(babylonTransformNode, node);
                        assign(babylonTransformNode);
                      });
                    };
                    ExtrasAsMetadata2.prototype.loadCameraAsync = function(context, camera, assign) {
                      var _this = this;
                      return this._loader.loadCameraAsync(context, camera, function(babylonCamera) {
                        _this._assignExtras(babylonCamera, camera);
                        assign(babylonCamera);
                      });
                    };
                    ExtrasAsMetadata2.prototype.createMaterial = function(context, material, babylonDrawMode) {
                      var babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);
                      this._assignExtras(babylonMaterial, material);
                      return babylonMaterial;
                    };
                    return ExtrasAsMetadata2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new ExtrasAsMetadata(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  animationPointerTree: () => (
                    /* binding */
                    animationPointerTree
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoaderAnimation */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"
                );
                function getColor3(_target, source, offset, scale) {
                  return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(source, offset).scale(scale);
                }
                function getAlpha(_target, source, offset, scale) {
                  return source[offset + 3] * scale;
                }
                function getFloat(_target, source, offset, scale) {
                  return source[offset] * scale;
                }
                function getMinusFloat(_target, source, offset, scale) {
                  return -source[offset] * scale;
                }
                function getNextFloat(_target, source, offset, scale) {
                  return source[offset + 1] * scale;
                }
                function getFloatBy2(_target, source, offset, scale) {
                  return source[offset] * scale * 2;
                }
                function getTextureTransformTree(textureName) {
                  return {
                    scale: [
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".uScale"), getFloat, function() {
                        return 2;
                      }),
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".vScale"), getNextFloat, function() {
                        return 2;
                      })
                    ],
                    offset: [
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".uOffset"), getFloat, function() {
                        return 2;
                      }),
                      new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".vOffset"), getNextFloat, function() {
                        return 2;
                      })
                    ],
                    rotation: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "".concat(textureName, ".wAng"), getMinusFloat, function() {
                      return 1;
                    })]
                  };
                }
                var CameraAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(CameraAnimationPropertyInfo2, _super);
                    function CameraAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    CameraAnimationPropertyInfo2.prototype.buildAnimations = function(target, name, fps, keys, callback) {
                      callback(target._babylonCamera, this._buildAnimation(name, fps, keys));
                    };
                    return CameraAnimationPropertyInfo2;
                  }(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo)
                );
                var MaterialAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(MaterialAnimationPropertyInfo2, _super);
                    function MaterialAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    MaterialAnimationPropertyInfo2.prototype.buildAnimations = function(target, name, fps, keys, callback) {
                      for (var fillMode in target._data) {
                        callback(target._data[fillMode].babylonMaterial, this._buildAnimation(name, fps, keys));
                      }
                    };
                    return MaterialAnimationPropertyInfo2;
                  }(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo)
                );
                var LightAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__extends)(LightAnimationPropertyInfo2, _super);
                    function LightAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    LightAnimationPropertyInfo2.prototype.buildAnimations = function(target, name, fps, keys, callback) {
                      callback(target._babylonLight, this._buildAnimation(name, fps, keys));
                    };
                    return LightAnimationPropertyInfo2;
                  }(_glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.AnimationPropertyInfo)
                );
                var nodesTree = {
                  __array__: (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({ __target__: true }, _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_1__.nodeAnimationData)
                };
                var camerasTree = {
                  __array__: {
                    __target__: true,
                    orthographic: {
                      xmag: [
                        new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoLeft", getMinusFloat, function() {
                          return 1;
                        }),
                        new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoRight", getNextFloat, function() {
                          return 1;
                        })
                      ],
                      ymag: [
                        new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoBottom", getMinusFloat, function() {
                          return 1;
                        }),
                        new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "orthoTop", getNextFloat, function() {
                          return 1;
                        })
                      ],
                      zfar: [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, function() {
                        return 1;
                      })],
                      znear: [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, function() {
                        return 1;
                      })]
                    },
                    perspective: {
                      yfov: [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "fov", getFloat, function() {
                        return 1;
                      })],
                      zfar: [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, function() {
                        return 1;
                      })],
                      znear: [new CameraAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, function() {
                        return 1;
                      })]
                    }
                  }
                };
                var materialsTree = {
                  __array__: {
                    __target__: true,
                    pbrMetallicRoughness: {
                      baseColorFactor: [
                        new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "albedoColor", getColor3, function() {
                          return 4;
                        }),
                        new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "alpha", getAlpha, function() {
                          return 4;
                        })
                      ],
                      metallicFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "metallic", getFloat, function() {
                        return 1;
                      })],
                      roughnessFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "roughness", getFloat, function() {
                        return 1;
                      })],
                      baseColorTexture: {
                        extensions: {
                          KHR_texture_transform: getTextureTransformTree("albedoTexture")
                        }
                      }
                    },
                    emissiveFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "emissiveColor", getColor3, function() {
                      return 3;
                    })],
                    normalTexture: {
                      scale: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "bumpTexture.level", getFloat, function() {
                        return 1;
                      })]
                    },
                    occlusionTexture: {
                      strength: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "ambientTextureStrength", getFloat, function() {
                        return 1;
                      })],
                      extensions: {
                        KHR_texture_transform: getTextureTransformTree("ambientTexture")
                      }
                    },
                    emissiveTexture: {
                      extensions: {
                        KHR_texture_transform: getTextureTransformTree("emissiveTexture")
                      }
                    },
                    extensions: {
                      KHR_materials_ior: {
                        ior: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "indexOfRefraction", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_clearcoat: {
                        clearcoatFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.intensity", getFloat, function() {
                          return 1;
                        })],
                        clearcoatRoughnessFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "clearCoat.roughness", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_sheen: {
                        sheenColorFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "sheen.color", getColor3, function() {
                          return 3;
                        })],
                        sheenRoughnessFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "sheen.roughness", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_specular: {
                        specularFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "metallicF0Factor", getFloat, function() {
                          return 1;
                        })],
                        specularColorFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", getColor3, function() {
                          return 3;
                        })]
                      },
                      KHR_materials_emissive_strength: {
                        emissiveStrength: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "emissiveIntensity", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_transmission: {
                        transmissionFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_volume: {
                        attenuationColor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", getColor3, function() {
                          return 3;
                        })],
                        attenuationDistance: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance", getFloat, function() {
                          return 1;
                        })],
                        thicknessFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_iridescence: {
                        iridescenceFactor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.intensity", getFloat, function() {
                          return 1;
                        })],
                        iridescenceIor: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction", getFloat, function() {
                          return 1;
                        })],
                        iridescenceThicknessMinimum: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness", getFloat, function() {
                          return 1;
                        })],
                        iridescenceThicknessMaximum: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness", getFloat, function() {
                          return 1;
                        })]
                      },
                      KHR_materials_anisotropy: {
                        anisotropyStrength: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "anisotropy.intensity", getFloat, function() {
                          return 1;
                        })],
                        anisotropyRotation: [new MaterialAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "anisotropy.angle", getFloat, function() {
                          return 1;
                        })]
                      }
                    }
                  }
                };
                var extensionsTree = {
                  KHR_lights_punctual: {
                    lights: {
                      __array__: {
                        __target__: true,
                        color: [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, function() {
                          return 3;
                        })],
                        intensity: [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, function() {
                          return 1;
                        })],
                        range: [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "range", getFloat, function() {
                          return 1;
                        })],
                        spot: {
                          innerConeAngle: [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "innerAngle", getFloatBy2, function() {
                            return 1;
                          })],
                          outerConeAngle: [new LightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "angle", getFloatBy2, function() {
                            return 1;
                          })]
                        }
                      }
                    }
                  }
                };
                var animationPointerTree = {
                  nodes: nodesTree,
                  materials: materialsTree,
                  cameras: camerasTree,
                  extensions: extensionsTree
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_animation_pointer: () => (
                    /* binding */
                    KHR_animation_pointer
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Misc/logger */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__);
                var _KHR_animation_pointer_data__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./KHR_animation_pointer.data */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts"
                );
                var NAME = "KHR_animation_pointer";
                var KHR_animation_pointer = (
                  /** @class */
                  function() {
                    function KHR_animation_pointer2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                    }
                    Object.defineProperty(KHR_animation_pointer2.prototype, "enabled", {
                      /**
                       * Defines whether this extension is enabled.
                       */
                      get: function() {
                        return this._loader.isExtensionUsed(NAME);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    KHR_animation_pointer2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_animation_pointer2.prototype._loadAnimationChannelAsync = function(context, animationContext, animation, channel, onLoad) {
                      var _a;
                      var extension = (_a = channel.target.extensions) === null || _a === void 0 ? void 0 : _a.KHR_animation_pointer;
                      if (!extension) {
                        return null;
                      }
                      if (channel.target.path !== "pointer") {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("".concat(context, "/target/path: Value (").concat(channel.target.path, ") must be (").concat("pointer", ") when using the ").concat(this.name, " extension"));
                      }
                      if (channel.target.node != void 0) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("".concat(context, "/target/node: Value (").concat(channel.target.node, ") must not be present when using the ").concat(this.name, " extension"));
                      }
                      var extensionContext = "".concat(context, "/extensions/").concat(this.name);
                      var pointer = extension.pointer;
                      if (!pointer) {
                        throw new Error("".concat(extensionContext, ": Pointer is missing"));
                      }
                      var targetInfo = this._parseAnimationPointer("".concat(extensionContext, "/pointer"), pointer);
                      if (!targetInfo) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("".concat(extensionContext, "/pointer: Invalid pointer (").concat(pointer, ") skipped"));
                        return null;
                      }
                      return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);
                    };
                    KHR_animation_pointer2.prototype._parseAnimationPointer = function(context, pointer) {
                      if (!pointer.startsWith("/")) {
                        babylonjs_Misc_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.Warn("".concat(context, ": Value (").concat(pointer, ") must start with a slash"));
                        return null;
                      }
                      var parts = pointer.split("/");
                      parts.shift();
                      var node = _KHR_animation_pointer_data__WEBPACK_IMPORTED_MODULE_2__.animationPointerTree;
                      var gltfCurrentNode = this._loader.gltf;
                      var gltfTargetNode = void 0;
                      for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                        var part = parts_1[_i];
                        if (node.__array__) {
                          node = node.__array__;
                        } else {
                          node = node[part];
                          if (!node) {
                            return null;
                          }
                        }
                        gltfCurrentNode = gltfCurrentNode && gltfCurrentNode[part];
                        if (node.__target__) {
                          gltfTargetNode = gltfCurrentNode;
                        }
                      }
                      if (!gltfTargetNode || !Array.isArray(node)) {
                        return null;
                      }
                      return {
                        target: gltfTargetNode,
                        properties: node
                      };
                    };
                    return KHR_animation_pointer2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_animation_pointer(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_draco_mesh_compression: () => (
                    /* binding */
                    KHR_draco_mesh_compression
                  )
                  /* harmony export */
                });
                var babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Buffers/buffer */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_draco_mesh_compression";
                var KHR_draco_mesh_compression = (
                  /** @class */
                  function() {
                    function KHR_draco_mesh_compression2(loader) {
                      this.name = NAME;
                      this.useNormalizedFlagFromAccessor = true;
                      this._loader = loader;
                      this.enabled = babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.DracoCompression.DecoderAvailable && this._loader.isExtensionUsed(NAME);
                    }
                    KHR_draco_mesh_compression2.prototype.dispose = function() {
                      delete this.dracoCompression;
                      this._loader = null;
                    };
                    KHR_draco_mesh_compression2.prototype._loadVertexDataAsync = function(context, primitive, babylonMesh) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function(extensionContext, extension) {
                        if (primitive.mode != void 0) {
                          if (primitive.mode !== 5 && primitive.mode !== 4) {
                            throw new Error("".concat(context, ": Unsupported mode ").concat(primitive.mode));
                          }
                          if (primitive.mode === 5) {
                            throw new Error("".concat(context, ": Mode ").concat(primitive.mode, " is not currently supported"));
                          }
                        }
                        var attributes = {};
                        var normalized = {};
                        var loadAttribute = function(name, kind) {
                          var uniqueId = extension.attributes[name];
                          if (uniqueId == void 0) {
                            return;
                          }
                          babylonMesh._delayInfo = babylonMesh._delayInfo || [];
                          if (babylonMesh._delayInfo.indexOf(kind) === -1) {
                            babylonMesh._delayInfo.push(kind);
                          }
                          attributes[kind] = uniqueId;
                          if (_this.useNormalizedFlagFromAccessor) {
                            var accessor = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.TryGet(_this._loader.gltf.accessors, primitive.attributes[name]);
                            if (accessor) {
                              normalized[kind] = accessor.normalized || false;
                            }
                          }
                        };
                        loadAttribute("POSITION", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                        loadAttribute("NORMAL", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                        loadAttribute("TANGENT", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind);
                        loadAttribute("TEXCOORD_0", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind);
                        loadAttribute("TEXCOORD_1", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind);
                        loadAttribute("TEXCOORD_2", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV3Kind);
                        loadAttribute("TEXCOORD_3", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV4Kind);
                        loadAttribute("TEXCOORD_4", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV5Kind);
                        loadAttribute("TEXCOORD_5", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV6Kind);
                        loadAttribute("JOINTS_0", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesKind);
                        loadAttribute("WEIGHTS_0", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsKind);
                        loadAttribute("COLOR_0", babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind);
                        var bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this._loader.gltf.bufferViews, extension.bufferView);
                        if (!bufferView._dracoBabylonGeometry) {
                          bufferView._dracoBabylonGeometry = _this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function(data) {
                            var dracoCompression = _this.dracoCompression || babylonjs_Meshes_Compression_dracoCompression__WEBPACK_IMPORTED_MODULE_0__.DracoCompression.Default;
                            return dracoCompression._decodeMeshToGeometryForGltfAsync(babylonMesh.name, _this._loader.babylonScene, data, attributes, normalized).catch(function(error) {
                              throw new Error("".concat(context, ": ").concat(error.message));
                            });
                          });
                        }
                        return bufferView._dracoBabylonGeometry;
                      });
                    };
                    return KHR_draco_mesh_compression2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_draco_mesh_compression(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_lights: () => (
                    /* binding */
                    KHR_lights
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Lights/light */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_lights_punctual";
                var KHR_lights = (
                  /** @class */
                  function() {
                    function KHR_lights2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_lights2.prototype.dispose = function() {
                      this._loader = null;
                      delete this._lights;
                    };
                    KHR_lights2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._lights = extension.lights;
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._lights);
                      }
                    };
                    KHR_lights2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        _this._loader._allMaterialsDirtyRequired = true;
                        return _this._loader.loadNodeAsync(context, node, function(babylonMesh) {
                          var babylonLight;
                          var light = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(extensionContext, _this._lights, extension.light);
                          var name = light.name || babylonMesh.name;
                          _this._loader.babylonScene._blockEntityCollection = !!_this._loader._assetContainer;
                          switch (light.type) {
                            case "directional": {
                              var babylonDirectionalLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), _this._loader.babylonScene);
                              babylonDirectionalLight.position.setAll(0);
                              babylonLight = babylonDirectionalLight;
                              break;
                            }
                            case "point": {
                              babylonLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.PointLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), _this._loader.babylonScene);
                              break;
                            }
                            case "spot": {
                              var babylonSpotLight = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.SpotLight(name, babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Backward(), 0, 1, _this._loader.babylonScene);
                              babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;
                              babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;
                              babylonLight = babylonSpotLight;
                              break;
                            }
                            default: {
                              _this._loader.babylonScene._blockEntityCollection = false;
                              throw new Error("".concat(extensionContext, ": Invalid light type (").concat(light.type, ")"));
                            }
                          }
                          babylonLight._parentContainer = _this._loader._assetContainer;
                          _this._loader.babylonScene._blockEntityCollection = false;
                          light._babylonLight = babylonLight;
                          babylonLight.falloffType = babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Light.FALLOFF_GLTF;
                          babylonLight.diffuse = light.color ? babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(light.color) : babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                          babylonLight.intensity = light.intensity == void 0 ? 1 : light.intensity;
                          babylonLight.range = light.range == void 0 ? Number.MAX_VALUE : light.range;
                          babylonLight.parent = babylonMesh;
                          _this._loader._babylonLights.push(babylonLight);
                          _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);
                          assign(babylonMesh);
                        });
                      });
                    };
                    return KHR_lights2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_lights(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts": (
              /*!********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts ***!
                \********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_anisotropy: () => (
                    /* binding */
                    KHR_materials_anisotropy
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_anisotropy";
                var KHR_materials_anisotropy = (
                  /** @class */
                  function() {
                    function KHR_materials_anisotropy2(loader) {
                      this.name = NAME;
                      this.order = 195;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_anisotropy2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_anisotropy2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_anisotropy2.prototype._loadIridescencePropertiesAsync = function(context, properties, babylonMaterial) {
                      var _a, _b;
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.anisotropy.isEnabled = true;
                      babylonMaterial.anisotropy.intensity = (_a = properties.anisotropyStrength) !== null && _a !== void 0 ? _a : 0;
                      babylonMaterial.anisotropy.angle = (_b = properties.anisotropyRotation) !== null && _b !== void 0 ? _b : 0;
                      if (properties.anisotropyTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/anisotropyTexture"), properties.anisotropyTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Anisotropy Intensity)");
                          babylonMaterial.anisotropy.texture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_anisotropy2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_anisotropy(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts": (
              /*!*******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts ***!
                \*******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_clearcoat: () => (
                    /* binding */
                    KHR_materials_clearcoat
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_clearcoat";
                var KHR_materials_clearcoat = (
                  /** @class */
                  function() {
                    function KHR_materials_clearcoat2(loader) {
                      this.name = NAME;
                      this.order = 190;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_clearcoat2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_clearcoat2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_clearcoat2.prototype._loadClearCoatPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.clearCoat.isEnabled = true;
                      babylonMaterial.clearCoat.useRoughnessFromMainTexture = false;
                      babylonMaterial.clearCoat.remapF0OnInterfaceChange = false;
                      if (properties.clearcoatFactor != void 0) {
                        babylonMaterial.clearCoat.intensity = properties.clearcoatFactor;
                      } else {
                        babylonMaterial.clearCoat.intensity = 0;
                      }
                      if (properties.clearcoatTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatTexture"), properties.clearcoatTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (ClearCoat Intensity)");
                          babylonMaterial.clearCoat.texture = texture;
                        }));
                      }
                      if (properties.clearcoatRoughnessFactor != void 0) {
                        babylonMaterial.clearCoat.roughness = properties.clearcoatRoughnessFactor;
                      } else {
                        babylonMaterial.clearCoat.roughness = 0;
                      }
                      if (properties.clearcoatRoughnessTexture) {
                        properties.clearcoatRoughnessTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatRoughnessTexture"), properties.clearcoatRoughnessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (ClearCoat Roughness)");
                          babylonMaterial.clearCoat.textureRoughness = texture;
                        }));
                      }
                      if (properties.clearcoatNormalTexture) {
                        properties.clearcoatNormalTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/clearcoatNormalTexture"), properties.clearcoatNormalTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (ClearCoat Normal)");
                          babylonMaterial.clearCoat.bumpTexture = texture;
                        }));
                        babylonMaterial.invertNormalMapX = !babylonMaterial.getScene().useRightHandedSystem;
                        babylonMaterial.invertNormalMapY = babylonMaterial.getScene().useRightHandedSystem;
                        if (properties.clearcoatNormalTexture.scale != void 0) {
                          babylonMaterial.clearCoat.bumpTexture.level = properties.clearcoatNormalTexture.scale;
                        }
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_clearcoat2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_clearcoat(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts": (
              /*!***************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts ***!
                \***************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_emissive_strength: () => (
                    /* binding */
                    KHR_materials_emissive_strength
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_emissive_strength";
                var KHR_materials_emissive_strength = (
                  /** @class */
                  function() {
                    function KHR_materials_emissive_strength2(loader) {
                      this.name = NAME;
                      this.order = 170;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_emissive_strength2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_emissive_strength2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        return _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial).then(function() {
                          _this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);
                        });
                      });
                    };
                    KHR_materials_emissive_strength2.prototype._loadEmissiveProperties = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (properties.emissiveStrength !== void 0) {
                        babylonMaterial.emissiveColor.scaleToRef(properties.emissiveStrength, babylonMaterial.emissiveColor);
                      }
                    };
                    return KHR_materials_emissive_strength2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_emissive_strength(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts": (
              /*!*************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts ***!
                \*************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_ior: () => (
                    /* binding */
                    KHR_materials_ior
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_ior";
                var KHR_materials_ior = (
                  /** @class */
                  function() {
                    function KHR_materials_ior2(loader) {
                      this.name = NAME;
                      this.order = 180;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_ior2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_ior2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_ior2.prototype._loadIorPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (properties.ior !== void 0) {
                        babylonMaterial.indexOfRefraction = properties.ior;
                      } else {
                        babylonMaterial.indexOfRefraction = KHR_materials_ior2._DEFAULT_IOR;
                      }
                      return Promise.resolve();
                    };
                    KHR_materials_ior2._DEFAULT_IOR = 1.5;
                    return KHR_materials_ior2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_ior(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts": (
              /*!*********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts ***!
                \*********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_iridescence: () => (
                    /* binding */
                    KHR_materials_iridescence
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_iridescence";
                var KHR_materials_iridescence = (
                  /** @class */
                  function() {
                    function KHR_materials_iridescence2(loader) {
                      this.name = NAME;
                      this.order = 195;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_iridescence2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_iridescence2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_iridescence2.prototype._loadIridescencePropertiesAsync = function(context, properties, babylonMaterial) {
                      var _a, _b, _c, _d, _e;
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.iridescence.isEnabled = true;
                      babylonMaterial.iridescence.intensity = (_a = properties.iridescenceFactor) !== null && _a !== void 0 ? _a : 0;
                      babylonMaterial.iridescence.indexOfRefraction = (_c = (_b = properties.iridescenceIor) !== null && _b !== void 0 ? _b : properties.iridescenceIOR) !== null && _c !== void 0 ? _c : 1.3;
                      babylonMaterial.iridescence.minimumThickness = (_d = properties.iridescenceThicknessMinimum) !== null && _d !== void 0 ? _d : 100;
                      babylonMaterial.iridescence.maximumThickness = (_e = properties.iridescenceThicknessMaximum) !== null && _e !== void 0 ? _e : 400;
                      if (properties.iridescenceTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/iridescenceTexture"), properties.iridescenceTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Iridescence Intensity)");
                          babylonMaterial.iridescence.texture = texture;
                        }));
                      }
                      if (properties.iridescenceThicknessTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/iridescenceThicknessTexture"), properties.iridescenceThicknessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Iridescence Thickness)");
                          babylonMaterial.iridescence.thicknessTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_iridescence2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_iridescence(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts": (
              /*!*******************************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts ***!
                \*******************************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_pbrSpecularGlossiness: () => (
                    /* binding */
                    KHR_materials_pbrSpecularGlossiness
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_pbrSpecularGlossiness";
                var KHR_materials_pbrSpecularGlossiness = (
                  /** @class */
                  function() {
                    function KHR_materials_pbrSpecularGlossiness2(loader) {
                      this.name = NAME;
                      this.order = 200;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_pbrSpecularGlossiness2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_pbrSpecularGlossiness2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadSpecularGlossinessPropertiesAsync(extensionContext, material, extension, babylonMaterial));
                        _this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_pbrSpecularGlossiness2.prototype._loadSpecularGlossinessPropertiesAsync = function(context, material, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.metallic = null;
                      babylonMaterial.roughness = null;
                      if (properties.diffuseFactor) {
                        babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.diffuseFactor);
                        babylonMaterial.alpha = properties.diffuseFactor[3];
                      } else {
                        babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                      }
                      babylonMaterial.reflectivityColor = properties.specularFactor ? babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.specularFactor) : babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                      babylonMaterial.microSurface = properties.glossinessFactor == void 0 ? 1 : properties.glossinessFactor;
                      if (properties.diffuseTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/diffuseTexture"), properties.diffuseTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Diffuse)");
                          babylonMaterial.albedoTexture = texture;
                        }));
                      }
                      if (properties.specularGlossinessTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularGlossinessTexture"), properties.specularGlossinessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Specular Glossiness)");
                          babylonMaterial.reflectivityTexture = texture;
                          babylonMaterial.reflectivityTexture.hasAlpha = true;
                        }));
                        babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_pbrSpecularGlossiness2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_pbrSpecularGlossiness(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_sheen: () => (
                    /* binding */
                    KHR_materials_sheen
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_sheen";
                var KHR_materials_sheen = (
                  /** @class */
                  function() {
                    function KHR_materials_sheen2(loader) {
                      this.name = NAME;
                      this.order = 190;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_sheen2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_sheen2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_sheen2.prototype._loadSheenPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.sheen.isEnabled = true;
                      babylonMaterial.sheen.intensity = 1;
                      if (properties.sheenColorFactor != void 0) {
                        babylonMaterial.sheen.color = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.sheenColorFactor);
                      } else {
                        babylonMaterial.sheen.color = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.Black();
                      }
                      if (properties.sheenColorTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/sheenColorTexture"), properties.sheenColorTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Sheen Color)");
                          babylonMaterial.sheen.texture = texture;
                        }));
                      }
                      if (properties.sheenRoughnessFactor !== void 0) {
                        babylonMaterial.sheen.roughness = properties.sheenRoughnessFactor;
                      } else {
                        babylonMaterial.sheen.roughness = 0;
                      }
                      if (properties.sheenRoughnessTexture) {
                        properties.sheenRoughnessTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/sheenRoughnessTexture"), properties.sheenRoughnessTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Sheen Roughness)");
                          babylonMaterial.sheen.textureRoughness = texture;
                        }));
                      }
                      babylonMaterial.sheen.albedoScaling = true;
                      babylonMaterial.sheen.useRoughnessFromMainTexture = false;
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_sheen2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_sheen(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_specular: () => (
                    /* binding */
                    KHR_materials_specular
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.color */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_specular";
                var KHR_materials_specular = (
                  /** @class */
                  function() {
                    function KHR_materials_specular2(loader) {
                      this.name = NAME;
                      this.order = 190;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_specular2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_specular2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_specular2.prototype._loadSpecularPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      if (properties.specularFactor !== void 0) {
                        babylonMaterial.metallicF0Factor = properties.specularFactor;
                      }
                      if (properties.specularColorFactor !== void 0) {
                        babylonMaterial.metallicReflectanceColor = babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.specularColorFactor);
                      }
                      if (properties.specularTexture) {
                        properties.specularTexture.nonColorData = true;
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularTexture"), properties.specularTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Specular F0 Strength)");
                          babylonMaterial.metallicReflectanceTexture = texture;
                          babylonMaterial.useOnlyMetallicFromMetallicReflectanceTexture = true;
                        }));
                      }
                      if (properties.specularColorTexture) {
                        promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/specularColorTexture"), properties.specularColorTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Specular F0 Color)");
                          babylonMaterial.reflectanceTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_specular2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_specular(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_translucency.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_translucency.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_translucency: () => (
                    /* binding */
                    KHR_materials_translucency
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_translucency";
                var KHR_materials_translucency = (
                  /** @class */
                  function() {
                    function KHR_materials_translucency2(loader) {
                      this.name = NAME;
                      this.order = 174;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      if (this.enabled) {
                        loader.parent.transparencyAsCoverage = true;
                      }
                    }
                    KHR_materials_translucency2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_translucency2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_translucency2.prototype._loadTranslucentPropertiesAsync = function(context, material, babylonMaterial, extension) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var pbrMaterial = babylonMaterial;
                      pbrMaterial.subSurface.isTranslucencyEnabled = true;
                      pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
                      pbrMaterial.subSurface.minimumThickness = 0;
                      pbrMaterial.subSurface.maximumThickness = 0;
                      pbrMaterial.subSurface.useAlbedoToTintTranslucency = true;
                      if (extension.translucencyFactor !== void 0) {
                        pbrMaterial.subSurface.translucencyIntensity = extension.translucencyFactor;
                      } else {
                        pbrMaterial.subSurface.translucencyIntensity = 0;
                        pbrMaterial.subSurface.isTranslucencyEnabled = false;
                        return Promise.resolve();
                      }
                      if (extension.translucencyTexture) {
                        extension.translucencyTexture.nonColorData = true;
                        return this._loader.loadTextureInfoAsync("".concat(context, "/translucencyTexture"), extension.translucencyTexture).then(function(texture) {
                          pbrMaterial.subSurface.translucencyIntensityTexture = texture;
                        });
                      } else {
                        return Promise.resolve();
                      }
                    };
                    return KHR_materials_translucency2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_translucency(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts": (
              /*!**********************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts ***!
                \**********************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_transmission: () => (
                    /* binding */
                    KHR_materials_transmission
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/tools */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var TransmissionHelper = (
                  /** @class */
                  function() {
                    function TransmissionHelper2(options, scene) {
                      var _this = this;
                      this._opaqueRenderTarget = null;
                      this._opaqueMeshesCache = [];
                      this._transparentMeshesCache = [];
                      this._materialObservers = {};
                      this._options = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, TransmissionHelper2._GetDefaultOptions()), options);
                      this._scene = scene;
                      this._scene._transmissionHelper = this;
                      this.onErrorObservable = new babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this._scene.onDisposeObservable.addOnce(function() {
                        _this.dispose();
                      });
                      this._parseScene();
                      this._setupRenderTargets();
                    }
                    TransmissionHelper2._GetDefaultOptions = function() {
                      return {
                        renderSize: 1024,
                        samples: 4,
                        lodGenerationScale: 1,
                        lodGenerationOffset: -4,
                        renderTargetTextureType: babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Constants.TEXTURETYPE_HALF_FLOAT,
                        generateMipmaps: true
                      };
                    };
                    TransmissionHelper2.prototype.updateOptions = function(options) {
                      var _this = this;
                      var newValues = Object.keys(options).filter(function(key) {
                        return _this._options[key] !== options[key];
                      });
                      if (!newValues.length) {
                        return;
                      }
                      var newOptions = (0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)((0, tslib__WEBPACK_IMPORTED_MODULE_2__.__assign)({}, this._options), options);
                      var oldOptions = this._options;
                      this._options = newOptions;
                      if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {
                        this._setupRenderTargets();
                      } else {
                        this._opaqueRenderTarget.samples = newOptions.samples;
                        this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;
                        this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;
                      }
                    };
                    TransmissionHelper2.prototype.getOpaqueTarget = function() {
                      return this._opaqueRenderTarget;
                    };
                    TransmissionHelper2.prototype._shouldRenderAsTransmission = function(material) {
                      if (!material) {
                        return false;
                      }
                      if (material instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial && material.subSurface.isRefractionEnabled) {
                        return true;
                      }
                      return false;
                    };
                    TransmissionHelper2.prototype._addMesh = function(mesh) {
                      var _this = this;
                      this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));
                      babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.Tools.SetImmediate(function() {
                        if (_this._shouldRenderAsTransmission(mesh.material)) {
                          mesh.material.refractionTexture = _this._opaqueRenderTarget;
                          if (_this._transparentMeshesCache.indexOf(mesh) === -1) {
                            _this._transparentMeshesCache.push(mesh);
                          }
                        } else {
                          if (_this._opaqueMeshesCache.indexOf(mesh) === -1) {
                            _this._opaqueMeshesCache.push(mesh);
                          }
                        }
                      });
                    };
                    TransmissionHelper2.prototype._removeMesh = function(mesh) {
                      mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);
                      delete this._materialObservers[mesh.uniqueId];
                      var idx = this._transparentMeshesCache.indexOf(mesh);
                      if (idx !== -1) {
                        this._transparentMeshesCache.splice(idx, 1);
                      }
                      idx = this._opaqueMeshesCache.indexOf(mesh);
                      if (idx !== -1) {
                        this._opaqueMeshesCache.splice(idx, 1);
                      }
                    };
                    TransmissionHelper2.prototype._parseScene = function() {
                      this._scene.meshes.forEach(this._addMesh.bind(this));
                      this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));
                      this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
                    };
                    TransmissionHelper2.prototype._onMeshMaterialChanged = function(mesh) {
                      var transparentIdx = this._transparentMeshesCache.indexOf(mesh);
                      var opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);
                      var useTransmission = this._shouldRenderAsTransmission(mesh.material);
                      if (useTransmission) {
                        if (mesh.material instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial) {
                          mesh.material.subSurface.refractionTexture = this._opaqueRenderTarget;
                        }
                        if (opaqueIdx !== -1) {
                          this._opaqueMeshesCache.splice(opaqueIdx, 1);
                          this._transparentMeshesCache.push(mesh);
                        } else if (transparentIdx === -1) {
                          this._transparentMeshesCache.push(mesh);
                        }
                      } else {
                        if (transparentIdx !== -1) {
                          this._transparentMeshesCache.splice(transparentIdx, 1);
                          this._opaqueMeshesCache.push(mesh);
                        } else if (opaqueIdx === -1) {
                          this._opaqueMeshesCache.push(mesh);
                        }
                      }
                    };
                    TransmissionHelper2.prototype._isRenderTargetValid = function() {
                      var _a;
                      return ((_a = this._opaqueRenderTarget) === null || _a === void 0 ? void 0 : _a.getInternalTexture()) !== null;
                    };
                    TransmissionHelper2.prototype._setupRenderTargets = function() {
                      var _this = this;
                      var _a, _b;
                      if (this._opaqueRenderTarget) {
                        this._opaqueRenderTarget.dispose();
                      }
                      this._opaqueRenderTarget = new babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, this._options.generateMipmaps, void 0, this._options.renderTargetTextureType);
                      this._opaqueRenderTarget.ignoreCameraViewport = true;
                      this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;
                      this._opaqueRenderTarget.clearColor = (_b = (_a = this._options.clearColor) === null || _a === void 0 ? void 0 : _a.clone()) !== null && _b !== void 0 ? _b : this._scene.clearColor.clone();
                      this._opaqueRenderTarget.gammaSpace = false;
                      this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;
                      this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;
                      this._opaqueRenderTarget.samples = this._options.samples;
                      var sceneImageProcessingapplyByPostProcess;
                      var saveSceneEnvIntensity;
                      this._opaqueRenderTarget.onBeforeBindObservable.add(function(opaqueRenderTarget) {
                        saveSceneEnvIntensity = _this._scene.environmentIntensity;
                        _this._scene.environmentIntensity = 1;
                        sceneImageProcessingapplyByPostProcess = _this._scene.imageProcessingConfiguration.applyByPostProcess;
                        if (!_this._options.clearColor) {
                          _this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, _this._scene.getEngine().useExactSrgbConversions);
                        } else {
                          opaqueRenderTarget.clearColor.copyFrom(_this._options.clearColor);
                        }
                        _this._scene.imageProcessingConfiguration._applyByPostProcess = true;
                      });
                      this._opaqueRenderTarget.onAfterUnbindObservable.add(function() {
                        _this._scene.environmentIntensity = saveSceneEnvIntensity;
                        _this._scene.imageProcessingConfiguration._applyByPostProcess = sceneImageProcessingapplyByPostProcess;
                      });
                      this._transparentMeshesCache.forEach(function(mesh) {
                        if (_this._shouldRenderAsTransmission(mesh.material)) {
                          mesh.material.refractionTexture = _this._opaqueRenderTarget;
                        }
                      });
                    };
                    TransmissionHelper2.prototype.dispose = function() {
                      this._scene._transmissionHelper = void 0;
                      if (this._opaqueRenderTarget) {
                        this._opaqueRenderTarget.dispose();
                        this._opaqueRenderTarget = null;
                      }
                      this._transparentMeshesCache = [];
                      this._opaqueMeshesCache = [];
                    };
                    return TransmissionHelper2;
                  }()
                );
                var NAME = "KHR_materials_transmission";
                var KHR_materials_transmission = (
                  /** @class */
                  function() {
                    function KHR_materials_transmission2(loader) {
                      this.name = NAME;
                      this.order = 175;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      if (this.enabled) {
                        loader.parent.transparencyAsCoverage = true;
                      }
                    }
                    KHR_materials_transmission2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_transmission2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_transmission2.prototype._loadTransparentPropertiesAsync = function(context, material, babylonMaterial, extension) {
                      var _a, _b;
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var pbrMaterial = babylonMaterial;
                      pbrMaterial.subSurface.isRefractionEnabled = true;
                      pbrMaterial.subSurface.volumeIndexOfRefraction = 1;
                      pbrMaterial.subSurface.useAlbedoToTintRefraction = true;
                      if (extension.transmissionFactor !== void 0) {
                        pbrMaterial.subSurface.refractionIntensity = extension.transmissionFactor;
                        var scene = pbrMaterial.getScene();
                        if (pbrMaterial.subSurface.refractionIntensity && !scene._transmissionHelper) {
                          new TransmissionHelper({}, pbrMaterial.getScene());
                        } else if (pbrMaterial.subSurface.refractionIntensity && !((_a = scene._transmissionHelper) === null || _a === void 0 ? void 0 : _a._isRenderTargetValid())) {
                          (_b = scene._transmissionHelper) === null || _b === void 0 ? void 0 : _b._setupRenderTargets();
                        }
                      } else {
                        pbrMaterial.subSurface.refractionIntensity = 0;
                        pbrMaterial.subSurface.isRefractionEnabled = false;
                        return Promise.resolve();
                      }
                      pbrMaterial.subSurface.minimumThickness = 0;
                      pbrMaterial.subSurface.maximumThickness = 0;
                      if (extension.transmissionTexture) {
                        extension.transmissionTexture.nonColorData = true;
                        return this._loader.loadTextureInfoAsync("".concat(context, "/transmissionTexture"), extension.transmissionTexture, void 0).then(function(texture) {
                          pbrMaterial.subSurface.refractionIntensityTexture = texture;
                          pbrMaterial.subSurface.useGltfStyleTextures = true;
                        });
                      } else {
                        return Promise.resolve();
                      }
                    };
                    return KHR_materials_transmission2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_transmission(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts": (
              /*!***************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts ***!
                \***************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_unlit: () => (
                    /* binding */
                    KHR_materials_unlit
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_unlit";
                var KHR_materials_unlit = (
                  /** @class */
                  function() {
                    function KHR_materials_unlit2(loader) {
                      this.name = NAME;
                      this.order = 210;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_unlit2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_unlit2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function() {
                        return _this._loadUnlitPropertiesAsync(context, material, babylonMaterial);
                      });
                    };
                    KHR_materials_unlit2.prototype._loadUnlitPropertiesAsync = function(context, material, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.unlit = true;
                      var properties = material.pbrMetallicRoughness;
                      if (properties) {
                        if (properties.baseColorFactor) {
                          babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.baseColorFactor);
                          babylonMaterial.alpha = properties.baseColorFactor[3];
                        } else {
                          babylonMaterial.albedoColor = babylonjs_Maths_math_color__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                        }
                        if (properties.baseColorTexture) {
                          promises.push(this._loader.loadTextureInfoAsync("".concat(context, "/baseColorTexture"), properties.baseColorTexture, function(texture) {
                            texture.name = "".concat(babylonMaterial.name, " (Base Color)");
                            babylonMaterial.albedoTexture = texture;
                          }));
                        }
                      }
                      if (material.doubleSided) {
                        babylonMaterial.backFaceCulling = false;
                        babylonMaterial.twoSidedLighting = true;
                      }
                      this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
                      return Promise.all(promises).then(function() {
                      });
                    };
                    return KHR_materials_unlit2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_unlit(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts": (
              /*!******************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts ***!
                \******************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_variants: () => (
                    /* binding */
                    KHR_materials_variants
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! babylonjs/Meshes/mesh */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__);
                var NAME = "KHR_materials_variants";
                var KHR_materials_variants = (
                  /** @class */
                  function() {
                    function KHR_materials_variants2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_materials_variants2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_materials_variants2.GetAvailableVariants = function(rootMesh) {
                      var extensionMetadata = this._GetExtensionMetadata(rootMesh);
                      if (!extensionMetadata) {
                        return [];
                      }
                      return Object.keys(extensionMetadata.variants);
                    };
                    KHR_materials_variants2.prototype.getAvailableVariants = function(rootMesh) {
                      return KHR_materials_variants2.GetAvailableVariants(rootMesh);
                    };
                    KHR_materials_variants2.SelectVariant = function(rootMesh, variantName) {
                      var extensionMetadata = this._GetExtensionMetadata(rootMesh);
                      if (!extensionMetadata) {
                        throw new Error("Cannot select variant on a glTF mesh that does not have the ".concat(NAME, " extension"));
                      }
                      var select = function(variantName2) {
                        var entries = extensionMetadata.variants[variantName2];
                        if (entries) {
                          for (var _i2 = 0, entries_1 = entries; _i2 < entries_1.length; _i2++) {
                            var entry = entries_1[_i2];
                            entry.mesh.material = entry.material;
                          }
                        }
                      };
                      if (variantName instanceof Array) {
                        for (var _i = 0, variantName_1 = variantName; _i < variantName_1.length; _i++) {
                          var name_1 = variantName_1[_i];
                          select(name_1);
                        }
                      } else {
                        select(variantName);
                      }
                      extensionMetadata.lastSelected = variantName;
                    };
                    KHR_materials_variants2.prototype.selectVariant = function(rootMesh, variantName) {
                      return KHR_materials_variants2.SelectVariant(rootMesh, variantName);
                    };
                    KHR_materials_variants2.Reset = function(rootMesh) {
                      var extensionMetadata = this._GetExtensionMetadata(rootMesh);
                      if (!extensionMetadata) {
                        throw new Error("Cannot reset on a glTF mesh that does not have the ".concat(NAME, " extension"));
                      }
                      for (var _i = 0, _a = extensionMetadata.original; _i < _a.length; _i++) {
                        var entry = _a[_i];
                        entry.mesh.material = entry.material;
                      }
                      extensionMetadata.lastSelected = null;
                    };
                    KHR_materials_variants2.prototype.reset = function(rootMesh) {
                      return KHR_materials_variants2.Reset(rootMesh);
                    };
                    KHR_materials_variants2.GetLastSelectedVariant = function(rootMesh) {
                      var extensionMetadata = this._GetExtensionMetadata(rootMesh);
                      if (!extensionMetadata) {
                        throw new Error("Cannot get the last selected variant on a glTF mesh that does not have the ".concat(NAME, " extension"));
                      }
                      return extensionMetadata.lastSelected;
                    };
                    KHR_materials_variants2.prototype.getLastSelectedVariant = function(rootMesh) {
                      return KHR_materials_variants2.GetLastSelectedVariant(rootMesh);
                    };
                    KHR_materials_variants2._GetExtensionMetadata = function(rootMesh) {
                      var _a, _b;
                      return ((_b = (_a = rootMesh === null || rootMesh === void 0 ? void 0 : rootMesh._internalMetadata) === null || _a === void 0 ? void 0 : _a.gltf) === null || _b === void 0 ? void 0 : _b[NAME]) || null;
                    };
                    KHR_materials_variants2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._variants = extension.variants;
                      }
                    };
                    KHR_materials_variants2.prototype._loadMeshPrimitiveAsync = function(context, name, node, mesh, primitive, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, primitive, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, function(babylonMesh) {
                          assign(babylonMesh);
                          if (babylonMesh instanceof babylonjs_Meshes_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh) {
                            var babylonDrawMode = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader._GetDrawMode(context, primitive.mode);
                            var root_1 = _this._loader.rootBabylonMesh;
                            var metadata = root_1 ? root_1._internalMetadata = root_1._internalMetadata || {} : {};
                            var gltf = metadata.gltf = metadata.gltf || {};
                            var extensionMetadata_1 = gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} };
                            extensionMetadata_1.original.push({ mesh: babylonMesh, material: babylonMesh.material });
                            var _loop_1 = function(mappingIndex2) {
                              var mapping = extension.mappings[mappingIndex2];
                              var material = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/mappings/").concat(mappingIndex2, "/material"), _this._loader.gltf.materials, mapping.material);
                              promises.push(_this._loader._loadMaterialAsync("#/materials/".concat(mapping.material), material, babylonMesh, babylonDrawMode, function(babylonMaterial) {
                                var _loop_2 = function(mappingVariantIndex2) {
                                  var variantIndex = mapping.variants[mappingVariantIndex2];
                                  var variant = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("/extensions/".concat(NAME, "/variants/").concat(variantIndex), _this._variants, variantIndex);
                                  extensionMetadata_1.variants[variant.name] = extensionMetadata_1.variants[variant.name] || [];
                                  extensionMetadata_1.variants[variant.name].push({
                                    mesh: babylonMesh,
                                    material: babylonMaterial
                                  });
                                  babylonMesh.onClonedObservable.add(function(newOne) {
                                    var newMesh = newOne;
                                    var metadata2 = null;
                                    var newRoot = newMesh;
                                    do {
                                      newRoot = newRoot.parent;
                                      if (!newRoot) {
                                        return;
                                      }
                                      metadata2 = KHR_materials_variants2._GetExtensionMetadata(newRoot);
                                    } while (metadata2 === null);
                                    if (root_1 && metadata2 === KHR_materials_variants2._GetExtensionMetadata(root_1)) {
                                      newRoot._internalMetadata = {};
                                      for (var key in root_1._internalMetadata) {
                                        newRoot._internalMetadata[key] = root_1._internalMetadata[key];
                                      }
                                      newRoot._internalMetadata.gltf = [];
                                      for (var key in root_1._internalMetadata.gltf) {
                                        newRoot._internalMetadata.gltf[key] = root_1._internalMetadata.gltf[key];
                                      }
                                      newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };
                                      for (var _i = 0, _a = metadata2.original; _i < _a.length; _i++) {
                                        var original = _a[_i];
                                        newRoot._internalMetadata.gltf[NAME].original.push({
                                          mesh: original.mesh,
                                          material: original.material
                                        });
                                      }
                                      for (var key in metadata2.variants) {
                                        if (Object.prototype.hasOwnProperty.call(metadata2.variants, key)) {
                                          newRoot._internalMetadata.gltf[NAME].variants[key] = [];
                                          for (var _b = 0, _c = metadata2.variants[key]; _b < _c.length; _b++) {
                                            var variantEntry = _c[_b];
                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({
                                              mesh: variantEntry.mesh,
                                              material: variantEntry.material
                                            });
                                          }
                                        }
                                      }
                                      metadata2 = newRoot._internalMetadata.gltf[NAME];
                                    }
                                    for (var _d = 0, _e = metadata2.original; _d < _e.length; _d++) {
                                      var target = _e[_d];
                                      if (target.mesh === babylonMesh) {
                                        target.mesh = newMesh;
                                      }
                                    }
                                    for (var _f = 0, _g = metadata2.variants[variant.name]; _f < _g.length; _f++) {
                                      var target = _g[_f];
                                      if (target.mesh === babylonMesh) {
                                        target.mesh = newMesh;
                                      }
                                    }
                                  });
                                };
                                for (var mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {
                                  _loop_2(mappingVariantIndex);
                                }
                              }));
                            };
                            for (var mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {
                              _loop_1(mappingIndex);
                            }
                          }
                        }));
                        return Promise.all(promises).then(function(_a) {
                          var babylonMesh = _a[0];
                          return babylonMesh;
                        });
                      });
                    };
                    return KHR_materials_variants2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_variants(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts": (
              /*!****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts ***!
                \****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_materials_volume: () => (
                    /* binding */
                    KHR_materials_volume
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_materials_volume";
                var KHR_materials_volume = (
                  /** @class */
                  function() {
                    function KHR_materials_volume2(loader) {
                      this.name = NAME;
                      this.order = 173;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                      if (this.enabled) {
                        this._loader._disableInstancedMesh++;
                      }
                    }
                    KHR_materials_volume2.prototype.dispose = function() {
                      if (this.enabled) {
                        this._loader._disableInstancedMesh--;
                      }
                      this._loader = null;
                    };
                    KHR_materials_volume2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
                        promises.push(_this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    KHR_materials_volume2.prototype._loadVolumePropertiesAsync = function(context, material, babylonMaterial, extension) {
                      if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      if (!babylonMaterial.subSurface.isRefractionEnabled && !babylonMaterial.subSurface.isTranslucencyEnabled || !extension.thicknessFactor) {
                        return Promise.resolve();
                      }
                      babylonMaterial.subSurface.volumeIndexOfRefraction = babylonMaterial.indexOfRefraction;
                      var attenuationDistance = extension.attenuationDistance !== void 0 ? extension.attenuationDistance : Number.MAX_VALUE;
                      babylonMaterial.subSurface.tintColorAtDistance = attenuationDistance;
                      if (extension.attenuationColor !== void 0 && extension.attenuationColor.length == 3) {
                        babylonMaterial.subSurface.tintColor.copyFromFloats(extension.attenuationColor[0], extension.attenuationColor[1], extension.attenuationColor[2]);
                      }
                      babylonMaterial.subSurface.minimumThickness = 0;
                      babylonMaterial.subSurface.maximumThickness = extension.thicknessFactor;
                      babylonMaterial.subSurface.useThicknessAsDepth = true;
                      if (extension.thicknessTexture) {
                        extension.thicknessTexture.nonColorData = true;
                        return this._loader.loadTextureInfoAsync("".concat(context, "/thicknessTexture"), extension.thicknessTexture).then(function(texture) {
                          babylonMaterial.subSurface.thicknessTexture = texture;
                          babylonMaterial.subSurface.useGltfStyleTextures = true;
                        });
                      } else {
                        return Promise.resolve();
                      }
                    };
                    return KHR_materials_volume2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_materials_volume(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_mesh_quantization: () => (
                    /* binding */
                    KHR_mesh_quantization
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_mesh_quantization";
                var KHR_mesh_quantization = (
                  /** @class */
                  function() {
                    function KHR_mesh_quantization2(loader) {
                      this.name = NAME;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_mesh_quantization2.prototype.dispose = function() {
                    };
                    return KHR_mesh_quantization2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_mesh_quantization(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_texture_basisu: () => (
                    /* binding */
                    KHR_texture_basisu
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_texture_basisu";
                var KHR_texture_basisu = (
                  /** @class */
                  function() {
                    function KHR_texture_basisu2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = loader.isExtensionUsed(NAME);
                    }
                    KHR_texture_basisu2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_texture_basisu2.prototype._loadTextureAsync = function(context, texture, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.LoadExtensionAsync(context, texture, this.name, function(extensionContext, extension) {
                        var sampler = texture.sampler == void 0 ? _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.DefaultSampler : _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(context, "/sampler"), _this._loader.gltf.samplers, texture.sampler);
                        var image = _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem.Get("".concat(extensionContext, "/source"), _this._loader.gltf.images, extension.source);
                        return _this._loader._createTextureAsync(context, sampler, image, function(babylonTexture) {
                          assign(babylonTexture);
                        }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : void 0, !texture._textureInfo.nonColorData);
                      });
                    };
                    return KHR_texture_basisu2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_texture_basisu(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts": (
              /*!*****************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts ***!
                \*****************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_texture_transform: () => (
                    /* binding */
                    KHR_texture_transform
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/Textures/texture */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_texture_transform";
                var KHR_texture_transform = (
                  /** @class */
                  function() {
                    function KHR_texture_transform2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_texture_transform2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_texture_transform2.prototype.loadTextureInfoAsync = function(context, textureInfo, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, textureInfo, this.name, function(extensionContext, extension) {
                        return _this._loader.loadTextureInfoAsync(context, textureInfo, function(babylonTexture) {
                          if (!(babylonTexture instanceof babylonjs_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_0__.Texture)) {
                            throw new Error("".concat(extensionContext, ": Texture type not supported"));
                          }
                          if (extension.offset) {
                            babylonTexture.uOffset = extension.offset[0];
                            babylonTexture.vOffset = extension.offset[1];
                          }
                          babylonTexture.uRotationCenter = 0;
                          babylonTexture.vRotationCenter = 0;
                          if (extension.rotation) {
                            babylonTexture.wAng = -extension.rotation;
                          }
                          if (extension.scale) {
                            babylonTexture.uScale = extension.scale[0];
                            babylonTexture.vScale = extension.scale[1];
                          }
                          if (extension.texCoord != void 0) {
                            babylonTexture.coordinatesIndex = extension.texCoord;
                          }
                          assign(babylonTexture);
                        });
                      });
                    };
                    return KHR_texture_transform2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_texture_transform(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts": (
              /*!***********************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts ***!
                \***********************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  KHR_xmp_json_ld: () => (
                    /* binding */
                    KHR_xmp_json_ld
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "KHR_xmp_json_ld";
                var KHR_xmp_json_ld = (
                  /** @class */
                  function() {
                    function KHR_xmp_json_ld2(loader) {
                      this.name = NAME;
                      this.order = 100;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    KHR_xmp_json_ld2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    KHR_xmp_json_ld2.prototype.onLoading = function() {
                      var _a, _b, _c;
                      if (this._loader.rootBabylonMesh === null) {
                        return;
                      }
                      var xmp_gltf = (_a = this._loader.gltf.extensions) === null || _a === void 0 ? void 0 : _a.KHR_xmp_json_ld;
                      var xmp_node = (_c = (_b = this._loader.gltf.asset) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.KHR_xmp_json_ld;
                      if (xmp_gltf && xmp_node) {
                        var packet = +xmp_node.packet;
                        if (xmp_gltf.packets && packet < xmp_gltf.packets.length) {
                          this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};
                          this._loader.rootBabylonMesh.metadata.xmp = xmp_gltf.packets[packet];
                        }
                      }
                    };
                    return KHR_xmp_json_ld2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new KHR_xmp_json_ld(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_audio_emitter: () => (
                    /* binding */
                    MSFT_audio_emitter
                  )
                  /* harmony export */
                });
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Audio/weightedsound */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "MSFT_audio_emitter";
                var MSFT_audio_emitter = (
                  /** @class */
                  function() {
                    function MSFT_audio_emitter2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_audio_emitter2.prototype.dispose = function() {
                      this._loader = null;
                      this._clips = null;
                      this._emitters = null;
                    };
                    MSFT_audio_emitter2.prototype.onLoading = function() {
                      var extensions = this._loader.gltf.extensions;
                      if (extensions && extensions[this.name]) {
                        var extension = extensions[this.name];
                        this._clips = extension.clips;
                        this._emitters = extension.emitters;
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._clips);
                        _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(this._emitters);
                      }
                    };
                    MSFT_audio_emitter2.prototype.loadSceneAsync = function(context, scene) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, scene, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        promises.push(_this._loader.loadSceneAsync(context, scene));
                        for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
                          var emitterIndex = _a[_i];
                          var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/emitters"), _this._emitters, emitterIndex);
                          if (emitter.refDistance != void 0 || emitter.maxDistance != void 0 || emitter.rolloffFactor != void 0 || emitter.distanceModel != void 0 || emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                            throw new Error("".concat(extensionContext, ": Direction or Distance properties are not allowed on emitters attached to a scene"));
                          }
                          promises.push(_this._loadEmitterAsync("".concat(extensionContext, "/emitters/").concat(emitter.index), emitter));
                        }
                        return Promise.all(promises).then(function() {
                        });
                      });
                    };
                    MSFT_audio_emitter2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        var promises = new Array();
                        return _this._loader.loadNodeAsync(extensionContext, node, function(babylonMesh) {
                          var _loop_1 = function(emitterIndex2) {
                            var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(extensionContext, "/emitters"), _this._emitters, emitterIndex2);
                            promises.push(_this._loadEmitterAsync("".concat(extensionContext, "/emitters/").concat(emitter.index), emitter).then(function() {
                              for (var _i2 = 0, _a2 = emitter._babylonSounds; _i2 < _a2.length; _i2++) {
                                var sound = _a2[_i2];
                                sound.attachToMesh(babylonMesh);
                                if (emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                                  sound.setLocalDirectionToMesh(babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.Forward());
                                  sound.setDirectionalCone(2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.innerAngle == void 0 ? Math.PI : emitter.innerAngle), 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.outerAngle == void 0 ? Math.PI : emitter.outerAngle), 0);
                                }
                              }
                            }));
                          };
                          for (var _i = 0, _a = extension.emitters; _i < _a.length; _i++) {
                            var emitterIndex = _a[_i];
                            _loop_1(emitterIndex);
                          }
                          assign(babylonMesh);
                        }).then(function(babylonMesh) {
                          return Promise.all(promises).then(function() {
                            return babylonMesh;
                          });
                        });
                      });
                    };
                    MSFT_audio_emitter2.prototype.loadAnimationAsync = function(context, animation) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, animation, this.name, function(extensionContext, extension) {
                        return _this._loader.loadAnimationAsync(context, animation).then(function(babylonAnimationGroup) {
                          var promises = new Array();
                          _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Assign(extension.events);
                          for (var _i = 0, _a = extension.events; _i < _a.length; _i++) {
                            var event_1 = _a[_i];
                            promises.push(_this._loadAnimationEventAsync("".concat(extensionContext, "/events/").concat(event_1.index), context, animation, event_1, babylonAnimationGroup));
                          }
                          return Promise.all(promises).then(function() {
                            return babylonAnimationGroup;
                          });
                        });
                      });
                    };
                    MSFT_audio_emitter2.prototype._loadClipAsync = function(context, clip) {
                      if (clip._objectURL) {
                        return clip._objectURL;
                      }
                      var promise;
                      if (clip.uri) {
                        promise = this._loader.loadUriAsync(context, clip, clip.uri);
                      } else {
                        var bufferView = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/bufferView"), this._loader.gltf.bufferViews, clip.bufferView);
                        promise = this._loader.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView);
                      }
                      clip._objectURL = promise.then(function(data) {
                        return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));
                      });
                      return clip._objectURL;
                    };
                    MSFT_audio_emitter2.prototype._loadEmitterAsync = function(context, emitter) {
                      var _this = this;
                      emitter._babylonSounds = emitter._babylonSounds || [];
                      if (!emitter._babylonData) {
                        var clipPromises = new Array();
                        var name_1 = emitter.name || "emitter".concat(emitter.index);
                        var options_1 = {
                          loop: false,
                          autoplay: false,
                          volume: emitter.volume == void 0 ? 1 : emitter.volume
                        };
                        var _loop_2 = function(i2) {
                          var clipContext = "/extensions/".concat(this_1.name, "/clips");
                          var clip = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get(clipContext, this_1._clips, emitter.clips[i2].clip);
                          clipPromises.push(this_1._loadClipAsync("".concat(clipContext, "/").concat(emitter.clips[i2].clip), clip).then(function(objectURL) {
                            var sound = emitter._babylonSounds[i2] = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Sound(name_1, objectURL, _this._loader.babylonScene, null, options_1);
                            sound.refDistance = emitter.refDistance || 1;
                            sound.maxDistance = emitter.maxDistance || 256;
                            sound.rolloffFactor = emitter.rolloffFactor || 1;
                            sound.distanceModel = emitter.distanceModel || "exponential";
                          }));
                        };
                        var this_1 = this;
                        for (var i = 0; i < emitter.clips.length; i++) {
                          _loop_2(i);
                        }
                        var promise = Promise.all(clipPromises).then(function() {
                          var weights = emitter.clips.map(function(clip) {
                            return clip.weight || 1;
                          });
                          var weightedSound = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);
                          if (emitter.innerAngle) {
                            weightedSound.directionalConeInnerAngle = 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.innerAngle);
                          }
                          if (emitter.outerAngle) {
                            weightedSound.directionalConeOuterAngle = 2 * babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.Tools.ToDegrees(emitter.outerAngle);
                          }
                          if (emitter.volume) {
                            weightedSound.volume = emitter.volume;
                          }
                          emitter._babylonData.sound = weightedSound;
                        });
                        emitter._babylonData = {
                          loaded: promise
                        };
                      }
                      return emitter._babylonData.loaded;
                    };
                    MSFT_audio_emitter2.prototype._getEventAction = function(context, sound, action, time, startOffset) {
                      switch (action) {
                        case "play": {
                          return function(currentFrame) {
                            var frameOffset = (startOffset || 0) + (currentFrame - time);
                            sound.play(frameOffset);
                          };
                        }
                        case "stop": {
                          return function() {
                            sound.stop();
                          };
                        }
                        case "pause": {
                          return function() {
                            sound.pause();
                          };
                        }
                        default: {
                          throw new Error("".concat(context, ": Unsupported action ").concat(action));
                        }
                      }
                    };
                    MSFT_audio_emitter2.prototype._loadAnimationEventAsync = function(context, animationContext, animation, event, babylonAnimationGroup) {
                      var _this = this;
                      if (babylonAnimationGroup.targetedAnimations.length == 0) {
                        return Promise.resolve();
                      }
                      var babylonAnimation = babylonAnimationGroup.targetedAnimations[0];
                      var emitterIndex = event.emitter;
                      var emitter = _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("/extensions/".concat(this.name, "/emitters"), this._emitters, emitterIndex);
                      return this._loadEmitterAsync(context, emitter).then(function() {
                        var sound = emitter._babylonData.sound;
                        if (sound) {
                          var babylonAnimationEvent = new babylonjs_Maths_math_vector__WEBPACK_IMPORTED_MODULE_0__.AnimationEvent(event.time, _this._getEventAction(context, sound, event.action, event.time, event.startOffset));
                          babylonAnimation.animation.addEvent(babylonAnimationEvent);
                          babylonAnimationGroup.onAnimationGroupEndObservable.add(function() {
                            sound.stop();
                          });
                          babylonAnimationGroup.onAnimationGroupPauseObservable.add(function() {
                            sound.pause();
                          });
                        }
                      });
                    };
                    return MSFT_audio_emitter2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new MSFT_audio_emitter(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_lod: () => (
                    /* binding */
                    MSFT_lod
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/deferred */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "MSFT_lod";
                var MSFT_lod = (
                  /** @class */
                  function() {
                    function MSFT_lod2(loader) {
                      this.name = NAME;
                      this.order = 100;
                      this.maxLODsToLoad = 10;
                      this.onNodeLODsLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onMaterialLODsLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this._bufferLODs = new Array();
                      this._nodeIndexLOD = null;
                      this._nodeSignalLODs = new Array();
                      this._nodePromiseLODs = new Array();
                      this._nodeBufferLODs = new Array();
                      this._materialIndexLOD = null;
                      this._materialSignalLODs = new Array();
                      this._materialPromiseLODs = new Array();
                      this._materialBufferLODs = new Array();
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_lod2.prototype.dispose = function() {
                      this._loader = null;
                      this._nodeIndexLOD = null;
                      this._nodeSignalLODs.length = 0;
                      this._nodePromiseLODs.length = 0;
                      this._nodeBufferLODs.length = 0;
                      this._materialIndexLOD = null;
                      this._materialSignalLODs.length = 0;
                      this._materialPromiseLODs.length = 0;
                      this._materialBufferLODs.length = 0;
                      this.onMaterialLODsLoadedObservable.clear();
                      this.onNodeLODsLoadedObservable.clear();
                    };
                    MSFT_lod2.prototype.onReady = function() {
                      var _this = this;
                      var _loop_1 = function(indexLOD2) {
                        var promise = Promise.all(this_1._nodePromiseLODs[indexLOD2]).then(function() {
                          if (indexLOD2 !== 0) {
                            _this._loader.endPerformanceCounter("Node LOD ".concat(indexLOD2));
                            _this._loader.log("Loaded node LOD ".concat(indexLOD2));
                          }
                          _this.onNodeLODsLoadedObservable.notifyObservers(indexLOD2);
                          if (indexLOD2 !== _this._nodePromiseLODs.length - 1) {
                            _this._loader.startPerformanceCounter("Node LOD ".concat(indexLOD2 + 1));
                            _this._loadBufferLOD(_this._nodeBufferLODs, indexLOD2 + 1);
                            if (_this._nodeSignalLODs[indexLOD2]) {
                              _this._nodeSignalLODs[indexLOD2].resolve();
                            }
                          }
                        });
                        this_1._loader._completePromises.push(promise);
                      };
                      var this_1 = this;
                      for (var indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {
                        _loop_1(indexLOD);
                      }
                      var _loop_2 = function(indexLOD2) {
                        var promise = Promise.all(this_2._materialPromiseLODs[indexLOD2]).then(function() {
                          if (indexLOD2 !== 0) {
                            _this._loader.endPerformanceCounter("Material LOD ".concat(indexLOD2));
                            _this._loader.log("Loaded material LOD ".concat(indexLOD2));
                          }
                          _this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD2);
                          if (indexLOD2 !== _this._materialPromiseLODs.length - 1) {
                            _this._loader.startPerformanceCounter("Material LOD ".concat(indexLOD2 + 1));
                            _this._loadBufferLOD(_this._materialBufferLODs, indexLOD2 + 1);
                            if (_this._materialSignalLODs[indexLOD2]) {
                              _this._materialSignalLODs[indexLOD2].resolve();
                            }
                          }
                        });
                        this_2._loader._completePromises.push(promise);
                      };
                      var this_2 = this;
                      for (var indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {
                        _loop_2(indexLOD);
                      }
                    };
                    MSFT_lod2.prototype.loadSceneAsync = function(context, scene) {
                      var promise = this._loader.loadSceneAsync(context, scene);
                      this._loadBufferLOD(this._bufferLODs, 0);
                      return promise;
                    };
                    MSFT_lod2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, node, this.name, function(extensionContext, extension) {
                        var firstPromise;
                        var nodeLODs = _this._getLODs(extensionContext, node, _this._loader.gltf.nodes, extension.ids);
                        _this._loader.logOpen("".concat(extensionContext));
                        var _loop_3 = function(indexLOD2) {
                          var nodeLOD = nodeLODs[indexLOD2];
                          if (indexLOD2 !== 0) {
                            _this._nodeIndexLOD = indexLOD2;
                            _this._nodeSignalLODs[indexLOD2] = _this._nodeSignalLODs[indexLOD2] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                          }
                          var assignWrap = function(babylonTransformNode) {
                            assign(babylonTransformNode);
                            babylonTransformNode.setEnabled(false);
                          };
                          var promise = _this._loader.loadNodeAsync("/nodes/".concat(nodeLOD.index), nodeLOD, assignWrap).then(function(babylonMesh) {
                            if (indexLOD2 !== 0) {
                              var previousNodeLOD = nodeLODs[indexLOD2 - 1];
                              if (previousNodeLOD._babylonTransformNode) {
                                _this._disposeTransformNode(previousNodeLOD._babylonTransformNode);
                                delete previousNodeLOD._babylonTransformNode;
                              }
                            }
                            babylonMesh.setEnabled(true);
                            return babylonMesh;
                          });
                          _this._nodePromiseLODs[indexLOD2] = _this._nodePromiseLODs[indexLOD2] || [];
                          if (indexLOD2 === 0) {
                            firstPromise = promise;
                          } else {
                            _this._nodeIndexLOD = null;
                            _this._nodePromiseLODs[indexLOD2].push(promise);
                          }
                        };
                        for (var indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {
                          _loop_3(indexLOD);
                        }
                        _this._loader.logClose();
                        return firstPromise;
                      });
                    };
                    MSFT_lod2.prototype._loadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
                      var _this = this;
                      if (this._nodeIndexLOD) {
                        return null;
                      }
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtensionAsync(context, material, this.name, function(extensionContext, extension) {
                        var firstPromise;
                        var materialLODs = _this._getLODs(extensionContext, material, _this._loader.gltf.materials, extension.ids);
                        _this._loader.logOpen("".concat(extensionContext));
                        var _loop_4 = function(indexLOD2) {
                          var materialLOD = materialLODs[indexLOD2];
                          if (indexLOD2 !== 0) {
                            _this._materialIndexLOD = indexLOD2;
                          }
                          var promise = _this._loader._loadMaterialAsync("/materials/".concat(materialLOD.index), materialLOD, babylonMesh, babylonDrawMode, function(babylonMaterial) {
                            if (indexLOD2 === 0) {
                              assign(babylonMaterial);
                            }
                          }).then(function(babylonMaterial) {
                            if (indexLOD2 !== 0) {
                              assign(babylonMaterial);
                              var previousDataLOD = materialLODs[indexLOD2 - 1]._data;
                              if (previousDataLOD[babylonDrawMode]) {
                                _this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);
                                delete previousDataLOD[babylonDrawMode];
                              }
                            }
                            return babylonMaterial;
                          });
                          _this._materialPromiseLODs[indexLOD2] = _this._materialPromiseLODs[indexLOD2] || [];
                          if (indexLOD2 === 0) {
                            firstPromise = promise;
                          } else {
                            _this._materialIndexLOD = null;
                            _this._materialPromiseLODs[indexLOD2].push(promise);
                          }
                        };
                        for (var indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {
                          _loop_4(indexLOD);
                        }
                        _this._loader.logClose();
                        return firstPromise;
                      });
                    };
                    MSFT_lod2.prototype._loadUriAsync = function(context, property, uri) {
                      var _this = this;
                      if (this._nodeIndexLOD !== null) {
                        this._loader.log("deferred");
                        var previousIndexLOD = this._nodeIndexLOD - 1;
                        this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                        return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(function() {
                          return _this._loader.loadUriAsync(context, property, uri);
                        });
                      } else if (this._materialIndexLOD !== null) {
                        this._loader.log("deferred");
                        var previousIndexLOD = this._materialIndexLOD - 1;
                        this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                        return this._materialSignalLODs[previousIndexLOD].promise.then(function() {
                          return _this._loader.loadUriAsync(context, property, uri);
                        });
                      }
                      return null;
                    };
                    MSFT_lod2.prototype.loadBufferAsync = function(context, buffer, byteOffset, byteLength) {
                      if (this._loader.parent.useRangeRequests && !buffer.uri) {
                        if (!this._loader.bin) {
                          throw new Error("".concat(context, ": Uri is missing or the binary glTF is missing its binary chunk"));
                        }
                        var loadAsync = function(bufferLODs, indexLOD) {
                          var start = byteOffset;
                          var end = start + byteLength - 1;
                          var bufferLOD = bufferLODs[indexLOD];
                          if (bufferLOD) {
                            bufferLOD.start = Math.min(bufferLOD.start, start);
                            bufferLOD.end = Math.max(bufferLOD.end, end);
                          } else {
                            bufferLOD = { start, end, loaded: new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Deferred() };
                            bufferLODs[indexLOD] = bufferLOD;
                          }
                          return bufferLOD.loaded.promise.then(function(data) {
                            return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);
                          });
                        };
                        this._loader.log("deferred");
                        if (this._nodeIndexLOD !== null) {
                          return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);
                        } else if (this._materialIndexLOD !== null) {
                          return loadAsync(this._materialBufferLODs, this._materialIndexLOD);
                        } else {
                          return loadAsync(this._bufferLODs, 0);
                        }
                      }
                      return null;
                    };
                    MSFT_lod2.prototype._loadBufferLOD = function(bufferLODs, indexLOD) {
                      var bufferLOD = bufferLODs[indexLOD];
                      if (bufferLOD) {
                        this._loader.log("Loading buffer range [".concat(bufferLOD.start, "-").concat(bufferLOD.end, "]"));
                        this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(function(data) {
                          bufferLOD.loaded.resolve(data);
                        }, function(error) {
                          bufferLOD.loaded.reject(error);
                        });
                      }
                    };
                    MSFT_lod2.prototype._getLODs = function(context, property, array, ids) {
                      if (this.maxLODsToLoad <= 0) {
                        throw new Error("maxLODsToLoad must be greater than zero");
                      }
                      var properties = [];
                      for (var i = ids.length - 1; i >= 0; i--) {
                        properties.push(_glTFLoader__WEBPACK_IMPORTED_MODULE_1__.ArrayItem.Get("".concat(context, "/ids/").concat(ids[i]), array, ids[i]));
                        if (properties.length === this.maxLODsToLoad) {
                          return properties;
                        }
                      }
                      properties.push(property);
                      return properties;
                    };
                    MSFT_lod2.prototype._disposeTransformNode = function(babylonTransformNode) {
                      var _this = this;
                      var babylonMaterials = [];
                      var babylonMaterial = babylonTransformNode.material;
                      if (babylonMaterial) {
                        babylonMaterials.push(babylonMaterial);
                      }
                      for (var _i = 0, _a = babylonTransformNode.getChildMeshes(); _i < _a.length; _i++) {
                        var babylonMesh = _a[_i];
                        if (babylonMesh.material) {
                          babylonMaterials.push(babylonMesh.material);
                        }
                      }
                      babylonTransformNode.dispose();
                      var babylonMaterialsToDispose = babylonMaterials.filter(function(babylonMaterial2) {
                        return _this._loader.babylonScene.meshes.every(function(mesh) {
                          return mesh.material != babylonMaterial2;
                        });
                      });
                      this._disposeMaterials(babylonMaterialsToDispose);
                    };
                    MSFT_lod2.prototype._disposeMaterials = function(babylonMaterials) {
                      var babylonTextures = {};
                      for (var _i = 0, babylonMaterials_1 = babylonMaterials; _i < babylonMaterials_1.length; _i++) {
                        var babylonMaterial = babylonMaterials_1[_i];
                        for (var _a = 0, _b = babylonMaterial.getActiveTextures(); _a < _b.length; _a++) {
                          var babylonTexture = _b[_a];
                          babylonTextures[babylonTexture.uniqueId] = babylonTexture;
                        }
                        babylonMaterial.dispose();
                      }
                      for (var uniqueId in babylonTextures) {
                        for (var _c = 0, _d = this._loader.babylonScene.materials; _c < _d.length; _c++) {
                          var babylonMaterial = _d[_c];
                          if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {
                            delete babylonTextures[uniqueId];
                          }
                        }
                      }
                      for (var uniqueId in babylonTextures) {
                        babylonTextures[uniqueId].dispose();
                      }
                    };
                    return MSFT_lod2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new MSFT_lod(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts": (
              /*!**************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts ***!
                \**************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_minecraftMesh: () => (
                    /* binding */
                    MSFT_minecraftMesh
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "MSFT_minecraftMesh";
                var MSFT_minecraftMesh = (
                  /** @class */
                  function() {
                    function MSFT_minecraftMesh2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_minecraftMesh2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    MSFT_minecraftMesh2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtraAsync(context, material, this.name, function(extraContext, extra) {
                        if (extra) {
                          if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(extraContext, ": Material type not supported"));
                          }
                          var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                          if (babylonMaterial.needAlphaBlending()) {
                            babylonMaterial.forceDepthWrite = true;
                            babylonMaterial.separateCullingPass = true;
                          }
                          babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;
                          babylonMaterial.twoSidedLighting = true;
                          return promise;
                        }
                        return null;
                      });
                    };
                    return MSFT_minecraftMesh2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new MSFT_minecraftMesh(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts": (
              /*!************************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts ***!
                \************************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MSFT_sRGBFactors: () => (
                    /* binding */
                    MSFT_sRGBFactors
                  )
                  /* harmony export */
                });
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Materials/PBR/pbrMaterial */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var NAME = "MSFT_sRGBFactors";
                var MSFT_sRGBFactors = (
                  /** @class */
                  function() {
                    function MSFT_sRGBFactors2(loader) {
                      this.name = NAME;
                      this._loader = loader;
                      this.enabled = this._loader.isExtensionUsed(NAME);
                    }
                    MSFT_sRGBFactors2.prototype.dispose = function() {
                      this._loader = null;
                    };
                    MSFT_sRGBFactors2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var _this = this;
                      return _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.LoadExtraAsync(context, material, this.name, function(extraContext, extra) {
                        if (extra) {
                          if (!(babylonMaterial instanceof babylonjs_Materials_PBR_pbrMaterial__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                            throw new Error("".concat(extraContext, ": Material type not supported"));
                          }
                          var promise = _this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                          var useExactSrgbConversions = babylonMaterial.getScene().getEngine().useExactSrgbConversions;
                          if (!babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoColor.toLinearSpaceToRef(babylonMaterial.albedoColor, useExactSrgbConversions);
                          }
                          if (!babylonMaterial.reflectivityTexture) {
                            babylonMaterial.reflectivityColor.toLinearSpaceToRef(babylonMaterial.reflectivityColor, useExactSrgbConversions);
                          }
                          return promise;
                        }
                        return null;
                      });
                    };
                    return MSFT_sRGBFactors2;
                  }()
                );
                _glTFLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoader.RegisterExtension(NAME, function(loader) {
                  return new MSFT_sRGBFactors(loader);
                });
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts": (
              /*!*************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/Extensions/index.ts ***!
                \*************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  EXT_lights_image_based: () => (
                    /* reexport safe */
                    _EXT_lights_image_based__WEBPACK_IMPORTED_MODULE_0__.EXT_lights_image_based
                  ),
                  /* harmony export */
                  EXT_mesh_gpu_instancing: () => (
                    /* reexport safe */
                    _EXT_mesh_gpu_instancing__WEBPACK_IMPORTED_MODULE_1__.EXT_mesh_gpu_instancing
                  ),
                  /* harmony export */
                  EXT_meshopt_compression: () => (
                    /* reexport safe */
                    _EXT_meshopt_compression__WEBPACK_IMPORTED_MODULE_2__.EXT_meshopt_compression
                  ),
                  /* harmony export */
                  EXT_texture_webp: () => (
                    /* reexport safe */
                    _EXT_texture_webp__WEBPACK_IMPORTED_MODULE_3__.EXT_texture_webp
                  ),
                  /* harmony export */
                  ExtrasAsMetadata: () => (
                    /* reexport safe */
                    _ExtrasAsMetadata__WEBPACK_IMPORTED_MODULE_28__.ExtrasAsMetadata
                  ),
                  /* harmony export */
                  KHR_animation_pointer: () => (
                    /* reexport safe */
                    _KHR_animation_pointer__WEBPACK_IMPORTED_MODULE_23__.KHR_animation_pointer
                  ),
                  /* harmony export */
                  KHR_draco_mesh_compression: () => (
                    /* reexport safe */
                    _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_4__.KHR_draco_mesh_compression
                  ),
                  /* harmony export */
                  KHR_lights: () => (
                    /* reexport safe */
                    _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_5__.KHR_lights
                  ),
                  /* harmony export */
                  KHR_materials_anisotropy: () => (
                    /* reexport safe */
                    _KHR_materials_anisotropy__WEBPACK_IMPORTED_MODULE_10__.KHR_materials_anisotropy
                  ),
                  /* harmony export */
                  KHR_materials_clearcoat: () => (
                    /* reexport safe */
                    _KHR_materials_clearcoat__WEBPACK_IMPORTED_MODULE_8__.KHR_materials_clearcoat
                  ),
                  /* harmony export */
                  KHR_materials_emissive_strength: () => (
                    /* reexport safe */
                    _KHR_materials_emissive_strength__WEBPACK_IMPORTED_MODULE_11__.KHR_materials_emissive_strength
                  ),
                  /* harmony export */
                  KHR_materials_ior: () => (
                    /* reexport safe */
                    _KHR_materials_ior__WEBPACK_IMPORTED_MODULE_14__.KHR_materials_ior
                  ),
                  /* harmony export */
                  KHR_materials_iridescence: () => (
                    /* reexport safe */
                    _KHR_materials_iridescence__WEBPACK_IMPORTED_MODULE_9__.KHR_materials_iridescence
                  ),
                  /* harmony export */
                  KHR_materials_pbrSpecularGlossiness: () => (
                    /* reexport safe */
                    _KHR_materials_pbrSpecularGlossiness__WEBPACK_IMPORTED_MODULE_6__.KHR_materials_pbrSpecularGlossiness
                  ),
                  /* harmony export */
                  KHR_materials_sheen: () => (
                    /* reexport safe */
                    _KHR_materials_sheen__WEBPACK_IMPORTED_MODULE_12__.KHR_materials_sheen
                  ),
                  /* harmony export */
                  KHR_materials_specular: () => (
                    /* reexport safe */
                    _KHR_materials_specular__WEBPACK_IMPORTED_MODULE_13__.KHR_materials_specular
                  ),
                  /* harmony export */
                  KHR_materials_translucency: () => (
                    /* reexport safe */
                    _KHR_materials_translucency__WEBPACK_IMPORTED_MODULE_17__.KHR_materials_translucency
                  ),
                  /* harmony export */
                  KHR_materials_transmission: () => (
                    /* reexport safe */
                    _KHR_materials_transmission__WEBPACK_IMPORTED_MODULE_16__.KHR_materials_transmission
                  ),
                  /* harmony export */
                  KHR_materials_unlit: () => (
                    /* reexport safe */
                    _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_7__.KHR_materials_unlit
                  ),
                  /* harmony export */
                  KHR_materials_variants: () => (
                    /* reexport safe */
                    _KHR_materials_variants__WEBPACK_IMPORTED_MODULE_15__.KHR_materials_variants
                  ),
                  /* harmony export */
                  KHR_materials_volume: () => (
                    /* reexport safe */
                    _KHR_materials_volume__WEBPACK_IMPORTED_MODULE_18__.KHR_materials_volume
                  ),
                  /* harmony export */
                  KHR_mesh_quantization: () => (
                    /* reexport safe */
                    _KHR_mesh_quantization__WEBPACK_IMPORTED_MODULE_19__.KHR_mesh_quantization
                  ),
                  /* harmony export */
                  KHR_texture_basisu: () => (
                    /* reexport safe */
                    _KHR_texture_basisu__WEBPACK_IMPORTED_MODULE_20__.KHR_texture_basisu
                  ),
                  /* harmony export */
                  KHR_texture_transform: () => (
                    /* reexport safe */
                    _KHR_texture_transform__WEBPACK_IMPORTED_MODULE_21__.KHR_texture_transform
                  ),
                  /* harmony export */
                  KHR_xmp_json_ld: () => (
                    /* reexport safe */
                    _KHR_xmp_json_ld__WEBPACK_IMPORTED_MODULE_22__.KHR_xmp_json_ld
                  ),
                  /* harmony export */
                  MSFT_audio_emitter: () => (
                    /* reexport safe */
                    _MSFT_audio_emitter__WEBPACK_IMPORTED_MODULE_24__.MSFT_audio_emitter
                  ),
                  /* harmony export */
                  MSFT_lod: () => (
                    /* reexport safe */
                    _MSFT_lod__WEBPACK_IMPORTED_MODULE_25__.MSFT_lod
                  ),
                  /* harmony export */
                  MSFT_minecraftMesh: () => (
                    /* reexport safe */
                    _MSFT_minecraftMesh__WEBPACK_IMPORTED_MODULE_26__.MSFT_minecraftMesh
                  ),
                  /* harmony export */
                  MSFT_sRGBFactors: () => (
                    /* reexport safe */
                    _MSFT_sRGBFactors__WEBPACK_IMPORTED_MODULE_27__.MSFT_sRGBFactors
                  )
                  /* harmony export */
                });
                var _EXT_lights_image_based__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./EXT_lights_image_based */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts"
                );
                var _EXT_mesh_gpu_instancing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./EXT_mesh_gpu_instancing */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts"
                );
                var _EXT_meshopt_compression__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./EXT_meshopt_compression */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts"
                );
                var _EXT_texture_webp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./EXT_texture_webp */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts"
                );
                var _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./KHR_draco_mesh_compression */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts"
                );
                var _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./KHR_lights_punctual */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts"
                );
                var _KHR_materials_pbrSpecularGlossiness__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__2(
                  /*! ./KHR_materials_pbrSpecularGlossiness */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts"
                );
                var _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__2(
                  /*! ./KHR_materials_unlit */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts"
                );
                var _KHR_materials_clearcoat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__2(
                  /*! ./KHR_materials_clearcoat */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts"
                );
                var _KHR_materials_iridescence__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__2(
                  /*! ./KHR_materials_iridescence */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts"
                );
                var _KHR_materials_anisotropy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__2(
                  /*! ./KHR_materials_anisotropy */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts"
                );
                var _KHR_materials_emissive_strength__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__2(
                  /*! ./KHR_materials_emissive_strength */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts"
                );
                var _KHR_materials_sheen__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__2(
                  /*! ./KHR_materials_sheen */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts"
                );
                var _KHR_materials_specular__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__2(
                  /*! ./KHR_materials_specular */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts"
                );
                var _KHR_materials_ior__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__2(
                  /*! ./KHR_materials_ior */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts"
                );
                var _KHR_materials_variants__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__2(
                  /*! ./KHR_materials_variants */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts"
                );
                var _KHR_materials_transmission__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__2(
                  /*! ./KHR_materials_transmission */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts"
                );
                var _KHR_materials_translucency__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__2(
                  /*! ./KHR_materials_translucency */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_translucency.ts"
                );
                var _KHR_materials_volume__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__2(
                  /*! ./KHR_materials_volume */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts"
                );
                var _KHR_mesh_quantization__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__2(
                  /*! ./KHR_mesh_quantization */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts"
                );
                var _KHR_texture_basisu__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__2(
                  /*! ./KHR_texture_basisu */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts"
                );
                var _KHR_texture_transform__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__2(
                  /*! ./KHR_texture_transform */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts"
                );
                var _KHR_xmp_json_ld__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__2(
                  /*! ./KHR_xmp_json_ld */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts"
                );
                var _KHR_animation_pointer__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__2(
                  /*! ./KHR_animation_pointer */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts"
                );
                var _MSFT_audio_emitter__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__2(
                  /*! ./MSFT_audio_emitter */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts"
                );
                var _MSFT_lod__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__2(
                  /*! ./MSFT_lod */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts"
                );
                var _MSFT_minecraftMesh__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__2(
                  /*! ./MSFT_minecraftMesh */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts"
                );
                var _MSFT_sRGBFactors__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__2(
                  /*! ./MSFT_sRGBFactors */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts"
                );
                var _ExtrasAsMetadata__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__2(
                  /*! ./ExtrasAsMetadata */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoader.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  ArrayItem: () => (
                    /* binding */
                    ArrayItem
                  ),
                  /* harmony export */
                  GLTFLoader: () => (
                    /* binding */
                    GLTFLoader
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Culling/boundingInfo */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ../glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderAnimation */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"
                );
                function mergeDeep() {
                  var objects = [];
                  for (var _i = 0; _i < arguments.length; _i++) {
                    objects[_i] = arguments[_i];
                  }
                  var isObject = function(obj) {
                    return obj && typeof obj === "object";
                  };
                  return objects.reduce(function(prev, obj) {
                    Object.keys(obj).forEach(function(key) {
                      var pVal = prev[key];
                      var oVal = obj[key];
                      if (Array.isArray(pVal) && Array.isArray(oVal)) {
                        prev[key] = pVal.concat.apply(pVal, oVal);
                      } else if (isObject(pVal) && isObject(oVal)) {
                        prev[key] = mergeDeep(pVal, oVal);
                      } else {
                        prev[key] = oVal;
                      }
                    });
                    return prev;
                  }, {});
                }
                var ArrayItem = (
                  /** @class */
                  function() {
                    function ArrayItem2() {
                    }
                    ArrayItem2.Get = function(context, array, index) {
                      if (!array || index == void 0 || !array[index]) {
                        throw new Error("".concat(context, ": Failed to find index (").concat(index, ")"));
                      }
                      return array[index];
                    };
                    ArrayItem2.TryGet = function(array, index) {
                      if (!array || index == void 0 || !array[index]) {
                        return null;
                      }
                      return array[index];
                    };
                    ArrayItem2.Assign = function(array) {
                      if (array) {
                        for (var index = 0; index < array.length; index++) {
                          array[index].index = index;
                        }
                      }
                    };
                    return ArrayItem2;
                  }()
                );
                var GLTFLoader = (
                  /** @class */
                  function() {
                    function GLTFLoader2(parent) {
                      this._completePromises = new Array();
                      this._assetContainer = null;
                      this._babylonLights = [];
                      this._disableInstancedMesh = 0;
                      this._allMaterialsDirtyRequired = false;
                      this._extensions = new Array();
                      this._disposed = false;
                      this._rootUrl = null;
                      this._fileName = null;
                      this._uniqueRootUrl = null;
                      this._bin = null;
                      this._rootBabylonMesh = null;
                      this._defaultBabylonMaterialData = {};
                      this._postSceneLoadActions = new Array();
                      this._parent = parent;
                    }
                    GLTFLoader2.RegisterExtension = function(name, factory) {
                      if (GLTFLoader2.UnregisterExtension(name)) {
                        babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Extension with the name '".concat(name, "' already exists"));
                      }
                      GLTFLoader2._RegisteredExtensions[name] = {
                        factory
                      };
                    };
                    GLTFLoader2.UnregisterExtension = function(name) {
                      if (!GLTFLoader2._RegisteredExtensions[name]) {
                        return false;
                      }
                      delete GLTFLoader2._RegisteredExtensions[name];
                      return true;
                    };
                    Object.defineProperty(GLTFLoader2.prototype, "gltf", {
                      /**
                       * The object that represents the glTF JSON.
                       */
                      get: function() {
                        if (!this._gltf) {
                          throw new Error("glTF JSON is not available");
                        }
                        return this._gltf;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "bin", {
                      /**
                       * The BIN chunk of a binary glTF.
                       */
                      get: function() {
                        return this._bin;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "parent", {
                      /**
                       * The parent file loader.
                       */
                      get: function() {
                        return this._parent;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "babylonScene", {
                      /**
                       * The Babylon scene when loading the asset.
                       */
                      get: function() {
                        if (!this._babylonScene) {
                          throw new Error("Scene is not available");
                        }
                        return this._babylonScene;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFLoader2.prototype, "rootBabylonMesh", {
                      /**
                       * The root Babylon mesh when loading the asset.
                       */
                      get: function() {
                        return this._rootBabylonMesh;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFLoader2.prototype.dispose = function() {
                      if (this._disposed) {
                        return;
                      }
                      this._disposed = true;
                      this._completePromises.length = 0;
                      this._extensions.forEach(function(extension) {
                        return extension.dispose && extension.dispose();
                      });
                      this._extensions.length = 0;
                      this._gltf = null;
                      this._bin = null;
                      this._babylonScene = null;
                      this._rootBabylonMesh = null;
                      this._defaultBabylonMaterialData = {};
                      this._postSceneLoadActions.length = 0;
                      this._parent.dispose();
                    };
                    GLTFLoader2.prototype.importMeshAsync = function(meshesNames, scene, container, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      if (fileName === void 0) {
                        fileName = "";
                      }
                      return Promise.resolve().then(function() {
                        _this._babylonScene = scene;
                        _this._assetContainer = container;
                        _this._loadData(data);
                        var nodes = null;
                        if (meshesNames) {
                          var nodeMap_1 = {};
                          if (_this._gltf.nodes) {
                            for (var _i = 0, _a = _this._gltf.nodes; _i < _a.length; _i++) {
                              var node = _a[_i];
                              if (node.name) {
                                nodeMap_1[node.name] = node.index;
                              }
                            }
                          }
                          var names = meshesNames instanceof Array ? meshesNames : [meshesNames];
                          nodes = names.map(function(name) {
                            var node2 = nodeMap_1[name];
                            if (node2 === void 0) {
                              throw new Error("Failed to find node '".concat(name, "'"));
                            }
                            return node2;
                          });
                        }
                        return _this._loadAsync(rootUrl, fileName, nodes, function() {
                          return {
                            meshes: _this._getMeshes(),
                            particleSystems: [],
                            skeletons: _this._getSkeletons(),
                            animationGroups: _this._getAnimationGroups(),
                            lights: _this._babylonLights,
                            transformNodes: _this._getTransformNodes(),
                            geometries: _this._getGeometries()
                          };
                        });
                      });
                    };
                    GLTFLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      if (fileName === void 0) {
                        fileName = "";
                      }
                      return Promise.resolve().then(function() {
                        _this._babylonScene = scene;
                        _this._loadData(data);
                        return _this._loadAsync(rootUrl, fileName, null, function() {
                          return void 0;
                        });
                      });
                    };
                    GLTFLoader2.prototype._loadAsync = function(rootUrl, fileName, nodes, resultFunc) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this._rootUrl = rootUrl;
                        _this._uniqueRootUrl = !rootUrl.startsWith("file:") && fileName ? rootUrl : "".concat(rootUrl).concat(Date.now(), "/");
                        _this._fileName = fileName;
                        _this._allMaterialsDirtyRequired = false;
                        _this._loadExtensions();
                        _this._checkExtensions();
                        var loadingToReadyCounterName = "".concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING], " => ").concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.READY]);
                        var loadingToCompleteCounterName = "".concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING], " => ").concat(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState[_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.COMPLETE]);
                        _this._parent._startPerformanceCounter(loadingToReadyCounterName);
                        _this._parent._startPerformanceCounter(loadingToCompleteCounterName);
                        _this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.LOADING);
                        _this._extensionsOnLoading();
                        var promises = new Array();
                        var oldBlockMaterialDirtyMechanism = _this._babylonScene.blockMaterialDirtyMechanism;
                        _this._babylonScene.blockMaterialDirtyMechanism = true;
                        if (!_this.parent.loadOnlyMaterials) {
                          if (nodes) {
                            promises.push(_this.loadSceneAsync("/nodes", { nodes, index: -1 }));
                          } else if (_this._gltf.scene != void 0 || _this._gltf.scenes && _this._gltf.scenes[0]) {
                            var scene = ArrayItem.Get("/scene", _this._gltf.scenes, _this._gltf.scene || 0);
                            promises.push(_this.loadSceneAsync("/scenes/".concat(scene.index), scene));
                          }
                        }
                        if (!_this.parent.skipMaterials && _this.parent.loadAllMaterials && _this._gltf.materials) {
                          for (var m = 0; m < _this._gltf.materials.length; ++m) {
                            var material = _this._gltf.materials[m];
                            var context_1 = "/materials/" + m;
                            var babylonDrawMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFillMode;
                            promises.push(_this._loadMaterialAsync(context_1, material, null, babylonDrawMode, function() {
                            }));
                          }
                        }
                        if (_this._allMaterialsDirtyRequired) {
                          _this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;
                        } else {
                          _this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);
                        }
                        if (_this._parent.compileMaterials) {
                          promises.push(_this._compileMaterialsAsync());
                        }
                        if (_this._parent.compileShadowGenerators) {
                          promises.push(_this._compileShadowGeneratorsAsync());
                        }
                        var resultPromise = Promise.all(promises).then(function() {
                          if (_this._rootBabylonMesh) {
                            _this._rootBabylonMesh.setEnabled(true);
                          }
                          _this._extensionsOnReady();
                          _this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.READY);
                          _this._startAnimations();
                          return resultFunc();
                        });
                        return resultPromise.then(function(result) {
                          _this._parent._endPerformanceCounter(loadingToReadyCounterName);
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Tools.SetImmediate(function() {
                            if (!_this._disposed) {
                              Promise.all(_this._completePromises).then(function() {
                                _this._parent._endPerformanceCounter(loadingToCompleteCounterName);
                                _this._parent._setState(_glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderState.COMPLETE);
                                _this._parent.onCompleteObservable.notifyObservers(void 0);
                                _this._parent.onCompleteObservable.clear();
                                _this.dispose();
                              }, function(error) {
                                _this._parent.onErrorObservable.notifyObservers(error);
                                _this._parent.onErrorObservable.clear();
                                _this.dispose();
                              });
                            }
                          });
                          return result;
                        });
                      }).catch(function(error) {
                        if (!_this._disposed) {
                          _this._parent.onErrorObservable.notifyObservers(error);
                          _this._parent.onErrorObservable.clear();
                          _this.dispose();
                        }
                        throw error;
                      });
                    };
                    GLTFLoader2.prototype._loadData = function(data) {
                      this._gltf = data.json;
                      this._setupData();
                      if (data.bin) {
                        var buffers = this._gltf.buffers;
                        if (buffers && buffers[0] && !buffers[0].uri) {
                          var binaryBuffer = buffers[0];
                          if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Binary buffer length (".concat(binaryBuffer.byteLength, ") from JSON does not match chunk length (").concat(data.bin.byteLength, ")"));
                          }
                          this._bin = data.bin;
                        } else {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Unexpected BIN chunk");
                        }
                      }
                    };
                    GLTFLoader2.prototype._setupData = function() {
                      ArrayItem.Assign(this._gltf.accessors);
                      ArrayItem.Assign(this._gltf.animations);
                      ArrayItem.Assign(this._gltf.buffers);
                      ArrayItem.Assign(this._gltf.bufferViews);
                      ArrayItem.Assign(this._gltf.cameras);
                      ArrayItem.Assign(this._gltf.images);
                      ArrayItem.Assign(this._gltf.materials);
                      ArrayItem.Assign(this._gltf.meshes);
                      ArrayItem.Assign(this._gltf.nodes);
                      ArrayItem.Assign(this._gltf.samplers);
                      ArrayItem.Assign(this._gltf.scenes);
                      ArrayItem.Assign(this._gltf.skins);
                      ArrayItem.Assign(this._gltf.textures);
                      if (this._gltf.nodes) {
                        var nodeParents = {};
                        for (var _i = 0, _a = this._gltf.nodes; _i < _a.length; _i++) {
                          var node = _a[_i];
                          if (node.children) {
                            for (var _b = 0, _c = node.children; _b < _c.length; _b++) {
                              var index = _c[_b];
                              nodeParents[index] = node.index;
                            }
                          }
                        }
                        var rootNode = this._createRootNode();
                        for (var _d = 0, _e = this._gltf.nodes; _d < _e.length; _d++) {
                          var node = _e[_d];
                          var parentIndex = nodeParents[node.index];
                          node.parent = parentIndex === void 0 ? rootNode : this._gltf.nodes[parentIndex];
                        }
                      }
                    };
                    GLTFLoader2.prototype._loadExtensions = function() {
                      for (var name_1 in GLTFLoader2._RegisteredExtensions) {
                        var extension = GLTFLoader2._RegisteredExtensions[name_1].factory(this);
                        if (extension.name !== name_1) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("The name of the glTF loader extension instance does not match the registered name: ".concat(extension.name, " !== ").concat(name_1));
                        }
                        this._extensions.push(extension);
                        this._parent.onExtensionLoadedObservable.notifyObservers(extension);
                      }
                      this._extensions.sort(function(a, b) {
                        return (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE);
                      });
                      this._parent.onExtensionLoadedObservable.clear();
                    };
                    GLTFLoader2.prototype._checkExtensions = function() {
                      if (this._gltf.extensionsRequired) {
                        var _loop_1 = function(name_22) {
                          var available = this_1._extensions.some(function(extension) {
                            return extension.name === name_22 && extension.enabled;
                          });
                          if (!available) {
                            throw new Error("Require extension ".concat(name_22, " is not available"));
                          }
                        };
                        var this_1 = this;
                        for (var _i = 0, _a = this._gltf.extensionsRequired; _i < _a.length; _i++) {
                          var name_2 = _a[_i];
                          _loop_1(name_2);
                        }
                      }
                    };
                    GLTFLoader2.prototype._createRootNode = function() {
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      this._rootBabylonMesh = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Mesh("__root__", this._babylonScene);
                      this._rootBabylonMesh._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      this._rootBabylonMesh.setEnabled(false);
                      var rootNode = {
                        _babylonTransformNode: this._rootBabylonMesh,
                        index: -1
                      };
                      switch (this._parent.coordinateSystemMode) {
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderCoordinateSystemMode.AUTO: {
                          if (!this._babylonScene.useRightHandedSystem) {
                            rootNode.rotation = [0, 1, 0, 0];
                            rootNode.scale = [1, 1, -1];
                            GLTFLoader2._LoadTransform(rootNode, this._rootBabylonMesh);
                          }
                          break;
                        }
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {
                          this._babylonScene.useRightHandedSystem = true;
                          break;
                        }
                        default: {
                          throw new Error("Invalid coordinate system mode (".concat(this._parent.coordinateSystemMode, ")"));
                        }
                      }
                      this._parent.onMeshLoadedObservable.notifyObservers(this._rootBabylonMesh);
                      return rootNode;
                    };
                    GLTFLoader2.prototype.loadSceneAsync = function(context, scene) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadSceneAsync(context, scene);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(scene.name || ""));
                      if (scene.nodes) {
                        for (var _i = 0, _a = scene.nodes; _i < _a.length; _i++) {
                          var index = _a[_i];
                          var node = ArrayItem.Get("".concat(context, "/nodes/").concat(index), this._gltf.nodes, index);
                          promises.push(this.loadNodeAsync("/nodes/".concat(node.index), node, function(babylonMesh) {
                            babylonMesh.parent = _this._rootBabylonMesh;
                          }));
                        }
                      }
                      for (var _b = 0, _c = this._postSceneLoadActions; _b < _c.length; _b++) {
                        var action = _c[_b];
                        action();
                      }
                      promises.push(this._loadAnimationsAsync());
                      this.logClose();
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype._forEachPrimitive = function(node, callback) {
                      if (node._primitiveBabylonMeshes) {
                        for (var _i = 0, _a = node._primitiveBabylonMeshes; _i < _a.length; _i++) {
                          var babylonMesh = _a[_i];
                          callback(babylonMesh);
                        }
                      }
                    };
                    GLTFLoader2.prototype._getGeometries = function() {
                      var geometries = [];
                      var nodes = this._gltf.nodes;
                      if (nodes) {
                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                          var node = nodes_1[_i];
                          this._forEachPrimitive(node, function(babylonMesh) {
                            var geometry = babylonMesh.geometry;
                            if (geometry && geometries.indexOf(geometry) === -1) {
                              geometries.push(geometry);
                            }
                          });
                        }
                      }
                      return geometries;
                    };
                    GLTFLoader2.prototype._getMeshes = function() {
                      var meshes = [];
                      if (this._rootBabylonMesh) {
                        meshes.push(this._rootBabylonMesh);
                      }
                      var nodes = this._gltf.nodes;
                      if (nodes) {
                        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                          var node = nodes_2[_i];
                          this._forEachPrimitive(node, function(babylonMesh) {
                            meshes.push(babylonMesh);
                          });
                        }
                      }
                      return meshes;
                    };
                    GLTFLoader2.prototype._getTransformNodes = function() {
                      var transformNodes = [];
                      var nodes = this._gltf.nodes;
                      if (nodes) {
                        for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
                          var node = nodes_3[_i];
                          if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === "TransformNode") {
                            transformNodes.push(node._babylonTransformNode);
                          }
                          if (node._babylonTransformNodeForSkin) {
                            transformNodes.push(node._babylonTransformNodeForSkin);
                          }
                        }
                      }
                      return transformNodes;
                    };
                    GLTFLoader2.prototype._getSkeletons = function() {
                      var skeletons = [];
                      var skins = this._gltf.skins;
                      if (skins) {
                        for (var _i = 0, skins_1 = skins; _i < skins_1.length; _i++) {
                          var skin = skins_1[_i];
                          if (skin._data) {
                            skeletons.push(skin._data.babylonSkeleton);
                          }
                        }
                      }
                      return skeletons;
                    };
                    GLTFLoader2.prototype._getAnimationGroups = function() {
                      var animationGroups = [];
                      var animations = this._gltf.animations;
                      if (animations) {
                        for (var _i = 0, animations_1 = animations; _i < animations_1.length; _i++) {
                          var animation = animations_1[_i];
                          if (animation._babylonAnimationGroup) {
                            animationGroups.push(animation._babylonAnimationGroup);
                          }
                        }
                      }
                      return animationGroups;
                    };
                    GLTFLoader2.prototype._startAnimations = function() {
                      switch (this._parent.animationStartMode) {
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.NONE: {
                          break;
                        }
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.FIRST: {
                          var babylonAnimationGroups = this._getAnimationGroups();
                          if (babylonAnimationGroups.length !== 0) {
                            babylonAnimationGroups[0].start(true);
                          }
                          break;
                        }
                        case _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFLoaderAnimationStartMode.ALL: {
                          var babylonAnimationGroups = this._getAnimationGroups();
                          for (var _i = 0, babylonAnimationGroups_1 = babylonAnimationGroups; _i < babylonAnimationGroups_1.length; _i++) {
                            var babylonAnimationGroup = babylonAnimationGroups_1[_i];
                            babylonAnimationGroup.start(true);
                          }
                          break;
                        }
                        default: {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Error("Invalid animation start mode (".concat(this._parent.animationStartMode, ")"));
                          return;
                        }
                      }
                    };
                    GLTFLoader2.prototype.loadNodeAsync = function(context, node, assign) {
                      var _this = this;
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (node._babylonTransformNode) {
                        throw new Error("".concat(context, ": Invalid recursive node hierarchy"));
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(node.name || ""));
                      var loadNode = function(babylonTransformNode) {
                        GLTFLoader2.AddPointerMetadata(babylonTransformNode, context);
                        GLTFLoader2._LoadTransform(node, babylonTransformNode);
                        if (node.camera != void 0) {
                          var camera = ArrayItem.Get("".concat(context, "/camera"), _this._gltf.cameras, node.camera);
                          promises.push(_this.loadCameraAsync("/cameras/".concat(camera.index), camera, function(babylonCamera) {
                            babylonCamera.parent = babylonTransformNode;
                          }));
                        }
                        if (node.children) {
                          for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                            var index = _a[_i];
                            var childNode = ArrayItem.Get("".concat(context, "/children/").concat(index), _this._gltf.nodes, index);
                            promises.push(_this.loadNodeAsync("/nodes/".concat(childNode.index), childNode, function(childBabylonMesh) {
                              childBabylonMesh.parent = babylonTransformNode;
                            }));
                          }
                        }
                        assign(babylonTransformNode);
                      };
                      if (node.mesh == void 0 || node.skin != void 0) {
                        var nodeName = node.name || "node".concat(node.index);
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        var transformNode = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TransformNode(nodeName, this._babylonScene);
                        transformNode._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        if (node.mesh == void 0) {
                          node._babylonTransformNode = transformNode;
                        } else {
                          node._babylonTransformNodeForSkin = transformNode;
                        }
                        loadNode(transformNode);
                      }
                      if (node.mesh != void 0) {
                        if (node.skin == void 0) {
                          var mesh = ArrayItem.Get("".concat(context, "/mesh"), this._gltf.meshes, node.mesh);
                          promises.push(this._loadMeshAsync("/meshes/".concat(mesh.index), node, mesh, loadNode));
                        } else {
                          var mesh = ArrayItem.Get("".concat(context, "/mesh"), this._gltf.meshes, node.mesh);
                          promises.push(this._loadMeshAsync("/meshes/".concat(mesh.index), node, mesh, function(babylonTransformNode) {
                            var babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;
                            babylonTransformNode.metadata = mergeDeep(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});
                            var skin = ArrayItem.Get("".concat(context, "/skin"), _this._gltf.skins, node.skin);
                            promises.push(_this._loadSkinAsync("/skins/".concat(skin.index), node, skin, function(babylonSkeleton) {
                              _this._forEachPrimitive(node, function(babylonMesh) {
                                babylonMesh.skeleton = babylonSkeleton;
                              });
                              _this._postSceneLoadActions.push(function() {
                                if (skin.skeleton != void 0) {
                                  var parentNode = ArrayItem.Get("/skins/".concat(skin.index, "/skeleton"), _this._gltf.nodes, skin.skeleton).parent;
                                  if (node.index === parentNode.index) {
                                    babylonTransformNode.parent = babylonTransformNodeForSkin.parent;
                                  } else {
                                    babylonTransformNode.parent = parentNode._babylonTransformNode;
                                  }
                                } else {
                                  babylonTransformNode.parent = _this._rootBabylonMesh;
                                }
                                _this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });
                              });
                            }));
                          }));
                        }
                      }
                      this.logClose();
                      return Promise.all(promises).then(function() {
                        _this._forEachPrimitive(node, function(babylonMesh) {
                          if (babylonMesh.geometry && babylonMesh.geometry.useBoundingInfoFromGeometry) {
                            babylonMesh._updateBoundingInfo();
                          } else {
                            babylonMesh.refreshBoundingInfo(true);
                          }
                        });
                        return node._babylonTransformNode;
                      });
                    };
                    GLTFLoader2.prototype._loadMeshAsync = function(context, node, mesh, assign) {
                      var primitives = mesh.primitives;
                      if (!primitives || !primitives.length) {
                        throw new Error("".concat(context, ": Primitives are missing"));
                      }
                      if (primitives[0].index == void 0) {
                        ArrayItem.Assign(primitives);
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(mesh.name || ""));
                      var name = node.name || "node".concat(node.index);
                      if (primitives.length === 1) {
                        var primitive = mesh.primitives[0];
                        promises.push(this._loadMeshPrimitiveAsync("".concat(context, "/primitives/").concat(primitive.index), name, node, mesh, primitive, function(babylonMesh) {
                          node._babylonTransformNode = babylonMesh;
                          node._primitiveBabylonMeshes = [babylonMesh];
                        }));
                      } else {
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        node._babylonTransformNode = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TransformNode(name, this._babylonScene);
                        node._babylonTransformNode._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        node._primitiveBabylonMeshes = [];
                        for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
                          var primitive = primitives_1[_i];
                          promises.push(this._loadMeshPrimitiveAsync("".concat(context, "/primitives/").concat(primitive.index), "".concat(name, "_primitive").concat(primitive.index), node, mesh, primitive, function(babylonMesh) {
                            babylonMesh.parent = node._babylonTransformNode;
                            node._primitiveBabylonMeshes.push(babylonMesh);
                          }));
                        }
                      }
                      assign(node._babylonTransformNode);
                      this.logClose();
                      return Promise.all(promises).then(function() {
                        return node._babylonTransformNode;
                      });
                    };
                    GLTFLoader2.prototype._loadMeshPrimitiveAsync = function(context, name, node, mesh, primitive, assign) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      this.logOpen("".concat(context));
                      var shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == void 0 && !mesh.primitives[0].targets;
                      var babylonAbstractMesh;
                      var promise;
                      if (shouldInstance && primitive._instanceData) {
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);
                        babylonAbstractMesh._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        promise = primitive._instanceData.promise;
                      } else {
                        var promises = new Array();
                        this._babylonScene._blockEntityCollection = !!this._assetContainer;
                        var babylonMesh_1 = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Mesh(name, this._babylonScene);
                        babylonMesh_1._parentContainer = this._assetContainer;
                        this._babylonScene._blockEntityCollection = false;
                        babylonMesh_1.overrideMaterialSideOrientation = this._babylonScene.useRightHandedSystem ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.CounterClockWiseSideOrientation : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.ClockWiseSideOrientation;
                        this._createMorphTargets(context, node, mesh, primitive, babylonMesh_1);
                        promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh_1).then(function(babylonGeometry) {
                          return _this._loadMorphTargetsAsync(context, primitive, babylonMesh_1, babylonGeometry).then(function() {
                            if (_this._disposed) {
                              return;
                            }
                            _this._babylonScene._blockEntityCollection = !!_this._assetContainer;
                            babylonGeometry.applyToMesh(babylonMesh_1);
                            babylonGeometry._parentContainer = _this._assetContainer;
                            _this._babylonScene._blockEntityCollection = false;
                          });
                        }));
                        var babylonDrawMode = GLTFLoader2._GetDrawMode(context, primitive.mode);
                        if (primitive.material == void 0) {
                          var babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];
                          if (!babylonMaterial) {
                            babylonMaterial = this._createDefaultMaterial("__GLTFLoader._default", babylonDrawMode);
                            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
                            this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;
                          }
                          babylonMesh_1.material = babylonMaterial;
                        } else if (!this.parent.skipMaterials) {
                          var material = ArrayItem.Get("".concat(context, "/material"), this._gltf.materials, primitive.material);
                          promises.push(this._loadMaterialAsync("/materials/".concat(material.index), material, babylonMesh_1, babylonDrawMode, function(babylonMaterial2) {
                            babylonMesh_1.material = babylonMaterial2;
                          }));
                        }
                        promise = Promise.all(promises);
                        if (shouldInstance) {
                          primitive._instanceData = {
                            babylonSourceMesh: babylonMesh_1,
                            promise
                          };
                        }
                        babylonAbstractMesh = babylonMesh_1;
                      }
                      GLTFLoader2.AddPointerMetadata(babylonAbstractMesh, context);
                      this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);
                      assign(babylonAbstractMesh);
                      this.logClose();
                      return promise.then(function() {
                        return babylonAbstractMesh;
                      });
                    };
                    GLTFLoader2.prototype._loadVertexDataAsync = function(context, primitive, babylonMesh) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var attributes = primitive.attributes;
                      if (!attributes) {
                        throw new Error("".concat(context, ": Attributes are missing"));
                      }
                      var promises = new Array();
                      var babylonGeometry = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Geometry(babylonMesh.name, this._babylonScene);
                      if (primitive.indices == void 0) {
                        babylonMesh.isUnIndexed = true;
                      } else {
                        var accessor = ArrayItem.Get("".concat(context, "/indices"), this._gltf.accessors, primitive.indices);
                        promises.push(this._loadIndicesAccessorAsync("/accessors/".concat(accessor.index), accessor).then(function(data) {
                          babylonGeometry.setIndices(data);
                        }));
                      }
                      var loadAttribute = function(name, kind, callback) {
                        if (attributes[name] == void 0) {
                          return;
                        }
                        babylonMesh._delayInfo = babylonMesh._delayInfo || [];
                        if (babylonMesh._delayInfo.indexOf(kind) === -1) {
                          babylonMesh._delayInfo.push(kind);
                        }
                        var accessor2 = ArrayItem.Get("".concat(context, "/attributes/").concat(name), _this._gltf.accessors, attributes[name]);
                        promises.push(_this._loadVertexAccessorAsync("/accessors/".concat(accessor2.index), accessor2, kind).then(function(babylonVertexBuffer) {
                          var _a, _b;
                          if (babylonVertexBuffer.getKind() === babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind && !_this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {
                            if (accessor2.min && accessor2.max) {
                              var min = (_a = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[0]).copyFromFloats.apply(_a, accessor2.min);
                              var max = (_b = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.TmpVectors.Vector3[1]).copyFromFloats.apply(_b, accessor2.max);
                              if (accessor2.normalized && accessor2.componentType !== 5126) {
                                var divider = 1;
                                switch (accessor2.componentType) {
                                  case 5120:
                                    divider = 127;
                                    break;
                                  case 5121:
                                    divider = 255;
                                    break;
                                  case 5122:
                                    divider = 32767;
                                    break;
                                  case 5123:
                                    divider = 65535;
                                    break;
                                }
                                var oneOverDivider = 1 / divider;
                                min.scaleInPlace(oneOverDivider);
                                max.scaleInPlace(oneOverDivider);
                              }
                              babylonGeometry._boundingInfo = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.BoundingInfo(min, max);
                              babylonGeometry.useBoundingInfoFromGeometry = true;
                            }
                          }
                          babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor2.count);
                        }));
                        if (kind == babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesExtraKind) {
                          babylonMesh.numBoneInfluencers = 8;
                        }
                        if (callback) {
                          callback(accessor2);
                        }
                      };
                      loadAttribute("POSITION", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind);
                      loadAttribute("NORMAL", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind);
                      loadAttribute("TANGENT", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind);
                      loadAttribute("TEXCOORD_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UVKind);
                      loadAttribute("TEXCOORD_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV2Kind);
                      loadAttribute("TEXCOORD_2", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV3Kind);
                      loadAttribute("TEXCOORD_3", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV4Kind);
                      loadAttribute("TEXCOORD_4", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV5Kind);
                      loadAttribute("TEXCOORD_5", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.UV6Kind);
                      loadAttribute("JOINTS_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesKind);
                      loadAttribute("WEIGHTS_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsKind);
                      loadAttribute("JOINTS_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesIndicesExtraKind);
                      loadAttribute("WEIGHTS_1", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.MatricesWeightsExtraKind);
                      loadAttribute("COLOR_0", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ColorKind, function(accessor2) {
                        if (accessor2.type === "VEC4") {
                          babylonMesh.hasVertexAlpha = true;
                        }
                      });
                      return Promise.all(promises).then(function() {
                        return babylonGeometry;
                      });
                    };
                    GLTFLoader2.prototype._createMorphTargets = function(context, node, mesh, primitive, babylonMesh) {
                      if (!primitive.targets) {
                        return;
                      }
                      if (node._numMorphTargets == void 0) {
                        node._numMorphTargets = primitive.targets.length;
                      } else if (primitive.targets.length !== node._numMorphTargets) {
                        throw new Error("".concat(context, ": Primitives do not have the same number of targets"));
                      }
                      var targetNames = mesh.extras ? mesh.extras.targetNames : null;
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      babylonMesh.morphTargetManager = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.MorphTargetManager(this._babylonScene);
                      babylonMesh.morphTargetManager._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      babylonMesh.morphTargetManager.areUpdatesFrozen = true;
                      for (var index = 0; index < primitive.targets.length; index++) {
                        var weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;
                        var name_3 = targetNames ? targetNames[index] : "morphTarget".concat(index);
                        babylonMesh.morphTargetManager.addTarget(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.MorphTarget(name_3, weight, babylonMesh.getScene()));
                      }
                    };
                    GLTFLoader2.prototype._loadMorphTargetsAsync = function(context, primitive, babylonMesh, babylonGeometry) {
                      if (!primitive.targets) {
                        return Promise.resolve();
                      }
                      var promises = new Array();
                      var morphTargetManager = babylonMesh.morphTargetManager;
                      for (var index = 0; index < morphTargetManager.numTargets; index++) {
                        var babylonMorphTarget = morphTargetManager.getTarget(index);
                        promises.push(this._loadMorphTargetVertexDataAsync("".concat(context, "/targets/").concat(index), babylonGeometry, primitive.targets[index], babylonMorphTarget));
                      }
                      return Promise.all(promises).then(function() {
                        morphTargetManager.areUpdatesFrozen = false;
                      });
                    };
                    GLTFLoader2.prototype._loadMorphTargetVertexDataAsync = function(context, babylonGeometry, attributes, babylonMorphTarget) {
                      var _this = this;
                      var promises = new Array();
                      var loadAttribute = function(attribute, kind, setData) {
                        if (attributes[attribute] == void 0) {
                          return;
                        }
                        var babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);
                        if (!babylonVertexBuffer) {
                          return;
                        }
                        var accessor = ArrayItem.Get("".concat(context, "/").concat(attribute), _this._gltf.accessors, attributes[attribute]);
                        promises.push(_this._loadFloatAccessorAsync("/accessors/".concat(accessor.index), accessor).then(function(data) {
                          setData(babylonVertexBuffer, data);
                        }));
                      };
                      loadAttribute("POSITION", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.PositionKind, function(babylonVertexBuffer, data) {
                        var positions = new Float32Array(data.length);
                        babylonVertexBuffer.forEach(data.length, function(value, index) {
                          positions[index] = data[index] + value;
                        });
                        babylonMorphTarget.setPositions(positions);
                      });
                      loadAttribute("NORMAL", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.NormalKind, function(babylonVertexBuffer, data) {
                        var normals = new Float32Array(data.length);
                        babylonVertexBuffer.forEach(normals.length, function(value, index) {
                          normals[index] = data[index] + value;
                        });
                        babylonMorphTarget.setNormals(normals);
                      });
                      loadAttribute("TANGENT", babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.TangentKind, function(babylonVertexBuffer, data) {
                        var tangents = new Float32Array(data.length / 3 * 4);
                        var dataIndex = 0;
                        babylonVertexBuffer.forEach(data.length / 3 * 4, function(value, index) {
                          if ((index + 1) % 4 !== 0) {
                            tangents[dataIndex] = data[dataIndex] + value;
                            dataIndex++;
                          }
                        });
                        babylonMorphTarget.setTangents(tangents);
                      });
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2._LoadTransform = function(node, babylonNode) {
                      if (node.skin != void 0) {
                        return;
                      }
                      var position = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero();
                      var rotation = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity();
                      var scaling = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.One();
                      if (node.matrix) {
                        var matrix = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArray(node.matrix);
                        matrix.decompose(scaling, rotation, position);
                      } else {
                        if (node.translation) {
                          position = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.translation);
                        }
                        if (node.rotation) {
                          rotation = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(node.rotation);
                        }
                        if (node.scale) {
                          scaling = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.scale);
                        }
                      }
                      babylonNode.position = position;
                      babylonNode.rotationQuaternion = rotation;
                      babylonNode.scaling = scaling;
                    };
                    GLTFLoader2.prototype._loadSkinAsync = function(context, node, skin, assign) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (skin._data) {
                        assign(skin._data.babylonSkeleton);
                        return skin._data.promise;
                      }
                      var skeletonId = "skeleton".concat(skin.index);
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonSkeleton = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);
                      babylonSkeleton._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      this._loadBones(context, skin, babylonSkeleton);
                      var promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then(function(inverseBindMatricesData) {
                        _this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);
                      });
                      skin._data = {
                        babylonSkeleton,
                        promise
                      };
                      assign(babylonSkeleton);
                      return promise;
                    };
                    GLTFLoader2.prototype._loadBones = function(context, skin, babylonSkeleton) {
                      if (skin.skeleton == void 0 || this._parent.alwaysComputeSkeletonRootNode) {
                        var rootNode = this._findSkeletonRootNode("".concat(context, "/joints"), skin.joints);
                        if (rootNode) {
                          if (skin.skeleton === void 0) {
                            skin.skeleton = rootNode.index;
                          } else {
                            var isParent = function(a, b) {
                              for (; b.parent; b = b.parent) {
                                if (b.parent === a) {
                                  return true;
                                }
                              }
                              return false;
                            };
                            var skeletonNode = ArrayItem.Get("".concat(context, "/skeleton"), this._gltf.nodes, skin.skeleton);
                            if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {
                              babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root"));
                              skin.skeleton = rootNode.index;
                            }
                          }
                        } else {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Failed to find common root"));
                        }
                      }
                      var babylonBones = {};
                      for (var _i = 0, _a = skin.joints; _i < _a.length; _i++) {
                        var index = _a[_i];
                        var node = ArrayItem.Get("".concat(context, "/joints/").concat(index), this._gltf.nodes, index);
                        this._loadBone(node, skin, babylonSkeleton, babylonBones);
                      }
                    };
                    GLTFLoader2.prototype._findSkeletonRootNode = function(context, joints) {
                      if (joints.length === 0) {
                        return null;
                      }
                      var paths = {};
                      for (var _i = 0, joints_1 = joints; _i < joints_1.length; _i++) {
                        var index = joints_1[_i];
                        var path = [];
                        var node = ArrayItem.Get("".concat(context, "/").concat(index), this._gltf.nodes, index);
                        while (node.index !== -1) {
                          path.unshift(node);
                          node = node.parent;
                        }
                        paths[index] = path;
                      }
                      var rootNode = null;
                      for (var i = 0; ; ++i) {
                        var path = paths[joints[0]];
                        if (i >= path.length) {
                          return rootNode;
                        }
                        var node = path[i];
                        for (var j = 1; j < joints.length; ++j) {
                          path = paths[joints[j]];
                          if (i >= path.length || node !== path[i]) {
                            return rootNode;
                          }
                        }
                        rootNode = node;
                      }
                    };
                    GLTFLoader2.prototype._loadBone = function(node, skin, babylonSkeleton, babylonBones) {
                      var babylonBone = babylonBones[node.index];
                      if (babylonBone) {
                        return babylonBone;
                      }
                      var parentBabylonBone = null;
                      if (node.index !== skin.skeleton) {
                        if (node.parent && node.parent.index !== -1) {
                          parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);
                        } else if (skin.skeleton !== void 0) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("/skins/".concat(skin.index, "/skeleton: Skeleton node is not a common root"));
                        }
                      }
                      var boneIndex = skin.joints.indexOf(node.index);
                      babylonBone = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Bone(node.name || "joint".concat(node.index), babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);
                      babylonBones[node.index] = babylonBone;
                      this._postSceneLoadActions.push(function() {
                        babylonBone.linkTransformNode(node._babylonTransformNode);
                      });
                      return babylonBone;
                    };
                    GLTFLoader2.prototype._loadSkinInverseBindMatricesDataAsync = function(context, skin) {
                      if (skin.inverseBindMatrices == void 0) {
                        return Promise.resolve(null);
                      }
                      var accessor = ArrayItem.Get("".concat(context, "/inverseBindMatrices"), this._gltf.accessors, skin.inverseBindMatrices);
                      return this._loadFloatAccessorAsync("/accessors/".concat(accessor.index), accessor);
                    };
                    GLTFLoader2.prototype._updateBoneMatrices = function(babylonSkeleton, inverseBindMatricesData) {
                      for (var _i = 0, _a = babylonSkeleton.bones; _i < _a.length; _i++) {
                        var babylonBone = _a[_i];
                        var baseMatrix = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.Identity();
                        var boneIndex = babylonBone._index;
                        if (inverseBindMatricesData && boneIndex !== -1) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);
                          baseMatrix.invertToRef(baseMatrix);
                        }
                        var babylonParentBone = babylonBone.getParent();
                        if (babylonParentBone) {
                          baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);
                        }
                        babylonBone.updateMatrix(baseMatrix, false, false);
                        babylonBone._updateAbsoluteBindMatrices(void 0, false);
                      }
                    };
                    GLTFLoader2.prototype._getNodeMatrix = function(node) {
                      return node.matrix ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.FromArray(node.matrix) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Matrix.Compose(node.scale ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.scale) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.One(), node.rotation ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(node.rotation) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity(), node.translation ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(node.translation) : babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero());
                    };
                    GLTFLoader2.prototype.loadCameraAsync = function(context, camera, assign) {
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var promises = new Array();
                      this.logOpen("".concat(context, " ").concat(camera.name || ""));
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonCamera = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.FreeCamera(camera.name || "camera".concat(camera.index), babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero(), this._babylonScene, false);
                      babylonCamera._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      babylonCamera.ignoreParentScaling = true;
                      camera._babylonCamera = babylonCamera;
                      babylonCamera.rotation = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, Math.PI, 0);
                      switch (camera.type) {
                        case "perspective": {
                          var perspective = camera.perspective;
                          if (!perspective) {
                            throw new Error("".concat(context, ": Camera perspective properties are missing"));
                          }
                          babylonCamera.fov = perspective.yfov;
                          babylonCamera.minZ = perspective.znear;
                          babylonCamera.maxZ = perspective.zfar || 0;
                          break;
                        }
                        case "orthographic": {
                          if (!camera.orthographic) {
                            throw new Error("".concat(context, ": Camera orthographic properties are missing"));
                          }
                          babylonCamera.mode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Camera.ORTHOGRAPHIC_CAMERA;
                          babylonCamera.orthoLeft = -camera.orthographic.xmag;
                          babylonCamera.orthoRight = camera.orthographic.xmag;
                          babylonCamera.orthoBottom = -camera.orthographic.ymag;
                          babylonCamera.orthoTop = camera.orthographic.ymag;
                          babylonCamera.minZ = camera.orthographic.znear;
                          babylonCamera.maxZ = camera.orthographic.zfar;
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, ": Invalid camera type (").concat(camera.type, ")"));
                        }
                      }
                      GLTFLoader2.AddPointerMetadata(babylonCamera, context);
                      this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);
                      assign(babylonCamera);
                      this.logClose();
                      return Promise.all(promises).then(function() {
                        return babylonCamera;
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationsAsync = function() {
                      var animations = this._gltf.animations;
                      if (!animations) {
                        return Promise.resolve();
                      }
                      var promises = new Array();
                      for (var index = 0; index < animations.length; index++) {
                        var animation = animations[index];
                        promises.push(this.loadAnimationAsync("/animations/".concat(animation.index), animation).then(function(animationGroup) {
                          if (animationGroup.targetedAnimations.length === 0) {
                            animationGroup.dispose();
                          }
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype.loadAnimationAsync = function(context, animation) {
                      var promise = this._extensionsLoadAnimationAsync(context, animation);
                      if (promise) {
                        return promise;
                      }
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonAnimationGroup = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.AnimationGroup(animation.name || "animation".concat(animation.index), this._babylonScene);
                      babylonAnimationGroup._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      animation._babylonAnimationGroup = babylonAnimationGroup;
                      var promises = new Array();
                      ArrayItem.Assign(animation.channels);
                      ArrayItem.Assign(animation.samplers);
                      for (var _i = 0, _a = animation.channels; _i < _a.length; _i++) {
                        var channel = _a[_i];
                        promises.push(this._loadAnimationChannelAsync("".concat(context, "/channels/").concat(channel.index), context, animation, channel, function(babylonTarget, babylonAnimation) {
                          babylonTarget.animations = babylonTarget.animations || [];
                          babylonTarget.animations.push(babylonAnimation);
                          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);
                        }));
                      }
                      return Promise.all(promises).then(function() {
                        babylonAnimationGroup.normalize(0);
                        return babylonAnimationGroup;
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationChannelAsync = function(context, animationContext, animation, channel, onLoad) {
                      var promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
                      if (promise) {
                        return promise;
                      }
                      if (channel.target.node == void 0) {
                        return Promise.resolve();
                      }
                      var targetNode = ArrayItem.Get("".concat(context, "/target/node"), this._gltf.nodes, channel.target.node);
                      if (channel.target.path === "weights" && !targetNode._numMorphTargets || channel.target.path !== "weights" && !targetNode._babylonTransformNode) {
                        return Promise.resolve();
                      }
                      var properties;
                      switch (channel.target.path) {
                        case "translation": {
                          properties = _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_2__.nodeAnimationData.translation;
                          break;
                        }
                        case "rotation": {
                          properties = _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_2__.nodeAnimationData.rotation;
                          break;
                        }
                        case "scale": {
                          properties = _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_2__.nodeAnimationData.scale;
                          break;
                        }
                        case "weights": {
                          properties = _glTFLoaderAnimation__WEBPACK_IMPORTED_MODULE_2__.nodeAnimationData.weights;
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, "/target/path: Invalid value (").concat(channel.target.path, ")"));
                        }
                      }
                      var targetInfo = {
                        target: targetNode,
                        properties
                      };
                      return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);
                    };
                    GLTFLoader2.prototype._loadAnimationChannelFromTargetInfoAsync = function(context, animationContext, animation, channel, targetInfo, onLoad) {
                      var fps = this.parent.targetFps;
                      var invfps = 1 / fps;
                      var sampler = ArrayItem.Get("".concat(context, "/sampler"), animation.samplers, channel.sampler);
                      return this._loadAnimationSamplerAsync("".concat(animationContext, "/samplers/").concat(channel.sampler), sampler).then(function(data) {
                        var numAnimations = 0;
                        for (var _i = 0, _a = targetInfo.properties; _i < _a.length; _i++) {
                          var property = _a[_i];
                          var stride = property.getStride(targetInfo.target);
                          var input = data.input;
                          var output = data.output;
                          var keys = new Array(input.length);
                          var outputOffset = 0;
                          switch (data.interpolation) {
                            case "STEP": {
                              for (var index = 0; index < input.length; index++) {
                                var value = property.getValue(targetInfo.target, output, outputOffset, 1);
                                outputOffset += stride;
                                keys[index] = {
                                  frame: input[index] * fps,
                                  value,
                                  interpolation: babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.AnimationKeyInterpolation.STEP
                                };
                              }
                              break;
                            }
                            case "CUBICSPLINE": {
                              for (var index = 0; index < input.length; index++) {
                                var inTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);
                                outputOffset += stride;
                                var value = property.getValue(targetInfo.target, output, outputOffset, 1);
                                outputOffset += stride;
                                var outTangent = property.getValue(targetInfo.target, output, outputOffset, invfps);
                                outputOffset += stride;
                                keys[index] = {
                                  frame: input[index] * fps,
                                  inTangent,
                                  value,
                                  outTangent
                                };
                              }
                              break;
                            }
                            case "LINEAR": {
                              for (var index = 0; index < input.length; index++) {
                                var value = property.getValue(targetInfo.target, output, outputOffset, 1);
                                outputOffset += stride;
                                keys[index] = {
                                  frame: input[index] * fps,
                                  value
                                };
                              }
                              break;
                            }
                          }
                          if (outputOffset > 0) {
                            var name_4 = "".concat(animation.name || "animation".concat(animation.index), "_channel").concat(channel.index, "_").concat(numAnimations);
                            property.buildAnimations(targetInfo.target, name_4, fps, keys, function(babylonAnimatable, babylonAnimation) {
                              ++numAnimations;
                              onLoad(babylonAnimatable, babylonAnimation);
                            });
                          }
                        }
                      });
                    };
                    GLTFLoader2.prototype._loadAnimationSamplerAsync = function(context, sampler) {
                      if (sampler._data) {
                        return sampler._data;
                      }
                      var interpolation = sampler.interpolation || "LINEAR";
                      switch (interpolation) {
                        case "STEP":
                        case "LINEAR":
                        case "CUBICSPLINE": {
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, "/interpolation: Invalid value (").concat(sampler.interpolation, ")"));
                        }
                      }
                      var inputAccessor = ArrayItem.Get("".concat(context, "/input"), this._gltf.accessors, sampler.input);
                      var outputAccessor = ArrayItem.Get("".concat(context, "/output"), this._gltf.accessors, sampler.output);
                      sampler._data = Promise.all([
                        this._loadFloatAccessorAsync("/accessors/".concat(inputAccessor.index), inputAccessor),
                        this._loadFloatAccessorAsync("/accessors/".concat(outputAccessor.index), outputAccessor)
                      ]).then(function(_a) {
                        var inputData = _a[0], outputData = _a[1];
                        return {
                          input: inputData,
                          interpolation,
                          output: outputData
                        };
                      });
                      return sampler._data;
                    };
                    GLTFLoader2.prototype.loadBufferAsync = function(context, buffer, byteOffset, byteLength) {
                      var extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (!buffer._data) {
                        if (buffer.uri) {
                          buffer._data = this.loadUriAsync("".concat(context, "/uri"), buffer, buffer.uri);
                        } else {
                          if (!this._bin) {
                            throw new Error("".concat(context, ": Uri is missing or the binary glTF is missing its binary chunk"));
                          }
                          buffer._data = this._bin.readAsync(0, buffer.byteLength);
                        }
                      }
                      return buffer._data.then(function(data) {
                        try {
                          return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
                        } catch (e) {
                          throw new Error("".concat(context, ": ").concat(e.message));
                        }
                      });
                    };
                    GLTFLoader2.prototype.loadBufferViewAsync = function(context, bufferView) {
                      var extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (bufferView._data) {
                        return bufferView._data;
                      }
                      var buffer = ArrayItem.Get("".concat(context, "/buffer"), this._gltf.buffers, bufferView.buffer);
                      bufferView._data = this.loadBufferAsync("/buffers/".concat(buffer.index), buffer, bufferView.byteOffset || 0, bufferView.byteLength);
                      return bufferView._data;
                    };
                    GLTFLoader2.prototype._loadAccessorAsync = function(context, accessor, constructor) {
                      var _this = this;
                      if (accessor._data) {
                        return accessor._data;
                      }
                      var numComponents = GLTFLoader2._GetNumComponents(context, accessor.type);
                      var byteStride = numComponents * babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.GetTypeByteLength(accessor.componentType);
                      var length = numComponents * accessor.count;
                      if (accessor.bufferView == void 0) {
                        accessor._data = Promise.resolve(new constructor(length));
                      } else {
                        var bufferView_1 = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
                        accessor._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView_1.index), bufferView_1).then(function(data) {
                          if (accessor.componentType === 5126 && !accessor.normalized && (!bufferView_1.byteStride || bufferView_1.byteStride === byteStride)) {
                            return GLTFLoader2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);
                          } else {
                            var typedArray_1 = new constructor(length);
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView_1.byteStride || byteStride, numComponents, accessor.componentType, typedArray_1.length, accessor.normalized || false, function(value, index) {
                              typedArray_1[index] = value;
                            });
                            return typedArray_1;
                          }
                        });
                      }
                      if (accessor.sparse) {
                        var sparse_1 = accessor.sparse;
                        accessor._data = accessor._data.then(function(data) {
                          var typedArray = data;
                          var indicesBufferView = ArrayItem.Get("".concat(context, "/sparse/indices/bufferView"), _this._gltf.bufferViews, sparse_1.indices.bufferView);
                          var valuesBufferView = ArrayItem.Get("".concat(context, "/sparse/values/bufferView"), _this._gltf.bufferViews, sparse_1.values.bufferView);
                          return Promise.all([
                            _this.loadBufferViewAsync("/bufferViews/".concat(indicesBufferView.index), indicesBufferView),
                            _this.loadBufferViewAsync("/bufferViews/".concat(valuesBufferView.index), valuesBufferView)
                          ]).then(function(_a) {
                            var indicesData = _a[0], valuesData = _a[1];
                            var indices = GLTFLoader2._GetTypedArray("".concat(context, "/sparse/indices"), sparse_1.indices.componentType, indicesData, sparse_1.indices.byteOffset, sparse_1.count);
                            var sparseLength = numComponents * sparse_1.count;
                            var values;
                            if (accessor.componentType === 5126 && !accessor.normalized) {
                              values = GLTFLoader2._GetTypedArray("".concat(context, "/sparse/values"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
                            } else {
                              var sparseData = GLTFLoader2._GetTypedArray("".concat(context, "/sparse/values"), accessor.componentType, valuesData, sparse_1.values.byteOffset, sparseLength);
                              values = new constructor(sparseLength);
                              babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, function(value, index) {
                                values[index] = value;
                              });
                            }
                            var valuesIndex = 0;
                            for (var indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {
                              var dataIndex = indices[indicesIndex] * numComponents;
                              for (var componentIndex = 0; componentIndex < numComponents; componentIndex++) {
                                typedArray[dataIndex++] = values[valuesIndex++];
                              }
                            }
                            return typedArray;
                          });
                        });
                      }
                      return accessor._data;
                    };
                    GLTFLoader2.prototype._loadFloatAccessorAsync = function(context, accessor) {
                      return this._loadAccessorAsync(context, accessor, Float32Array);
                    };
                    GLTFLoader2.prototype._loadIndicesAccessorAsync = function(context, accessor) {
                      if (accessor.type !== "SCALAR") {
                        throw new Error("".concat(context, "/type: Invalid value ").concat(accessor.type));
                      }
                      if (accessor.componentType !== 5121 && accessor.componentType !== 5123 && accessor.componentType !== 5125) {
                        throw new Error("".concat(context, "/componentType: Invalid value ").concat(accessor.componentType));
                      }
                      if (accessor._data) {
                        return accessor._data;
                      }
                      if (accessor.sparse) {
                        var constructor = GLTFLoader2._GetTypedArrayConstructor("".concat(context, "/componentType"), accessor.componentType);
                        accessor._data = this._loadAccessorAsync(context, accessor, constructor);
                      } else {
                        var bufferView = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
                        accessor._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function(data) {
                          return GLTFLoader2._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);
                        });
                      }
                      return accessor._data;
                    };
                    GLTFLoader2.prototype._loadVertexBufferViewAsync = function(bufferView) {
                      if (bufferView._babylonBuffer) {
                        return bufferView._babylonBuffer;
                      }
                      var engine = this._babylonScene.getEngine();
                      bufferView._babylonBuffer = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView).then(function(data) {
                        return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Buffer(engine, data, false);
                      });
                      return bufferView._babylonBuffer;
                    };
                    GLTFLoader2.prototype._loadVertexAccessorAsync = function(context, accessor, kind) {
                      var _a;
                      if ((_a = accessor._babylonVertexBuffer) === null || _a === void 0 ? void 0 : _a[kind]) {
                        return accessor._babylonVertexBuffer[kind];
                      }
                      if (!accessor._babylonVertexBuffer) {
                        accessor._babylonVertexBuffer = {};
                      }
                      var engine = this._babylonScene.getEngine();
                      if (accessor.sparse || accessor.bufferView == void 0) {
                        accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then(function(data) {
                          return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, data, kind, false);
                        });
                      } else {
                        var bufferView_2 = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, accessor.bufferView);
                        accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView_2).then(function(babylonBuffer) {
                          var numComponents = GLTFLoader2._GetNumComponents(context, accessor.type);
                          return new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer(engine, babylonBuffer, kind, false, void 0, bufferView_2.byteStride, void 0, accessor.byteOffset, numComponents, accessor.componentType, accessor.normalized, true, void 0, true);
                        });
                      }
                      return accessor._babylonVertexBuffer[kind];
                    };
                    GLTFLoader2.prototype._loadMaterialMetallicRoughnessPropertiesAsync = function(context, properties, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      if (properties) {
                        if (properties.baseColorFactor) {
                          babylonMaterial.albedoColor = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(properties.baseColorFactor);
                          babylonMaterial.alpha = properties.baseColorFactor[3];
                        } else {
                          babylonMaterial.albedoColor = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.White();
                        }
                        babylonMaterial.metallic = properties.metallicFactor == void 0 ? 1 : properties.metallicFactor;
                        babylonMaterial.roughness = properties.roughnessFactor == void 0 ? 1 : properties.roughnessFactor;
                        if (properties.baseColorTexture) {
                          promises.push(this.loadTextureInfoAsync("".concat(context, "/baseColorTexture"), properties.baseColorTexture, function(texture) {
                            texture.name = "".concat(babylonMaterial.name, " (Base Color)");
                            babylonMaterial.albedoTexture = texture;
                          }));
                        }
                        if (properties.metallicRoughnessTexture) {
                          properties.metallicRoughnessTexture.nonColorData = true;
                          promises.push(this.loadTextureInfoAsync("".concat(context, "/metallicRoughnessTexture"), properties.metallicRoughnessTexture, function(texture) {
                            texture.name = "".concat(babylonMaterial.name, " (Metallic Roughness)");
                            babylonMaterial.metallicTexture = texture;
                          }));
                          babylonMaterial.useMetallnessFromMetallicTextureBlue = true;
                          babylonMaterial.useRoughnessFromMetallicTextureGreen = true;
                          babylonMaterial.useRoughnessFromMetallicTextureAlpha = false;
                        }
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype._loadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      material._data = material._data || {};
                      var babylonData = material._data[babylonDrawMode];
                      if (!babylonData) {
                        this.logOpen("".concat(context, " ").concat(material.name || ""));
                        var babylonMaterial = this.createMaterial(context, material, babylonDrawMode);
                        babylonData = {
                          babylonMaterial,
                          babylonMeshes: [],
                          promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)
                        };
                        material._data[babylonDrawMode] = babylonData;
                        GLTFLoader2.AddPointerMetadata(babylonMaterial, context);
                        this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
                        this.logClose();
                      }
                      if (babylonMesh) {
                        babylonData.babylonMeshes.push(babylonMesh);
                        babylonMesh.onDisposeObservable.addOnce(function() {
                          var index = babylonData.babylonMeshes.indexOf(babylonMesh);
                          if (index !== -1) {
                            babylonData.babylonMeshes.splice(index, 1);
                          }
                        });
                      }
                      assign(babylonData.babylonMaterial);
                      return babylonData.promise.then(function() {
                        return babylonData.babylonMaterial;
                      });
                    };
                    GLTFLoader2.prototype._createDefaultMaterial = function(name, babylonDrawMode) {
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var babylonMaterial = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial(name, this._babylonScene);
                      babylonMaterial._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      babylonMaterial.fillMode = babylonDrawMode;
                      babylonMaterial.enableSpecularAntiAliasing = true;
                      babylonMaterial.useRadianceOverAlpha = !this._parent.transparencyAsCoverage;
                      babylonMaterial.useSpecularOverAlpha = !this._parent.transparencyAsCoverage;
                      babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_OPAQUE;
                      babylonMaterial.metallic = 1;
                      babylonMaterial.roughness = 1;
                      return babylonMaterial;
                    };
                    GLTFLoader2.prototype.createMaterial = function(context, material, babylonDrawMode) {
                      var extensionPromise = this._extensionsCreateMaterial(context, material, babylonDrawMode);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var name = material.name || "material".concat(material.index);
                      var babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);
                      return babylonMaterial;
                    };
                    GLTFLoader2.prototype.loadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      var extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      var promises = new Array();
                      promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
                      if (material.pbrMetallicRoughness) {
                        promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync("".concat(context, "/pbrMetallicRoughness"), material.pbrMetallicRoughness, babylonMaterial));
                      }
                      this.loadMaterialAlphaProperties(context, material, babylonMaterial);
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype.loadMaterialBasePropertiesAsync = function(context, material, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var promises = new Array();
                      babylonMaterial.emissiveColor = material.emissiveFactor ? babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3.FromArray(material.emissiveFactor) : new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Color3(0, 0, 0);
                      if (material.doubleSided) {
                        babylonMaterial.backFaceCulling = false;
                        babylonMaterial.twoSidedLighting = true;
                      }
                      if (material.normalTexture) {
                        material.normalTexture.nonColorData = true;
                        promises.push(this.loadTextureInfoAsync("".concat(context, "/normalTexture"), material.normalTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Normal)");
                          babylonMaterial.bumpTexture = texture;
                        }));
                        babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;
                        babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;
                        if (material.normalTexture.scale != void 0 && babylonMaterial.bumpTexture) {
                          babylonMaterial.bumpTexture.level = material.normalTexture.scale;
                        }
                        babylonMaterial.forceIrradianceInFragment = true;
                      }
                      if (material.occlusionTexture) {
                        material.occlusionTexture.nonColorData = true;
                        promises.push(this.loadTextureInfoAsync("".concat(context, "/occlusionTexture"), material.occlusionTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Occlusion)");
                          babylonMaterial.ambientTexture = texture;
                        }));
                        babylonMaterial.useAmbientInGrayScale = true;
                        if (material.occlusionTexture.strength != void 0) {
                          babylonMaterial.ambientTextureStrength = material.occlusionTexture.strength;
                        }
                      }
                      if (material.emissiveTexture) {
                        promises.push(this.loadTextureInfoAsync("".concat(context, "/emissiveTexture"), material.emissiveTexture, function(texture) {
                          texture.name = "".concat(babylonMaterial.name, " (Emissive)");
                          babylonMaterial.emissiveTexture = texture;
                        }));
                      }
                      return Promise.all(promises).then(function() {
                      });
                    };
                    GLTFLoader2.prototype.loadMaterialAlphaProperties = function(context, material, babylonMaterial) {
                      if (!(babylonMaterial instanceof babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial)) {
                        throw new Error("".concat(context, ": Material type not supported"));
                      }
                      var alphaMode = material.alphaMode || "OPAQUE";
                      switch (alphaMode) {
                        case "OPAQUE": {
                          babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_OPAQUE;
                          break;
                        }
                        case "MASK": {
                          babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_ALPHATEST;
                          babylonMaterial.alphaCutOff = material.alphaCutoff == void 0 ? 0.5 : material.alphaCutoff;
                          if (babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoTexture.hasAlpha = true;
                          }
                          break;
                        }
                        case "BLEND": {
                          babylonMaterial.transparencyMode = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.PBRMaterial.PBRMATERIAL_ALPHABLEND;
                          if (babylonMaterial.albedoTexture) {
                            babylonMaterial.albedoTexture.hasAlpha = true;
                            babylonMaterial.useAlphaFromAlbedoTexture = true;
                          }
                          break;
                        }
                        default: {
                          throw new Error("".concat(context, "/alphaMode: Invalid value (").concat(material.alphaMode, ")"));
                        }
                      }
                    };
                    GLTFLoader2.prototype.loadTextureInfoAsync = function(context, textureInfo, assign) {
                      var _this = this;
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      this.logOpen("".concat(context));
                      if (textureInfo.texCoord >= 6) {
                        throw new Error("".concat(context, "/texCoord: Invalid value (").concat(textureInfo.texCoord, ")"));
                      }
                      var texture = ArrayItem.Get("".concat(context, "/index"), this._gltf.textures, textureInfo.index);
                      texture._textureInfo = textureInfo;
                      var promise = this._loadTextureAsync("/textures/".concat(textureInfo.index), texture, function(babylonTexture) {
                        babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;
                        GLTFLoader2.AddPointerMetadata(babylonTexture, context);
                        _this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);
                        assign(babylonTexture);
                      });
                      this.logClose();
                      return promise;
                    };
                    GLTFLoader2.prototype._loadTextureAsync = function(context, texture, assign) {
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      this.logOpen("".concat(context, " ").concat(texture.name || ""));
                      var sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get("".concat(context, "/sampler"), this._gltf.samplers, texture.sampler);
                      var image = ArrayItem.Get("".concat(context, "/source"), this._gltf.images, texture.source);
                      var promise = this._createTextureAsync(context, sampler, image, assign, void 0, !texture._textureInfo.nonColorData);
                      this.logClose();
                      return promise;
                    };
                    GLTFLoader2.prototype._createTextureAsync = function(context, sampler, image, assign, textureLoaderOptions, useSRGBBuffer) {
                      var _this = this;
                      if (assign === void 0) {
                        assign = function() {
                        };
                      }
                      var samplerData = this._loadSampler("/samplers/".concat(sampler.index), sampler);
                      var promises = new Array();
                      var deferred = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Deferred();
                      this._babylonScene._blockEntityCollection = !!this._assetContainer;
                      var textureCreationOptions = {
                        noMipmap: samplerData.noMipMaps,
                        invertY: false,
                        samplingMode: samplerData.samplingMode,
                        onLoad: function() {
                          if (!_this._disposed) {
                            deferred.resolve();
                          }
                        },
                        onError: function(message, exception) {
                          if (!_this._disposed) {
                            deferred.reject(new Error("".concat(context, ": ").concat(exception && exception.message ? exception.message : message || "Failed to load texture")));
                          }
                        },
                        mimeType: image.mimeType,
                        loaderOptions: textureLoaderOptions,
                        useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers
                      };
                      var babylonTexture = new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture(null, this._babylonScene, textureCreationOptions);
                      babylonTexture._parentContainer = this._assetContainer;
                      this._babylonScene._blockEntityCollection = false;
                      promises.push(deferred.promise);
                      promises.push(this.loadImageAsync("/images/".concat(image.index), image).then(function(data) {
                        var name = image.uri || "".concat(_this._fileName, "#image").concat(image.index);
                        var dataUrl = "data:".concat(_this._uniqueRootUrl).concat(name);
                        babylonTexture.updateURL(dataUrl, data);
                      }));
                      babylonTexture.wrapU = samplerData.wrapU;
                      babylonTexture.wrapV = samplerData.wrapV;
                      assign(babylonTexture);
                      return Promise.all(promises).then(function() {
                        return babylonTexture;
                      });
                    };
                    GLTFLoader2.prototype._loadSampler = function(context, sampler) {
                      if (!sampler._data) {
                        sampler._data = {
                          noMipMaps: sampler.minFilter === 9728 || sampler.minFilter === 9729,
                          samplingMode: GLTFLoader2._GetTextureSamplingMode(context, sampler),
                          wrapU: GLTFLoader2._GetTextureWrapMode("".concat(context, "/wrapS"), sampler.wrapS),
                          wrapV: GLTFLoader2._GetTextureWrapMode("".concat(context, "/wrapT"), sampler.wrapT)
                        };
                      }
                      return sampler._data;
                    };
                    GLTFLoader2.prototype.loadImageAsync = function(context, image) {
                      if (!image._data) {
                        this.logOpen("".concat(context, " ").concat(image.name || ""));
                        if (image.uri) {
                          image._data = this.loadUriAsync("".concat(context, "/uri"), image, image.uri);
                        } else {
                          var bufferView = ArrayItem.Get("".concat(context, "/bufferView"), this._gltf.bufferViews, image.bufferView);
                          image._data = this.loadBufferViewAsync("/bufferViews/".concat(bufferView.index), bufferView);
                        }
                        this.logClose();
                      }
                      return image._data;
                    };
                    GLTFLoader2.prototype.loadUriAsync = function(context, property, uri) {
                      var _this = this;
                      var extensionPromise = this._extensionsLoadUriAsync(context, property, uri);
                      if (extensionPromise) {
                        return extensionPromise;
                      }
                      if (!GLTFLoader2._ValidateUri(uri)) {
                        throw new Error("".concat(context, ": '").concat(uri, "' is invalid"));
                      }
                      if ((0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.IsBase64DataUrl)(uri)) {
                        var data = new Uint8Array((0, babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.DecodeBase64UrlToBinary)(uri));
                        this.log("".concat(context, ": Decoded ").concat(uri.substr(0, 64), "... (").concat(data.length, " bytes)"));
                        return Promise.resolve(data);
                      }
                      this.log("".concat(context, ": Loading ").concat(uri));
                      return this._parent.preprocessUrlAsync(this._rootUrl + uri).then(function(url) {
                        return new Promise(function(resolve, reject) {
                          _this._parent._loadFile(_this._babylonScene, url, function(data2) {
                            if (!_this._disposed) {
                              _this.log("".concat(context, ": Loaded ").concat(uri, " (").concat(data2.byteLength, " bytes)"));
                              resolve(new Uint8Array(data2));
                            }
                          }, true, function(request) {
                            reject(new babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.LoadFileError("".concat(context, ": Failed to load '").concat(uri, "'").concat(request ? ": " + request.status + " " + request.statusText : ""), request));
                          });
                        });
                      });
                    };
                    GLTFLoader2.AddPointerMetadata = function(babylonObject, pointer) {
                      babylonObject.metadata = babylonObject.metadata || {};
                      var metadata = babylonObject._internalMetadata = babylonObject._internalMetadata || {};
                      var gltf = metadata.gltf = metadata.gltf || {};
                      var pointers = gltf.pointers = gltf.pointers || [];
                      pointers.push(pointer);
                    };
                    GLTFLoader2._GetTextureWrapMode = function(context, mode) {
                      mode = mode == void 0 ? 10497 : mode;
                      switch (mode) {
                        case 33071:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.CLAMP_ADDRESSMODE;
                        case 33648:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.MIRROR_ADDRESSMODE;
                        case 10497:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_ADDRESSMODE;
                        default:
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Invalid value (").concat(mode, ")"));
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.WRAP_ADDRESSMODE;
                      }
                    };
                    GLTFLoader2._GetTextureSamplingMode = function(context, sampler) {
                      var magFilter = sampler.magFilter == void 0 ? 9729 : sampler.magFilter;
                      var minFilter = sampler.minFilter == void 0 ? 9987 : sampler.minFilter;
                      if (magFilter === 9729) {
                        switch (minFilter) {
                          case 9728:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST;
                          case 9729:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR;
                          case 9984:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST_MIPNEAREST;
                          case 9985:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPNEAREST;
                          case 9986:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_NEAREST_MIPLINEAR;
                          case 9987:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPLINEAR;
                          default:
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/minFilter: Invalid value (").concat(minFilter, ")"));
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.LINEAR_LINEAR_MIPLINEAR;
                        }
                      } else {
                        if (magFilter !== 9728) {
                          babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/magFilter: Invalid value (").concat(magFilter, ")"));
                        }
                        switch (minFilter) {
                          case 9728:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST;
                          case 9729:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR;
                          case 9984:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST;
                          case 9985:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR_MIPNEAREST;
                          case 9986:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPLINEAR;
                          case 9987:
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_LINEAR_MIPLINEAR;
                          default:
                            babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, "/minFilter: Invalid value (").concat(minFilter, ")"));
                            return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Texture.NEAREST_NEAREST_MIPNEAREST;
                        }
                      }
                    };
                    GLTFLoader2._GetTypedArrayConstructor = function(context, componentType) {
                      switch (componentType) {
                        case 5120:
                          return Int8Array;
                        case 5121:
                          return Uint8Array;
                        case 5122:
                          return Int16Array;
                        case 5123:
                          return Uint16Array;
                        case 5125:
                          return Uint32Array;
                        case 5126:
                          return Float32Array;
                        default:
                          throw new Error("".concat(context, ": Invalid component type ").concat(componentType));
                      }
                    };
                    GLTFLoader2._GetTypedArray = function(context, componentType, bufferView, byteOffset, length) {
                      var buffer = bufferView.buffer;
                      byteOffset = bufferView.byteOffset + (byteOffset || 0);
                      var constructor = GLTFLoader2._GetTypedArrayConstructor("".concat(context, "/componentType"), componentType);
                      var componentTypeLength = babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.VertexBuffer.GetTypeByteLength(componentType);
                      if (byteOffset % componentTypeLength !== 0) {
                        babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("".concat(context, ": Copying buffer as byte offset (").concat(byteOffset, ") is not a multiple of component type byte length (").concat(componentTypeLength, ")"));
                        return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);
                      }
                      return new constructor(buffer, byteOffset, length);
                    };
                    GLTFLoader2._GetNumComponents = function(context, type) {
                      switch (type) {
                        case "SCALAR":
                          return 1;
                        case "VEC2":
                          return 2;
                        case "VEC3":
                          return 3;
                        case "VEC4":
                          return 4;
                        case "MAT2":
                          return 4;
                        case "MAT3":
                          return 9;
                        case "MAT4":
                          return 16;
                      }
                      throw new Error("".concat(context, ": Invalid type (").concat(type, ")"));
                    };
                    GLTFLoader2._ValidateUri = function(uri) {
                      return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Tools.IsBase64(uri) || uri.indexOf("..") === -1;
                    };
                    GLTFLoader2._GetDrawMode = function(context, mode) {
                      if (mode == void 0) {
                        mode = 4;
                      }
                      switch (mode) {
                        case 0:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.PointListDrawMode;
                        case 1:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineListDrawMode;
                        case 2:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineLoopDrawMode;
                        case 3:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.LineStripDrawMode;
                        case 4:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFillMode;
                        case 5:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleStripDrawMode;
                        case 6:
                          return babylonjs_Misc_deferred__WEBPACK_IMPORTED_MODULE_0__.Material.TriangleFanDrawMode;
                      }
                      throw new Error("".concat(context, ": Invalid mesh primitive mode (").concat(mode, ")"));
                    };
                    GLTFLoader2.prototype._compileMaterialsAsync = function() {
                      var _this = this;
                      this._parent._startPerformanceCounter("Compile materials");
                      var promises = new Array();
                      if (this._gltf.materials) {
                        for (var _i = 0, _a = this._gltf.materials; _i < _a.length; _i++) {
                          var material = _a[_i];
                          if (material._data) {
                            for (var babylonDrawMode in material._data) {
                              var babylonData = material._data[babylonDrawMode];
                              for (var _b = 0, _c = babylonData.babylonMeshes; _b < _c.length; _b++) {
                                var babylonMesh = _c[_b];
                                babylonMesh.computeWorldMatrix(true);
                                var babylonMaterial = babylonData.babylonMaterial;
                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));
                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));
                                if (this._parent.useClipPlane) {
                                  promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));
                                  promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));
                                }
                              }
                            }
                          }
                        }
                      }
                      return Promise.all(promises).then(function() {
                        _this._parent._endPerformanceCounter("Compile materials");
                      });
                    };
                    GLTFLoader2.prototype._compileShadowGeneratorsAsync = function() {
                      var _this = this;
                      this._parent._startPerformanceCounter("Compile shadow generators");
                      var promises = new Array();
                      var lights = this._babylonScene.lights;
                      for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                        var light = lights_1[_i];
                        var generator = light.getShadowGenerator();
                        if (generator) {
                          promises.push(generator.forceCompilationAsync());
                        }
                      }
                      return Promise.all(promises).then(function() {
                        _this._parent._endPerformanceCounter("Compile shadow generators");
                      });
                    };
                    GLTFLoader2.prototype._forEachExtensions = function(action) {
                      for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
                        var extension = _a[_i];
                        if (extension.enabled) {
                          action(extension);
                        }
                      }
                    };
                    GLTFLoader2.prototype._applyExtensions = function(property, functionName, actionAsync) {
                      for (var _i = 0, _a = this._extensions; _i < _a.length; _i++) {
                        var extension = _a[_i];
                        if (extension.enabled) {
                          var id = "".concat(extension.name, ".").concat(functionName);
                          var loaderProperty = property;
                          loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};
                          var activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;
                          if (!activeLoaderExtensionFunctions[id]) {
                            activeLoaderExtensionFunctions[id] = true;
                            try {
                              var result = actionAsync(extension);
                              if (result) {
                                return result;
                              }
                            } finally {
                              delete activeLoaderExtensionFunctions[id];
                            }
                          }
                        }
                      }
                      return null;
                    };
                    GLTFLoader2.prototype._extensionsOnLoading = function() {
                      this._forEachExtensions(function(extension) {
                        return extension.onLoading && extension.onLoading();
                      });
                    };
                    GLTFLoader2.prototype._extensionsOnReady = function() {
                      this._forEachExtensions(function(extension) {
                        return extension.onReady && extension.onReady();
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadSceneAsync = function(context, scene) {
                      return this._applyExtensions(scene, "loadScene", function(extension) {
                        return extension.loadSceneAsync && extension.loadSceneAsync(context, scene);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadNodeAsync = function(context, node, assign) {
                      return this._applyExtensions(node, "loadNode", function(extension) {
                        return extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadCameraAsync = function(context, camera, assign) {
                      return this._applyExtensions(camera, "loadCamera", function(extension) {
                        return extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadVertexDataAsync = function(context, primitive, babylonMesh) {
                      return this._applyExtensions(primitive, "loadVertexData", function(extension) {
                        return extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadMeshPrimitiveAsync = function(context, name, node, mesh, primitive, assign) {
                      return this._applyExtensions(primitive, "loadMeshPrimitive", function(extension) {
                        return extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadMaterialAsync = function(context, material, babylonMesh, babylonDrawMode, assign) {
                      return this._applyExtensions(material, "loadMaterial", function(extension) {
                        return extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsCreateMaterial = function(context, material, babylonDrawMode) {
                      return this._applyExtensions(material, "createMaterial", function(extension) {
                        return extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadMaterialPropertiesAsync = function(context, material, babylonMaterial) {
                      return this._applyExtensions(material, "loadMaterialProperties", function(extension) {
                        return extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadTextureInfoAsync = function(context, textureInfo, assign) {
                      return this._applyExtensions(textureInfo, "loadTextureInfo", function(extension) {
                        return extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadTextureAsync = function(context, texture, assign) {
                      return this._applyExtensions(texture, "loadTexture", function(extension) {
                        return extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadAnimationAsync = function(context, animation) {
                      return this._applyExtensions(animation, "loadAnimation", function(extension) {
                        return extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadAnimationChannelAsync = function(context, animationContext, animation, channel, onLoad) {
                      return this._applyExtensions(animation, "loadAnimationChannel", function(extension) {
                        return extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadSkinAsync = function(context, node, skin) {
                      return this._applyExtensions(skin, "loadSkin", function(extension) {
                        return extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadUriAsync = function(context, property, uri) {
                      return this._applyExtensions(property, "loadUri", function(extension) {
                        return extension._loadUriAsync && extension._loadUriAsync(context, property, uri);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadBufferViewAsync = function(context, bufferView) {
                      return this._applyExtensions(bufferView, "loadBufferView", function(extension) {
                        return extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView);
                      });
                    };
                    GLTFLoader2.prototype._extensionsLoadBufferAsync = function(context, buffer, byteOffset, byteLength) {
                      return this._applyExtensions(buffer, "loadBuffer", function(extension) {
                        return extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength);
                      });
                    };
                    GLTFLoader2.LoadExtensionAsync = function(context, property, extensionName, actionAsync) {
                      if (!property.extensions) {
                        return null;
                      }
                      var extensions = property.extensions;
                      var extension = extensions[extensionName];
                      if (!extension) {
                        return null;
                      }
                      return actionAsync("".concat(context, "/extensions/").concat(extensionName), extension);
                    };
                    GLTFLoader2.LoadExtraAsync = function(context, property, extensionName, actionAsync) {
                      if (!property.extras) {
                        return null;
                      }
                      var extras = property.extras;
                      var extra = extras[extensionName];
                      if (!extra) {
                        return null;
                      }
                      return actionAsync("".concat(context, "/extras/").concat(extensionName), extra);
                    };
                    GLTFLoader2.prototype.isExtensionUsed = function(name) {
                      return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;
                    };
                    GLTFLoader2.prototype.logOpen = function(message) {
                      this._parent._logOpen(message);
                    };
                    GLTFLoader2.prototype.logClose = function() {
                      this._parent._logClose();
                    };
                    GLTFLoader2.prototype.log = function(message) {
                      this._parent._log(message);
                    };
                    GLTFLoader2.prototype.startPerformanceCounter = function(counterName) {
                      this._parent._startPerformanceCounter(counterName);
                    };
                    GLTFLoader2.prototype.endPerformanceCounter = function(counterName) {
                      this._parent._endPerformanceCounter(counterName);
                    };
                    GLTFLoader2._RegisteredExtensions = {};
                    GLTFLoader2.DefaultSampler = { index: -1 };
                    return GLTFLoader2;
                  }()
                );
                _glTFFileLoader__WEBPACK_IMPORTED_MODULE_1__.GLTFFileLoader._CreateGLTF2Loader = function(parent) {
                  return new GLTFLoader(parent);
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  AnimationPropertyInfo: () => (
                    /* binding */
                    AnimationPropertyInfo
                  ),
                  /* harmony export */
                  TransformNodeAnimationPropertyInfo: () => (
                    /* binding */
                    TransformNodeAnimationPropertyInfo
                  ),
                  /* harmony export */
                  WeightAnimationPropertyInfo: () => (
                    /* binding */
                    WeightAnimationPropertyInfo
                  ),
                  /* harmony export */
                  getQuaternion: () => (
                    /* binding */
                    getQuaternion
                  ),
                  /* harmony export */
                  getVector3: () => (
                    /* binding */
                    getVector3
                  ),
                  /* harmony export */
                  getWeights: () => (
                    /* binding */
                    getWeights
                  ),
                  /* harmony export */
                  nodeAnimationData: () => (
                    /* binding */
                    nodeAnimationData
                  )
                  /* harmony export */
                });
                var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! tslib */
                  "../../../../node_modules/tslib/tslib.es6.mjs"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Maths/math.vector */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__);
                function getVector3(_target, source, offset, scale) {
                  return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Vector3.FromArray(source, offset).scaleInPlace(scale);
                }
                function getQuaternion(_target, source, offset, scale) {
                  return babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Quaternion.FromArray(source, offset).scaleInPlace(scale);
                }
                function getWeights(target, source, offset, scale) {
                  var value = new Array(target._numMorphTargets);
                  for (var i = 0; i < value.length; i++) {
                    value[i] = source[offset++] * scale;
                  }
                  return value;
                }
                var AnimationPropertyInfo = (
                  /** @class */
                  function() {
                    function AnimationPropertyInfo2(type, name, getValue, getStride) {
                      this.type = type;
                      this.name = name;
                      this.getValue = getValue;
                      this.getStride = getStride;
                    }
                    AnimationPropertyInfo2.prototype._buildAnimation = function(name, fps, keys) {
                      var babylonAnimation = new babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation(name, this.name, fps, this.type);
                      babylonAnimation.setKeys(keys);
                      return babylonAnimation;
                    };
                    return AnimationPropertyInfo2;
                  }()
                );
                var TransformNodeAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(TransformNodeAnimationPropertyInfo2, _super);
                    function TransformNodeAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    TransformNodeAnimationPropertyInfo2.prototype.buildAnimations = function(target, name, fps, keys, callback) {
                      callback(target._babylonTransformNode, this._buildAnimation(name, fps, keys));
                    };
                    return TransformNodeAnimationPropertyInfo2;
                  }(AnimationPropertyInfo)
                );
                var WeightAnimationPropertyInfo = (
                  /** @class */
                  function(_super) {
                    (0, tslib__WEBPACK_IMPORTED_MODULE_1__.__extends)(WeightAnimationPropertyInfo2, _super);
                    function WeightAnimationPropertyInfo2() {
                      return _super !== null && _super.apply(this, arguments) || this;
                    }
                    WeightAnimationPropertyInfo2.prototype.buildAnimations = function(target, name, fps, keys, callback) {
                      if (target._numMorphTargets) {
                        var _loop_1 = function(targetIndex2) {
                          var babylonAnimation = new babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation("".concat(name, "_").concat(targetIndex2), this_1.name, fps, this_1.type);
                          babylonAnimation.setKeys(keys.map(function(key) {
                            return {
                              frame: key.frame,
                              inTangent: key.inTangent ? key.inTangent[targetIndex2] : void 0,
                              value: key.value[targetIndex2],
                              outTangent: key.outTangent ? key.outTangent[targetIndex2] : void 0,
                              interpolation: key.interpolation
                            };
                          }));
                          if (target._primitiveBabylonMeshes) {
                            for (var _i = 0, _a = target._primitiveBabylonMeshes; _i < _a.length; _i++) {
                              var babylonMesh = _a[_i];
                              if (babylonMesh.morphTargetManager) {
                                var morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex2);
                                var babylonAnimationClone = babylonAnimation.clone();
                                morphTarget.animations.push(babylonAnimationClone);
                                callback(morphTarget, babylonAnimationClone);
                              }
                            }
                          }
                        };
                        var this_1 = this;
                        for (var targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {
                          _loop_1(targetIndex);
                        }
                      }
                    };
                    return WeightAnimationPropertyInfo2;
                  }(AnimationPropertyInfo)
                );
                var nodeAnimationData = {
                  translation: [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_VECTOR3, "position", getVector3, function() {
                    return 3;
                  })],
                  rotation: [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_QUATERNION, "rotationQuaternion", getQuaternion, function() {
                    return 4;
                  })],
                  scale: [new TransformNodeAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_VECTOR3, "scaling", getVector3, function() {
                    return 3;
                  })],
                  weights: [new WeightAnimationPropertyInfo(babylonjs_Animations_animation__WEBPACK_IMPORTED_MODULE_0__.Animation.ANIMATIONTYPE_FLOAT, "influence", getWeights, function(target) {
                    return target._numMorphTargets;
                  })]
                };
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts": (
              /*!****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts ***!
                \****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts": (
              /*!*****************************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts ***!
                \*****************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/2.0/index.ts": (
              /*!**************************************************!*\
                !*** ../../../dev/loaders/src/glTF/2.0/index.ts ***!
                \**************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  ArrayItem: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.ArrayItem
                  ),
                  /* harmony export */
                  EXT_lights_image_based: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.EXT_lights_image_based
                  ),
                  /* harmony export */
                  EXT_mesh_gpu_instancing: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.EXT_mesh_gpu_instancing
                  ),
                  /* harmony export */
                  EXT_meshopt_compression: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.EXT_meshopt_compression
                  ),
                  /* harmony export */
                  EXT_texture_webp: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.EXT_texture_webp
                  ),
                  /* harmony export */
                  ExtrasAsMetadata: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.ExtrasAsMetadata
                  ),
                  /* harmony export */
                  GLTFLoader: () => (
                    /* reexport safe */
                    _glTFLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoader
                  ),
                  /* harmony export */
                  KHR_animation_pointer: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_animation_pointer
                  ),
                  /* harmony export */
                  KHR_draco_mesh_compression: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_draco_mesh_compression
                  ),
                  /* harmony export */
                  KHR_lights: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_lights
                  ),
                  /* harmony export */
                  KHR_materials_anisotropy: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_anisotropy
                  ),
                  /* harmony export */
                  KHR_materials_clearcoat: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_clearcoat
                  ),
                  /* harmony export */
                  KHR_materials_emissive_strength: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_emissive_strength
                  ),
                  /* harmony export */
                  KHR_materials_ior: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_ior
                  ),
                  /* harmony export */
                  KHR_materials_iridescence: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_iridescence
                  ),
                  /* harmony export */
                  KHR_materials_pbrSpecularGlossiness: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_pbrSpecularGlossiness
                  ),
                  /* harmony export */
                  KHR_materials_sheen: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_sheen
                  ),
                  /* harmony export */
                  KHR_materials_specular: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_specular
                  ),
                  /* harmony export */
                  KHR_materials_translucency: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_translucency
                  ),
                  /* harmony export */
                  KHR_materials_transmission: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_transmission
                  ),
                  /* harmony export */
                  KHR_materials_unlit: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_unlit
                  ),
                  /* harmony export */
                  KHR_materials_variants: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_variants
                  ),
                  /* harmony export */
                  KHR_materials_volume: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_materials_volume
                  ),
                  /* harmony export */
                  KHR_mesh_quantization: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_mesh_quantization
                  ),
                  /* harmony export */
                  KHR_texture_basisu: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_texture_basisu
                  ),
                  /* harmony export */
                  KHR_texture_transform: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_texture_transform
                  ),
                  /* harmony export */
                  KHR_xmp_json_ld: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.KHR_xmp_json_ld
                  ),
                  /* harmony export */
                  MSFT_audio_emitter: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.MSFT_audio_emitter
                  ),
                  /* harmony export */
                  MSFT_lod: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.MSFT_lod
                  ),
                  /* harmony export */
                  MSFT_minecraftMesh: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.MSFT_minecraftMesh
                  ),
                  /* harmony export */
                  MSFT_sRGBFactors: () => (
                    /* reexport safe */
                    _Extensions_index__WEBPACK_IMPORTED_MODULE_3__.MSFT_sRGBFactors
                  )
                  /* harmony export */
                });
                var _glTFLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFLoader */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoader.ts"
                );
                var _glTFLoaderExtension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFLoaderExtension */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderExtension.ts"
                );
                var _glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts"
                );
                var _Extensions_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./Extensions/index */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/glTFFileLoader.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/glTFFileLoader.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* binding */
                    GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* binding */
                    GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* binding */
                    GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* binding */
                    GLTFLoaderState
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/error */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__);
                var _glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFValidation */
                  "../../../dev/loaders/src/glTF/glTFValidation.ts"
                );
                function readAsync(arrayBuffer, byteOffset, byteLength) {
                  try {
                    return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
                  } catch (e) {
                    return Promise.reject(e);
                  }
                }
                function readViewAsync(arrayBufferView, byteOffset, byteLength) {
                  try {
                    if (arrayBufferView.byteOffset + byteOffset + byteLength > arrayBufferView.buffer.byteLength) {
                      throw new Error("Array length out of bounds.");
                    }
                    return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));
                  } catch (e) {
                    return Promise.reject(e);
                  }
                }
                var GLTFLoaderCoordinateSystemMode;
                (function(GLTFLoaderCoordinateSystemMode2) {
                  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["AUTO"] = 0] = "AUTO";
                  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
                })(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));
                var GLTFLoaderAnimationStartMode;
                (function(GLTFLoaderAnimationStartMode2) {
                  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["NONE"] = 0] = "NONE";
                  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["FIRST"] = 1] = "FIRST";
                  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["ALL"] = 2] = "ALL";
                })(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));
                var GLTFLoaderState;
                (function(GLTFLoaderState2) {
                  GLTFLoaderState2[GLTFLoaderState2["LOADING"] = 0] = "LOADING";
                  GLTFLoaderState2[GLTFLoaderState2["READY"] = 1] = "READY";
                  GLTFLoaderState2[GLTFLoaderState2["COMPLETE"] = 2] = "COMPLETE";
                })(GLTFLoaderState || (GLTFLoaderState = {}));
                var GLTFFileLoader = (
                  /** @class */
                  function() {
                    function GLTFFileLoader2() {
                      this.onParsedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
                      this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
                      this.compileMaterials = false;
                      this.useClipPlane = false;
                      this.compileShadowGenerators = false;
                      this.transparencyAsCoverage = false;
                      this.useRangeRequests = false;
                      this.createInstances = true;
                      this.alwaysComputeBoundingBox = false;
                      this.loadAllMaterials = false;
                      this.loadOnlyMaterials = false;
                      this.skipMaterials = false;
                      this.useSRGBBuffers = true;
                      this.targetFps = 60;
                      this.alwaysComputeSkeletonRootNode = false;
                      this.preprocessUrlAsync = function(url) {
                        return Promise.resolve(url);
                      };
                      this.onMeshLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onSkinLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onTextureLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onMaterialLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onCameraLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onCompleteObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onErrorObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onDisposeObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.onExtensionLoadedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this.validate = false;
                      this.onValidatedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this._loader = null;
                      this._state = null;
                      this._requests = new Array();
                      this.name = "gltf";
                      this.extensions = {
                        ".gltf": { isBinary: false },
                        ".glb": { isBinary: true }
                      };
                      this.onLoaderStateChangedObservable = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable();
                      this._logIndentLevel = 0;
                      this._loggingEnabled = false;
                      this._log = this._logDisabled;
                      this._capturePerformanceCounters = false;
                      this._startPerformanceCounter = this._startPerformanceCounterDisabled;
                      this._endPerformanceCounter = this._endPerformanceCounterDisabled;
                    }
                    Object.defineProperty(GLTFFileLoader2.prototype, "onParsed", {
                      /**
                       * Raised when the asset has been parsed
                       */
                      set: function(callback) {
                        if (this._onParsedObserver) {
                          this.onParsedObservable.remove(this._onParsedObserver);
                        }
                        this._onParsedObserver = this.onParsedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onMeshLoaded", {
                      /**
                       * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
                       * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
                       */
                      set: function(callback) {
                        if (this._onMeshLoadedObserver) {
                          this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
                        }
                        this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onTextureLoaded", {
                      /**
                       * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
                       */
                      set: function(callback) {
                        if (this._onTextureLoadedObserver) {
                          this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
                        }
                        this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onMaterialLoaded", {
                      /**
                       * Callback raised when the loader creates a material after parsing the glTF properties of the material.
                       */
                      set: function(callback) {
                        if (this._onMaterialLoadedObserver) {
                          this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
                        }
                        this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onCameraLoaded", {
                      /**
                       * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
                       */
                      set: function(callback) {
                        if (this._onCameraLoadedObserver) {
                          this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
                        }
                        this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onComplete", {
                      /**
                       * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
                       * For assets with LODs, raised when all of the LODs are complete.
                       * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
                       */
                      set: function(callback) {
                        if (this._onCompleteObserver) {
                          this.onCompleteObservable.remove(this._onCompleteObserver);
                        }
                        this._onCompleteObserver = this.onCompleteObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onError", {
                      /**
                       * Callback raised when an error occurs.
                       */
                      set: function(callback) {
                        if (this._onErrorObserver) {
                          this.onErrorObservable.remove(this._onErrorObserver);
                        }
                        this._onErrorObserver = this.onErrorObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onDispose", {
                      /**
                       * Callback raised after the loader is disposed.
                       */
                      set: function(callback) {
                        if (this._onDisposeObserver) {
                          this.onDisposeObservable.remove(this._onDisposeObserver);
                        }
                        this._onDisposeObserver = this.onDisposeObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onExtensionLoaded", {
                      /**
                       * Callback raised after a loader extension is created.
                       */
                      set: function(callback) {
                        if (this._onExtensionLoadedObserver) {
                          this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
                        }
                        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "loggingEnabled", {
                      /**
                       * Defines if the loader logging is enabled.
                       */
                      get: function() {
                        return this._loggingEnabled;
                      },
                      set: function(value) {
                        if (this._loggingEnabled === value) {
                          return;
                        }
                        this._loggingEnabled = value;
                        if (this._loggingEnabled) {
                          this._log = this._logEnabled;
                        } else {
                          this._log = this._logDisabled;
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "capturePerformanceCounters", {
                      /**
                       * Defines if the loader should capture performance counters.
                       */
                      get: function() {
                        return this._capturePerformanceCounters;
                      },
                      set: function(value) {
                        if (this._capturePerformanceCounters === value) {
                          return;
                        }
                        this._capturePerformanceCounters = value;
                        if (this._capturePerformanceCounters) {
                          this._startPerformanceCounter = this._startPerformanceCounterEnabled;
                          this._endPerformanceCounter = this._endPerformanceCounterEnabled;
                        } else {
                          this._startPerformanceCounter = this._startPerformanceCounterDisabled;
                          this._endPerformanceCounter = this._endPerformanceCounterDisabled;
                        }
                      },
                      enumerable: false,
                      configurable: true
                    });
                    Object.defineProperty(GLTFFileLoader2.prototype, "onValidated", {
                      /**
                       * Callback raised after a loader extension is created.
                       */
                      set: function(callback) {
                        if (this._onValidatedObserver) {
                          this.onValidatedObservable.remove(this._onValidatedObserver);
                        }
                        this._onValidatedObserver = this.onValidatedObservable.add(callback);
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFFileLoader2.prototype.dispose = function() {
                      if (this._loader) {
                        this._loader.dispose();
                        this._loader = null;
                      }
                      for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
                        var request = _a[_i];
                        request.abort();
                      }
                      this._requests.length = 0;
                      delete this._progressCallback;
                      this.preprocessUrlAsync = function(url) {
                        return Promise.resolve(url);
                      };
                      this.onMeshLoadedObservable.clear();
                      this.onSkinLoadedObservable.clear();
                      this.onTextureLoadedObservable.clear();
                      this.onMaterialLoadedObservable.clear();
                      this.onCameraLoadedObservable.clear();
                      this.onCompleteObservable.clear();
                      this.onExtensionLoadedObservable.clear();
                      this.onDisposeObservable.notifyObservers(void 0);
                      this.onDisposeObservable.clear();
                    };
                    GLTFFileLoader2.prototype.loadFile = function(scene, fileOrUrl, rootUrl, onSuccess, onProgress, useArrayBuffer, onError, name) {
                      var _this = this;
                      if (ArrayBuffer.isView(fileOrUrl)) {
                        this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name);
                        return null;
                      }
                      this._progressCallback = onProgress;
                      var fileName = fileOrUrl.name || babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.GetFilename(fileOrUrl);
                      if (useArrayBuffer) {
                        if (this.useRangeRequests) {
                          if (this.validate) {
                            babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("glTF validation is not supported when range requests are enabled");
                          }
                          var fileRequest_1 = {
                            abort: function() {
                            },
                            onCompleteObservable: new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Observable()
                          };
                          var dataBuffer = {
                            readAsync: function(byteOffset, byteLength) {
                              return new Promise(function(resolve, reject) {
                                _this._loadFile(scene, fileOrUrl, function(data) {
                                  resolve(new Uint8Array(data));
                                }, true, function(error) {
                                  reject(error);
                                }, function(webRequest) {
                                  webRequest.setRequestHeader("Range", "bytes=".concat(byteOffset, "-").concat(byteOffset + byteLength - 1));
                                });
                              });
                            },
                            byteLength: 0
                          };
                          this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader(dataBuffer)).then(function(loaderData) {
                            fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
                            onSuccess(loaderData);
                          }, onError ? function(error) {
                            return onError(void 0, error);
                          } : void 0);
                          return fileRequest_1;
                        }
                        return this._loadFile(scene, fileOrUrl, function(data) {
                          _this._validate(scene, new Uint8Array(data), rootUrl, fileName);
                          _this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                            readAsync: function(byteOffset, byteLength) {
                              return readAsync(data, byteOffset, byteLength);
                            },
                            byteLength: data.byteLength
                          })).then(function(loaderData) {
                            onSuccess(loaderData);
                          }, onError ? function(error) {
                            return onError(void 0, error);
                          } : void 0);
                        }, true, onError);
                      }
                      return this._loadFile(scene, fileOrUrl, function(data) {
                        _this._validate(scene, new Uint8Array(data), rootUrl, fileName);
                        onSuccess({ json: _this._parseJson(data) });
                      }, useArrayBuffer, onError);
                    };
                    GLTFFileLoader2.prototype._loadBinary = function(scene, data, rootUrl, onSuccess, onError, fileName) {
                      this._validate(scene, data, rootUrl, fileName);
                      this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                        readAsync: function(byteOffset, byteLength) {
                          return readViewAsync(data, byteOffset, byteLength);
                        },
                        byteLength: data.byteLength
                      })).then(function(loaderData) {
                        onSuccess(loaderData);
                      }, onError ? function(error) {
                        return onError(void 0, error);
                      } : void 0);
                    };
                    GLTFFileLoader2.prototype.importMeshAsync = function(meshesNames, scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this.onParsedObservable.notifyObservers(data);
                        _this.onParsedObservable.clear();
                        _this._log("Loading ".concat(fileName || ""));
                        _this._loader = _this._getLoader(data);
                        return _this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);
                      });
                    };
                    GLTFFileLoader2.prototype.loadAsync = function(scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this.onParsedObservable.notifyObservers(data);
                        _this.onParsedObservable.clear();
                        _this._log("Loading ".concat(fileName || ""));
                        _this._loader = _this._getLoader(data);
                        return _this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);
                      });
                    };
                    GLTFFileLoader2.prototype.loadAssetContainerAsync = function(scene, data, rootUrl, onProgress, fileName) {
                      var _this = this;
                      return Promise.resolve().then(function() {
                        _this.onParsedObservable.notifyObservers(data);
                        _this.onParsedObservable.clear();
                        _this._log("Loading ".concat(fileName || ""));
                        _this._loader = _this._getLoader(data);
                        var container = new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.AssetContainer(scene);
                        var materials = [];
                        _this.onMaterialLoadedObservable.add(function(material) {
                          materials.push(material);
                        });
                        var textures = [];
                        _this.onTextureLoadedObservable.add(function(texture) {
                          textures.push(texture);
                        });
                        var cameras = [];
                        _this.onCameraLoadedObservable.add(function(camera) {
                          cameras.push(camera);
                        });
                        var morphTargetManagers = [];
                        _this.onMeshLoadedObservable.add(function(mesh) {
                          if (mesh.morphTargetManager) {
                            morphTargetManagers.push(mesh.morphTargetManager);
                          }
                        });
                        return _this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then(function(result) {
                          Array.prototype.push.apply(container.geometries, result.geometries);
                          Array.prototype.push.apply(container.meshes, result.meshes);
                          Array.prototype.push.apply(container.particleSystems, result.particleSystems);
                          Array.prototype.push.apply(container.skeletons, result.skeletons);
                          Array.prototype.push.apply(container.animationGroups, result.animationGroups);
                          Array.prototype.push.apply(container.materials, materials);
                          Array.prototype.push.apply(container.textures, textures);
                          Array.prototype.push.apply(container.lights, result.lights);
                          Array.prototype.push.apply(container.transformNodes, result.transformNodes);
                          Array.prototype.push.apply(container.cameras, cameras);
                          Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);
                          return container;
                        });
                      });
                    };
                    GLTFFileLoader2.prototype.canDirectLoad = function(data) {
                      return data.indexOf("asset") !== -1 && data.indexOf("version") !== -1 || data.startsWith("data:base64," + GLTFFileLoader2._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
                      data.startsWith("data:;base64," + GLTFFileLoader2._MagicBase64Encoded) || data.startsWith("data:application/octet-stream;base64," + GLTFFileLoader2._MagicBase64Encoded) || data.startsWith("data:model/gltf-binary;base64," + GLTFFileLoader2._MagicBase64Encoded);
                    };
                    GLTFFileLoader2.prototype.directLoad = function(scene, data) {
                      if (data.startsWith("base64," + GLTFFileLoader2._MagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
                      data.startsWith(";base64," + GLTFFileLoader2._MagicBase64Encoded) || data.startsWith("application/octet-stream;base64," + GLTFFileLoader2._MagicBase64Encoded) || data.startsWith("model/gltf-binary;base64," + GLTFFileLoader2._MagicBase64Encoded)) {
                        var arrayBuffer_1 = (0, babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DecodeBase64UrlToBinary)(data);
                        this._validate(scene, new Uint8Array(arrayBuffer_1));
                        return this._unpackBinaryAsync(new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.DataReader({
                          readAsync: function(byteOffset, byteLength) {
                            return readAsync(arrayBuffer_1, byteOffset, byteLength);
                          },
                          byteLength: arrayBuffer_1.byteLength
                        }));
                      }
                      this._validate(scene, data);
                      return Promise.resolve({ json: this._parseJson(data) });
                    };
                    GLTFFileLoader2.prototype.createPlugin = function() {
                      return new GLTFFileLoader2();
                    };
                    Object.defineProperty(GLTFFileLoader2.prototype, "loaderState", {
                      /**
                       * The loader state or null if the loader is not active.
                       */
                      get: function() {
                        return this._state;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    GLTFFileLoader2.prototype.whenCompleteAsync = function() {
                      var _this = this;
                      return new Promise(function(resolve, reject) {
                        _this.onCompleteObservable.addOnce(function() {
                          resolve();
                        });
                        _this.onErrorObservable.addOnce(function(reason) {
                          reject(reason);
                        });
                      });
                    };
                    GLTFFileLoader2.prototype._setState = function(state) {
                      if (this._state === state) {
                        return;
                      }
                      this._state = state;
                      this.onLoaderStateChangedObservable.notifyObservers(this._state);
                      this._log(GLTFLoaderState[this._state]);
                    };
                    GLTFFileLoader2.prototype._loadFile = function(scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {
                      var _this = this;
                      var request = scene._loadFile(fileOrUrl, onSuccess, function(event) {
                        _this._onProgress(event, request);
                      }, true, useArrayBuffer, onError, onOpened);
                      request.onCompleteObservable.add(function(request2) {
                        _this._requests.splice(_this._requests.indexOf(request2), 1);
                      });
                      this._requests.push(request);
                      return request;
                    };
                    GLTFFileLoader2.prototype._onProgress = function(event, request) {
                      if (!this._progressCallback) {
                        return;
                      }
                      request._lengthComputable = event.lengthComputable;
                      request._loaded = event.loaded;
                      request._total = event.total;
                      var lengthComputable = true;
                      var loaded = 0;
                      var total = 0;
                      for (var _i = 0, _a = this._requests; _i < _a.length; _i++) {
                        var request_1 = _a[_i];
                        if (request_1._lengthComputable === void 0 || request_1._loaded === void 0 || request_1._total === void 0) {
                          return;
                        }
                        lengthComputable = lengthComputable && request_1._lengthComputable;
                        loaded += request_1._loaded;
                        total += request_1._total;
                      }
                      this._progressCallback({
                        lengthComputable,
                        loaded,
                        total: lengthComputable ? total : 0
                      });
                    };
                    GLTFFileLoader2.prototype._validate = function(scene, data, rootUrl, fileName) {
                      var _this = this;
                      if (rootUrl === void 0) {
                        rootUrl = "";
                      }
                      if (fileName === void 0) {
                        fileName = "";
                      }
                      if (!this.validate) {
                        return;
                      }
                      this._startPerformanceCounter("Validate JSON");
                      _glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation.ValidateAsync(data, rootUrl, fileName, function(uri) {
                        return _this.preprocessUrlAsync(rootUrl + uri).then(function(url) {
                          return scene._loadFileAsync(url, void 0, true, true);
                        });
                      }).then(function(result) {
                        _this._endPerformanceCounter("Validate JSON");
                        _this.onValidatedObservable.notifyObservers(result);
                        _this.onValidatedObservable.clear();
                      }, function(reason) {
                        _this._endPerformanceCounter("Validate JSON");
                        babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.Warn("Failed to validate: ".concat(reason.message));
                        _this.onValidatedObservable.clear();
                      });
                    };
                    GLTFFileLoader2.prototype._getLoader = function(loaderData) {
                      var asset = loaderData.json.asset || {};
                      this._log("Asset version: ".concat(asset.version));
                      asset.minVersion && this._log("Asset minimum version: ".concat(asset.minVersion));
                      asset.generator && this._log("Asset generator: ".concat(asset.generator));
                      var version = GLTFFileLoader2._parseVersion(asset.version);
                      if (!version) {
                        throw new Error("Invalid version: " + asset.version);
                      }
                      if (asset.minVersion !== void 0) {
                        var minVersion = GLTFFileLoader2._parseVersion(asset.minVersion);
                        if (!minVersion) {
                          throw new Error("Invalid minimum version: " + asset.minVersion);
                        }
                        if (GLTFFileLoader2._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
                          throw new Error("Incompatible minimum version: " + asset.minVersion);
                        }
                      }
                      var createLoaders = {
                        1: GLTFFileLoader2._CreateGLTF1Loader,
                        2: GLTFFileLoader2._CreateGLTF2Loader
                      };
                      var createLoader = createLoaders[version.major];
                      if (!createLoader) {
                        throw new Error("Unsupported version: " + asset.version);
                      }
                      return createLoader(this);
                    };
                    GLTFFileLoader2.prototype._parseJson = function(json) {
                      this._startPerformanceCounter("Parse JSON");
                      this._log("JSON length: ".concat(json.length));
                      var parsed = JSON.parse(json);
                      this._endPerformanceCounter("Parse JSON");
                      return parsed;
                    };
                    GLTFFileLoader2.prototype._unpackBinaryAsync = function(dataReader) {
                      var _this = this;
                      this._startPerformanceCounter("Unpack Binary");
                      return dataReader.loadAsync(20).then(function() {
                        var Binary = {
                          Magic: 1179937895
                        };
                        var magic = dataReader.readUint32();
                        if (magic !== Binary.Magic) {
                          throw new babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.RuntimeError("Unexpected magic: " + magic, babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.ErrorCodes.GLTFLoaderUnexpectedMagicError);
                        }
                        var version = dataReader.readUint32();
                        if (_this.loggingEnabled) {
                          _this._log("Binary version: ".concat(version));
                        }
                        var length = dataReader.readUint32();
                        if (!_this.useRangeRequests && length !== dataReader.buffer.byteLength) {
                          babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Warn("Length in header does not match actual data length: ".concat(length, " != ").concat(dataReader.buffer.byteLength));
                        }
                        var unpacked;
                        switch (version) {
                          case 1: {
                            unpacked = _this._unpackBinaryV1Async(dataReader, length);
                            break;
                          }
                          case 2: {
                            unpacked = _this._unpackBinaryV2Async(dataReader, length);
                            break;
                          }
                          default: {
                            throw new Error("Unsupported version: " + version);
                          }
                        }
                        _this._endPerformanceCounter("Unpack Binary");
                        return unpacked;
                      });
                    };
                    GLTFFileLoader2.prototype._unpackBinaryV1Async = function(dataReader, length) {
                      var ContentFormat = {
                        JSON: 0
                      };
                      var contentLength = dataReader.readUint32();
                      var contentFormat = dataReader.readUint32();
                      if (contentFormat !== ContentFormat.JSON) {
                        throw new Error("Unexpected content format: ".concat(contentFormat));
                      }
                      var bodyLength = length - dataReader.byteOffset;
                      var data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };
                      if (bodyLength !== 0) {
                        var startByteOffset_1 = dataReader.byteOffset;
                        data.bin = {
                          readAsync: function(byteOffset, byteLength) {
                            return dataReader.buffer.readAsync(startByteOffset_1 + byteOffset, byteLength);
                          },
                          byteLength: bodyLength
                        };
                      }
                      return Promise.resolve(data);
                    };
                    GLTFFileLoader2.prototype._unpackBinaryV2Async = function(dataReader, length) {
                      var _this = this;
                      var ChunkFormat = {
                        JSON: 1313821514,
                        BIN: 5130562
                      };
                      var chunkLength = dataReader.readUint32();
                      var chunkFormat = dataReader.readUint32();
                      if (chunkFormat !== ChunkFormat.JSON) {
                        throw new Error("First chunk format is not JSON");
                      }
                      if (dataReader.byteOffset + chunkLength === length) {
                        return dataReader.loadAsync(chunkLength).then(function() {
                          return { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
                        });
                      }
                      return dataReader.loadAsync(chunkLength + 8).then(function() {
                        var data = { json: _this._parseJson(dataReader.readString(chunkLength)), bin: null };
                        var readAsync2 = function() {
                          var chunkLength2 = dataReader.readUint32();
                          var chunkFormat2 = dataReader.readUint32();
                          switch (chunkFormat2) {
                            case ChunkFormat.JSON: {
                              throw new Error("Unexpected JSON chunk");
                            }
                            case ChunkFormat.BIN: {
                              var startByteOffset_2 = dataReader.byteOffset;
                              data.bin = {
                                readAsync: function(byteOffset, byteLength) {
                                  return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength);
                                },
                                byteLength: chunkLength2
                              };
                              dataReader.skipBytes(chunkLength2);
                              break;
                            }
                            default: {
                              dataReader.skipBytes(chunkLength2);
                              break;
                            }
                          }
                          if (dataReader.byteOffset !== length) {
                            return dataReader.loadAsync(8).then(readAsync2);
                          }
                          return Promise.resolve(data);
                        };
                        return readAsync2();
                      });
                    };
                    GLTFFileLoader2._parseVersion = function(version) {
                      if (version === "1.0" || version === "1.0.1") {
                        return {
                          major: 1,
                          minor: 0
                        };
                      }
                      var match = (version + "").match(/^(\d+)\.(\d+)/);
                      if (!match) {
                        return null;
                      }
                      return {
                        major: parseInt(match[1]),
                        minor: parseInt(match[2])
                      };
                    };
                    GLTFFileLoader2._compareVersion = function(a, b) {
                      if (a.major > b.major) {
                        return 1;
                      }
                      if (a.major < b.major) {
                        return -1;
                      }
                      if (a.minor > b.minor) {
                        return 1;
                      }
                      if (a.minor < b.minor) {
                        return -1;
                      }
                      return 0;
                    };
                    GLTFFileLoader2.prototype._logOpen = function(message) {
                      this._log(message);
                      this._logIndentLevel++;
                    };
                    GLTFFileLoader2.prototype._logClose = function() {
                      --this._logIndentLevel;
                    };
                    GLTFFileLoader2.prototype._logEnabled = function(message) {
                      var spaces = GLTFFileLoader2._logSpaces.substr(0, this._logIndentLevel * 2);
                      babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Logger.Log("".concat(spaces).concat(message));
                    };
                    GLTFFileLoader2.prototype._logDisabled = function(message) {
                    };
                    GLTFFileLoader2.prototype._startPerformanceCounterEnabled = function(counterName) {
                      babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.StartPerformanceCounter(counterName);
                    };
                    GLTFFileLoader2.prototype._startPerformanceCounterDisabled = function(counterName) {
                    };
                    GLTFFileLoader2.prototype._endPerformanceCounterEnabled = function(counterName) {
                      babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.Tools.EndPerformanceCounter(counterName);
                    };
                    GLTFFileLoader2.prototype._endPerformanceCounterDisabled = function(counterName) {
                    };
                    GLTFFileLoader2.IncrementalLoading = true;
                    GLTFFileLoader2.HomogeneousCoordinates = false;
                    GLTFFileLoader2._MagicBase64Encoded = "Z2xURg";
                    GLTFFileLoader2._logSpaces = "                                ";
                    return GLTFFileLoader2;
                  }()
                );
                if (babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.SceneLoader) {
                  babylonjs_Misc_observable__WEBPACK_IMPORTED_MODULE_0__.SceneLoader.RegisterPlugin(new GLTFFileLoader());
                }
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/glTFValidation.ts": (
              /*!*******************************************************!*\
                !*** ../../../dev/loaders/src/glTF/glTFValidation.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFValidation: () => (
                    /* binding */
                    GLTFValidation
                  )
                  /* harmony export */
                });
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! babylonjs/Misc/tools */
                  "babylonjs/Misc/observable"
                );
                var babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__);
                function validateAsync(data, rootUrl, fileName, getExternalResource) {
                  var options = {
                    externalResourceFunction: function(uri) {
                      return getExternalResource(uri).then(function(value) {
                        return new Uint8Array(value);
                      });
                    }
                  };
                  if (fileName) {
                    options.uri = rootUrl === "file:" ? fileName : rootUrl + fileName;
                  }
                  return data instanceof ArrayBuffer ? GLTFValidator.validateBytes(new Uint8Array(data), options) : GLTFValidator.validateString(data, options);
                }
                function workerFunc() {
                  var pendingExternalResources = [];
                  onmessage = function(message) {
                    var data = message.data;
                    switch (data.id) {
                      case "init": {
                        importScripts(data.url);
                        break;
                      }
                      case "validate": {
                        validateAsync(data.data, data.rootUrl, data.fileName, function(uri) {
                          return new Promise(function(resolve, reject) {
                            var index = pendingExternalResources.length;
                            pendingExternalResources.push({ resolve, reject });
                            postMessage({ id: "getExternalResource", index, uri });
                          });
                        }).then(function(value) {
                          postMessage({ id: "validate.resolve", value });
                        }, function(reason) {
                          postMessage({ id: "validate.reject", reason });
                        });
                        break;
                      }
                      case "getExternalResource.resolve": {
                        pendingExternalResources[data.index].resolve(data.value);
                        break;
                      }
                      case "getExternalResource.reject": {
                        pendingExternalResources[data.index].reject(data.reason);
                        break;
                      }
                    }
                  };
                }
                var GLTFValidation = (
                  /** @class */
                  function() {
                    function GLTFValidation2() {
                    }
                    GLTFValidation2.ValidateAsync = function(data, rootUrl, fileName, getExternalResource) {
                      var _this = this;
                      var dataCopy = ArrayBuffer.isView(data) ? data.slice().buffer : data;
                      if (typeof Worker === "function") {
                        return new Promise(function(resolve, reject) {
                          var workerContent = "".concat(validateAsync, "(").concat(workerFunc, ")()");
                          var workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
                          var worker = new Worker(workerBlobUrl);
                          var onError = function(error) {
                            worker.removeEventListener("error", onError);
                            worker.removeEventListener("message", onMessage);
                            reject(error);
                          };
                          var onMessage = function(message) {
                            var data2 = message.data;
                            switch (data2.id) {
                              case "getExternalResource": {
                                getExternalResource(data2.uri).then(function(value) {
                                  worker.postMessage({ id: "getExternalResource.resolve", index: data2.index, value }, [value]);
                                }, function(reason) {
                                  worker.postMessage({ id: "getExternalResource.reject", index: data2.index, reason });
                                });
                                break;
                              }
                              case "validate.resolve": {
                                worker.removeEventListener("error", onError);
                                worker.removeEventListener("message", onMessage);
                                resolve(data2.value);
                                worker.terminate();
                                break;
                              }
                              case "validate.reject": {
                                worker.removeEventListener("error", onError);
                                worker.removeEventListener("message", onMessage);
                                reject(data2.reason);
                                worker.terminate();
                              }
                            }
                          };
                          worker.addEventListener("error", onError);
                          worker.addEventListener("message", onMessage);
                          worker.postMessage({ id: "init", url: babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.GetBabylonScriptURL(_this.Configuration.url) });
                          worker.postMessage({ id: "validate", data: dataCopy, rootUrl, fileName });
                        });
                      } else {
                        if (!this._LoadScriptPromise) {
                          this._LoadScriptPromise = babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools.LoadBabylonScriptAsync(this.Configuration.url);
                        }
                        return this._LoadScriptPromise.then(function() {
                          return validateAsync(dataCopy, rootUrl, fileName, getExternalResource);
                        });
                      }
                    };
                    GLTFValidation2.Configuration = {
                      url: "".concat(babylonjs_Misc_tools__WEBPACK_IMPORTED_MODULE_0__.Tools._DefaultCdnUrl, "/gltf_validator.js")
                    };
                    return GLTFValidation2;
                  }()
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/glTF/index.ts": (
              /*!**********************************************!*\
                !*** ../../../dev/loaders/src/glTF/index.ts ***!
                \**********************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport module object */
                    _1_0_index__WEBPACK_IMPORTED_MODULE_2__
                  ),
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport module object */
                    _2_0_index__WEBPACK_IMPORTED_MODULE_3__
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    _glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation
                  )
                  /* harmony export */
                });
                var _glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var _glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./glTFValidation */
                  "../../../dev/loaders/src/glTF/glTFValidation.ts"
                );
                var _1_0_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./1.0/index */
                  "../../../dev/loaders/src/glTF/1.0/index.ts"
                );
                var _2_0_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./2.0/index */
                  "../../../dev/loaders/src/glTF/2.0/index.ts"
                );
              }
            ),
            /***/
            "../../../dev/loaders/src/index.ts": (
              /*!*****************************************!*\
                !*** ../../../dev/loaders/src/index.ts ***!
                \*****************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTF1
                  ),
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTF2
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    _glTF_index__WEBPACK_IMPORTED_MODULE_0__.GLTFValidation
                  ),
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.OBJFileLoader
                  ),
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    _STL_index__WEBPACK_IMPORTED_MODULE_2__.STLFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    _OBJ_index__WEBPACK_IMPORTED_MODULE_1__.SolidParser
                  )
                  /* harmony export */
                });
                var _glTF_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! ./glTF/index */
                  "../../../dev/loaders/src/glTF/index.ts"
                );
                var _OBJ_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./OBJ/index */
                  "../../../dev/loaders/src/OBJ/index.ts"
                );
                var _STL_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./STL/index */
                  "../../../dev/loaders/src/STL/index.ts"
                );
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-glTF.ts": (
              /*!******************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-glTF.ts ***!
                \******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__.GLTFValidation
                  )
                  /* harmony export */
                });
                var loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/glTF/glTFFileLoader */
                  "../../../dev/loaders/src/glTF/glTFFileLoader.ts"
                );
                var loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! loaders/glTF/glTFValidation */
                  "../../../dev/loaders/src/glTF/glTFValidation.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  globalObject.BABYLON = globalObject.BABYLON || {};
                  for (var key in loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__) {
                    globalObject.BABYLON[key] = loaders_glTF_glTFFileLoader__WEBPACK_IMPORTED_MODULE_0__[key];
                  }
                  for (var key in loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__) {
                    globalObject.BABYLON[key] = loaders_glTF_glTFValidation__WEBPACK_IMPORTED_MODULE_1__[key];
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-glTF1.ts": (
              /*!*******************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-glTF1.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport module object */
                    loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__
                  )
                  /* harmony export */
                });
                var loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/glTF/1.0/index */
                  "../../../dev/loaders/src/glTF/1.0/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  globalObject.BABYLON = globalObject.BABYLON || {};
                  globalObject.BABYLON.GLTF1 = globalObject.BABYLON.GLTF1 || {};
                  for (var key in loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__) {
                    globalObject.BABYLON.GLTF1[key] = loaders_glTF_1_0_index__WEBPACK_IMPORTED_MODULE_0__[key];
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-glTF2.ts": (
              /*!*******************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-glTF2.ts ***!
                \*******************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport module object */
                    loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__
                  )
                  /* harmony export */
                });
                var loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/glTF/2.0/Extensions/index */
                  "../../../dev/loaders/src/glTF/2.0/Extensions/index.ts"
                );
                var loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! loaders/glTF/2.0/glTFLoaderInterfaces */
                  "../../../dev/loaders/src/glTF/2.0/glTFLoaderInterfaces.ts"
                );
                var loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! loaders/glTF/2.0/index */
                  "../../../dev/loaders/src/glTF/2.0/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  globalObject.BABYLON = globalObject.BABYLON || {};
                  var BABYLON_1 = globalObject.BABYLON;
                  BABYLON_1.GLTF2 = BABYLON_1.GLTF2 || {};
                  BABYLON_1.GLTF2.Loader = BABYLON_1.GLTF2.Loader || {};
                  BABYLON_1.GLTF2.Loader.Extensions = BABYLON_1.GLTF2.Loader.Extensions || {};
                  var keys = [];
                  for (var key in loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__) {
                    BABYLON_1.GLTF2.Loader.Extensions[key] = loaders_glTF_2_0_Extensions_index__WEBPACK_IMPORTED_MODULE_0__[key];
                    keys.push(key);
                  }
                  for (var key in loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__) {
                    BABYLON_1.GLTF2.Loader[key] = loaders_glTF_2_0_glTFLoaderInterfaces__WEBPACK_IMPORTED_MODULE_1__[key];
                    keys.push(key);
                  }
                  for (var key in loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__) {
                    if (keys.indexOf(key) > -1) {
                      continue;
                    }
                    BABYLON_1.GLTF2[key] = loaders_glTF_2_0_index__WEBPACK_IMPORTED_MODULE_2__[key];
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-objFileLoader.ts": (
              /*!***************************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-objFileLoader.ts ***!
                \***************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.OBJFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__.SolidParser
                  )
                  /* harmony export */
                });
                var loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/OBJ/index */
                  "../../../dev/loaders/src/OBJ/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  for (var key in loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__) {
                    if (!globalObject.BABYLON[key]) {
                      globalObject.BABYLON[key] = loaders_OBJ_index__WEBPACK_IMPORTED_MODULE_0__[key];
                    }
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts": (
              /*!***************************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts ***!
                \***************************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader
                  )
                  /* harmony export */
                });
                var loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/STL/index */
                  "../../../dev/loaders/src/STL/index.ts"
                );
                var globalObject = typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof window !== "undefined" ? window : void 0;
                if (typeof globalObject !== "undefined") {
                  for (var key in loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__) {
                    if (!globalObject.BABYLON[key]) {
                      globalObject.BABYLON[key] = loaders_STL_index__WEBPACK_IMPORTED_MODULE_0__[key];
                    }
                  }
                }
              }
            ),
            /***/
            "../../../lts/loaders/src/legacy/legacy.ts": (
              /*!*************************************************!*\
                !*** ../../../lts/loaders/src/legacy/legacy.ts ***!
                \*************************************************/
              /***/
              (__unused_webpack_module, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  GLTF1: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTF1
                  ),
                  /* harmony export */
                  GLTF2: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTF2
                  ),
                  /* harmony export */
                  GLTFFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFFileLoader
                  ),
                  /* harmony export */
                  GLTFLoaderAnimationStartMode: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderAnimationStartMode
                  ),
                  /* harmony export */
                  GLTFLoaderCoordinateSystemMode: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderCoordinateSystemMode
                  ),
                  /* harmony export */
                  GLTFLoaderState: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFLoaderState
                  ),
                  /* harmony export */
                  GLTFValidation: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.GLTFValidation
                  ),
                  /* harmony export */
                  MTLFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.MTLFileLoader
                  ),
                  /* harmony export */
                  OBJFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.OBJFileLoader
                  ),
                  /* harmony export */
                  STLFileLoader: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.STLFileLoader
                  ),
                  /* harmony export */
                  SolidParser: () => (
                    /* reexport safe */
                    loaders_index__WEBPACK_IMPORTED_MODULE_0__.SolidParser
                  )
                  /* harmony export */
                });
                var loaders_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(
                  /*! loaders/index */
                  "../../../dev/loaders/src/index.ts"
                );
                var _legacy_glTF__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(
                  /*! ./legacy-glTF */
                  "../../../lts/loaders/src/legacy/legacy-glTF.ts"
                );
                var _legacy_glTF1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(
                  /*! ./legacy-glTF1 */
                  "../../../lts/loaders/src/legacy/legacy-glTF1.ts"
                );
                var _legacy_glTF2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(
                  /*! ./legacy-glTF2 */
                  "../../../lts/loaders/src/legacy/legacy-glTF2.ts"
                );
                var _legacy_objFileLoader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__2(
                  /*! ./legacy-objFileLoader */
                  "../../../lts/loaders/src/legacy/legacy-objFileLoader.ts"
                );
                var _legacy_stlFileLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__2(
                  /*! ./legacy-stlFileLoader */
                  "../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts"
                );
              }
            ),
            /***/
            "babylonjs/Misc/observable": (
              /*!****************************************************************************************************!*\
                !*** external {"root":"BABYLON","commonjs":"babylonjs","commonjs2":"babylonjs","amd":"babylonjs"} ***!
                \****************************************************************************************************/
              /***/
              (module2) => {
                module2.exports = __WEBPACK_EXTERNAL_MODULE_babylonjs_Misc_observable__;
              }
            ),
            /***/
            "../../../../node_modules/tslib/tslib.es6.mjs": (
              /*!****************************************************!*\
                !*** ../../../../node_modules/tslib/tslib.es6.mjs ***!
                \****************************************************/
              /***/
              (__unused_webpack___webpack_module__, __webpack_exports__2, __webpack_require__2) => {
                __webpack_require__2.r(__webpack_exports__2);
                __webpack_require__2.d(__webpack_exports__2, {
                  /* harmony export */
                  __addDisposableResource: () => (
                    /* binding */
                    __addDisposableResource
                  ),
                  /* harmony export */
                  __assign: () => (
                    /* binding */
                    __assign
                  ),
                  /* harmony export */
                  __asyncDelegator: () => (
                    /* binding */
                    __asyncDelegator
                  ),
                  /* harmony export */
                  __asyncGenerator: () => (
                    /* binding */
                    __asyncGenerator
                  ),
                  /* harmony export */
                  __asyncValues: () => (
                    /* binding */
                    __asyncValues
                  ),
                  /* harmony export */
                  __await: () => (
                    /* binding */
                    __await
                  ),
                  /* harmony export */
                  __awaiter: () => (
                    /* binding */
                    __awaiter
                  ),
                  /* harmony export */
                  __classPrivateFieldGet: () => (
                    /* binding */
                    __classPrivateFieldGet
                  ),
                  /* harmony export */
                  __classPrivateFieldIn: () => (
                    /* binding */
                    __classPrivateFieldIn
                  ),
                  /* harmony export */
                  __classPrivateFieldSet: () => (
                    /* binding */
                    __classPrivateFieldSet
                  ),
                  /* harmony export */
                  __createBinding: () => (
                    /* binding */
                    __createBinding
                  ),
                  /* harmony export */
                  __decorate: () => (
                    /* binding */
                    __decorate
                  ),
                  /* harmony export */
                  __disposeResources: () => (
                    /* binding */
                    __disposeResources
                  ),
                  /* harmony export */
                  __esDecorate: () => (
                    /* binding */
                    __esDecorate
                  ),
                  /* harmony export */
                  __exportStar: () => (
                    /* binding */
                    __exportStar
                  ),
                  /* harmony export */
                  __extends: () => (
                    /* binding */
                    __extends
                  ),
                  /* harmony export */
                  __generator: () => (
                    /* binding */
                    __generator
                  ),
                  /* harmony export */
                  __importDefault: () => (
                    /* binding */
                    __importDefault
                  ),
                  /* harmony export */
                  __importStar: () => (
                    /* binding */
                    __importStar
                  ),
                  /* harmony export */
                  __makeTemplateObject: () => (
                    /* binding */
                    __makeTemplateObject
                  ),
                  /* harmony export */
                  __metadata: () => (
                    /* binding */
                    __metadata
                  ),
                  /* harmony export */
                  __param: () => (
                    /* binding */
                    __param
                  ),
                  /* harmony export */
                  __propKey: () => (
                    /* binding */
                    __propKey
                  ),
                  /* harmony export */
                  __read: () => (
                    /* binding */
                    __read
                  ),
                  /* harmony export */
                  __rest: () => (
                    /* binding */
                    __rest
                  ),
                  /* harmony export */
                  __runInitializers: () => (
                    /* binding */
                    __runInitializers
                  ),
                  /* harmony export */
                  __setFunctionName: () => (
                    /* binding */
                    __setFunctionName
                  ),
                  /* harmony export */
                  __spread: () => (
                    /* binding */
                    __spread
                  ),
                  /* harmony export */
                  __spreadArray: () => (
                    /* binding */
                    __spreadArray
                  ),
                  /* harmony export */
                  __spreadArrays: () => (
                    /* binding */
                    __spreadArrays
                  ),
                  /* harmony export */
                  __values: () => (
                    /* binding */
                    __values
                  ),
                  /* harmony export */
                  "default": () => __WEBPACK_DEFAULT_EXPORT__
                  /* harmony export */
                });
                var extendStatics = function(d, b) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                    d2.__proto__ = b2;
                  } || function(d2, b2) {
                    for (var p in b2)
                      if (Object.prototype.hasOwnProperty.call(b2, p))
                        d2[p] = b2[p];
                  };
                  return extendStatics(d, b);
                };
                function __extends(d, b) {
                  if (typeof b !== "function" && b !== null)
                    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                  extendStatics(d, b);
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                }
                var __assign = function() {
                  __assign = Object.assign || function __assign2(t) {
                    for (var s, i = 1, n = arguments.length; i < n; i++) {
                      s = arguments[i];
                      for (var p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                          t[p] = s[p];
                    }
                    return t;
                  };
                  return __assign.apply(this, arguments);
                };
                function __rest(s, e) {
                  var t = {};
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                      t[p] = s[p];
                  if (s != null && typeof Object.getOwnPropertySymbols === "function")
                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                        t[p[i]] = s[p[i]];
                    }
                  return t;
                }
                function __decorate(decorators, target, key, desc) {
                  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
                  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
                    r = Reflect.decorate(decorators, target, key, desc);
                  else
                    for (var i = decorators.length - 1; i >= 0; i--)
                      if (d = decorators[i])
                        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
                  return c > 3 && r && Object.defineProperty(target, key, r), r;
                }
                function __param(paramIndex, decorator) {
                  return function(target, key) {
                    decorator(target, key, paramIndex);
                  };
                }
                function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
                  function accept(f) {
                    if (f !== void 0 && typeof f !== "function")
                      throw new TypeError("Function expected");
                    return f;
                  }
                  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
                  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
                  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
                  var _, done = false;
                  for (var i = decorators.length - 1; i >= 0; i--) {
                    var context = {};
                    for (var p in contextIn)
                      context[p] = p === "access" ? {} : contextIn[p];
                    for (var p in contextIn.access)
                      context.access[p] = contextIn.access[p];
                    context.addInitializer = function(f) {
                      if (done)
                        throw new TypeError("Cannot add initializers after decoration has completed");
                      extraInitializers.push(accept(f || null));
                    };
                    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
                    if (kind === "accessor") {
                      if (result === void 0)
                        continue;
                      if (result === null || typeof result !== "object")
                        throw new TypeError("Object expected");
                      if (_ = accept(result.get))
                        descriptor.get = _;
                      if (_ = accept(result.set))
                        descriptor.set = _;
                      if (_ = accept(result.init))
                        initializers.unshift(_);
                    } else if (_ = accept(result)) {
                      if (kind === "field")
                        initializers.unshift(_);
                      else
                        descriptor[key] = _;
                    }
                  }
                  if (target)
                    Object.defineProperty(target, contextIn.name, descriptor);
                  done = true;
                }
                ;
                function __runInitializers(thisArg, initializers, value) {
                  var useValue = arguments.length > 2;
                  for (var i = 0; i < initializers.length; i++) {
                    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
                  }
                  return useValue ? value : void 0;
                }
                ;
                function __propKey(x) {
                  return typeof x === "symbol" ? x : "".concat(x);
                }
                ;
                function __setFunctionName(f, name, prefix) {
                  if (typeof name === "symbol")
                    name = name.description ? "[".concat(name.description, "]") : "";
                  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
                }
                ;
                function __metadata(metadataKey, metadataValue) {
                  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
                    return Reflect.metadata(metadataKey, metadataValue);
                }
                function __awaiter(thisArg, _arguments, P, generator) {
                  function adopt(value) {
                    return value instanceof P ? value : new P(function(resolve) {
                      resolve(value);
                    });
                  }
                  return new (P || (P = Promise))(function(resolve, reject) {
                    function fulfilled(value) {
                      try {
                        step(generator.next(value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function rejected(value) {
                      try {
                        step(generator["throw"](value));
                      } catch (e) {
                        reject(e);
                      }
                    }
                    function step(result) {
                      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                    }
                    step((generator = generator.apply(thisArg, _arguments || [])).next());
                  });
                }
                function __generator(thisArg, body) {
                  var _ = { label: 0, sent: function() {
                    if (t[0] & 1)
                      throw t[1];
                    return t[1];
                  }, trys: [], ops: [] }, f, y, t, g;
                  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                    return this;
                  }), g;
                  function verb(n) {
                    return function(v) {
                      return step([n, v]);
                    };
                  }
                  function step(op) {
                    if (f)
                      throw new TypeError("Generator is already executing.");
                    while (g && (g = 0, op[0] && (_ = 0)), _)
                      try {
                        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                          return t;
                        if (y = 0, t)
                          op = [op[0] & 2, t.value];
                        switch (op[0]) {
                          case 0:
                          case 1:
                            t = op;
                            break;
                          case 4:
                            _.label++;
                            return { value: op[1], done: false };
                          case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                          case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                          default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                              _ = 0;
                              continue;
                            }
                            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                              _.label = op[1];
                              break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                              _.label = t[1];
                              t = op;
                              break;
                            }
                            if (t && _.label < t[2]) {
                              _.label = t[2];
                              _.ops.push(op);
                              break;
                            }
                            if (t[2])
                              _.ops.pop();
                            _.trys.pop();
                            continue;
                        }
                        op = body.call(thisArg, _);
                      } catch (e) {
                        op = [6, e];
                        y = 0;
                      } finally {
                        f = t = 0;
                      }
                    if (op[0] & 5)
                      throw op[1];
                    return { value: op[0] ? op[1] : void 0, done: true };
                  }
                }
                var __createBinding = Object.create ? function(o, m, k, k2) {
                  if (k2 === void 0)
                    k2 = k;
                  var desc = Object.getOwnPropertyDescriptor(m, k);
                  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
                    desc = { enumerable: true, get: function() {
                      return m[k];
                    } };
                  }
                  Object.defineProperty(o, k2, desc);
                } : function(o, m, k, k2) {
                  if (k2 === void 0)
                    k2 = k;
                  o[k2] = m[k];
                };
                function __exportStar(m, o) {
                  for (var p in m)
                    if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                      __createBinding(o, m, p);
                }
                function __values(o) {
                  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
                  if (m)
                    return m.call(o);
                  if (o && typeof o.length === "number")
                    return {
                      next: function() {
                        if (o && i >= o.length)
                          o = void 0;
                        return { value: o && o[i++], done: !o };
                      }
                    };
                  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
                }
                function __read(o, n) {
                  var m = typeof Symbol === "function" && o[Symbol.iterator];
                  if (!m)
                    return o;
                  var i = m.call(o), r, ar = [], e;
                  try {
                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                      ar.push(r.value);
                  } catch (error) {
                    e = { error };
                  } finally {
                    try {
                      if (r && !r.done && (m = i["return"]))
                        m.call(i);
                    } finally {
                      if (e)
                        throw e.error;
                    }
                  }
                  return ar;
                }
                function __spread() {
                  for (var ar = [], i = 0; i < arguments.length; i++)
                    ar = ar.concat(__read(arguments[i]));
                  return ar;
                }
                function __spreadArrays() {
                  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                    s += arguments[i].length;
                  for (var r = Array(s), k = 0, i = 0; i < il; i++)
                    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                      r[k] = a[j];
                  return r;
                }
                function __spreadArray(to, from, pack) {
                  if (pack || arguments.length === 2)
                    for (var i = 0, l = from.length, ar; i < l; i++) {
                      if (ar || !(i in from)) {
                        if (!ar)
                          ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                  return to.concat(ar || Array.prototype.slice.call(from));
                }
                function __await(v) {
                  return this instanceof __await ? (this.v = v, this) : new __await(v);
                }
                function __asyncGenerator(thisArg, _arguments, generator) {
                  if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                  var g = generator.apply(thisArg, _arguments || []), i, q = [];
                  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                    return this;
                  }, i;
                  function verb(n) {
                    if (g[n])
                      i[n] = function(v) {
                        return new Promise(function(a, b) {
                          q.push([n, v, a, b]) > 1 || resume(n, v);
                        });
                      };
                  }
                  function resume(n, v) {
                    try {
                      step(g[n](v));
                    } catch (e) {
                      settle(q[0][3], e);
                    }
                  }
                  function step(r) {
                    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
                  }
                  function fulfill(value) {
                    resume("next", value);
                  }
                  function reject(value) {
                    resume("throw", value);
                  }
                  function settle(f, v) {
                    if (f(v), q.shift(), q.length)
                      resume(q[0][0], q[0][1]);
                  }
                }
                function __asyncDelegator(o) {
                  var i, p;
                  return i = {}, verb("next"), verb("throw", function(e) {
                    throw e;
                  }), verb("return"), i[Symbol.iterator] = function() {
                    return this;
                  }, i;
                  function verb(n, f) {
                    i[n] = o[n] ? function(v) {
                      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
                    } : f;
                  }
                }
                function __asyncValues(o) {
                  if (!Symbol.asyncIterator)
                    throw new TypeError("Symbol.asyncIterator is not defined.");
                  var m = o[Symbol.asyncIterator], i;
                  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                    return this;
                  }, i);
                  function verb(n) {
                    i[n] = o[n] && function(v) {
                      return new Promise(function(resolve, reject) {
                        v = o[n](v), settle(resolve, reject, v.done, v.value);
                      });
                    };
                  }
                  function settle(resolve, reject, d, v) {
                    Promise.resolve(v).then(function(v2) {
                      resolve({ value: v2, done: d });
                    }, reject);
                  }
                }
                function __makeTemplateObject(cooked, raw) {
                  if (Object.defineProperty) {
                    Object.defineProperty(cooked, "raw", { value: raw });
                  } else {
                    cooked.raw = raw;
                  }
                  return cooked;
                }
                ;
                var __setModuleDefault = Object.create ? function(o, v) {
                  Object.defineProperty(o, "default", { enumerable: true, value: v });
                } : function(o, v) {
                  o["default"] = v;
                };
                function __importStar(mod) {
                  if (mod && mod.__esModule)
                    return mod;
                  var result = {};
                  if (mod != null) {
                    for (var k in mod)
                      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                        __createBinding(result, mod, k);
                  }
                  __setModuleDefault(result, mod);
                  return result;
                }
                function __importDefault(mod) {
                  return mod && mod.__esModule ? mod : { default: mod };
                }
                function __classPrivateFieldGet(receiver, state, kind, f) {
                  if (kind === "a" && !f)
                    throw new TypeError("Private accessor was defined without a getter");
                  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
                    throw new TypeError("Cannot read private member from an object whose class did not declare it");
                  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
                }
                function __classPrivateFieldSet(receiver, state, value, kind, f) {
                  if (kind === "m")
                    throw new TypeError("Private method is not writable");
                  if (kind === "a" && !f)
                    throw new TypeError("Private accessor was defined without a setter");
                  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
                    throw new TypeError("Cannot write private member to an object whose class did not declare it");
                  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
                }
                function __classPrivateFieldIn(state, receiver) {
                  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
                    throw new TypeError("Cannot use 'in' operator on non-object");
                  return typeof state === "function" ? receiver === state : state.has(receiver);
                }
                function __addDisposableResource(env, value, async) {
                  if (value !== null && value !== void 0) {
                    if (typeof value !== "object" && typeof value !== "function")
                      throw new TypeError("Object expected.");
                    var dispose;
                    if (async) {
                      if (!Symbol.asyncDispose)
                        throw new TypeError("Symbol.asyncDispose is not defined.");
                      dispose = value[Symbol.asyncDispose];
                    }
                    if (dispose === void 0) {
                      if (!Symbol.dispose)
                        throw new TypeError("Symbol.dispose is not defined.");
                      dispose = value[Symbol.dispose];
                    }
                    if (typeof dispose !== "function")
                      throw new TypeError("Object not disposable.");
                    env.stack.push({ value, dispose, async });
                  } else if (async) {
                    env.stack.push({ async: true });
                  }
                  return value;
                }
                var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
                  var e = new Error(message);
                  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
                };
                function __disposeResources(env) {
                  function fail(e) {
                    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
                    env.hasError = true;
                  }
                  function next() {
                    while (env.stack.length) {
                      var rec = env.stack.pop();
                      try {
                        var result = rec.dispose && rec.dispose.call(rec.value);
                        if (rec.async)
                          return Promise.resolve(result).then(next, function(e) {
                            fail(e);
                            return next();
                          });
                      } catch (e) {
                        fail(e);
                      }
                    }
                    if (env.hasError)
                      throw env.error;
                  }
                  return next();
                }
                const __WEBPACK_DEFAULT_EXPORT__ = {
                  __extends,
                  __assign,
                  __rest,
                  __decorate,
                  __param,
                  __metadata,
                  __awaiter,
                  __generator,
                  __createBinding,
                  __exportStar,
                  __values,
                  __read,
                  __spread,
                  __spreadArrays,
                  __spreadArray,
                  __await,
                  __asyncGenerator,
                  __asyncDelegator,
                  __asyncValues,
                  __makeTemplateObject,
                  __importStar,
                  __importDefault,
                  __classPrivateFieldGet,
                  __classPrivateFieldSet,
                  __classPrivateFieldIn,
                  __addDisposableResource,
                  __disposeResources
                };
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          (() => {
            __webpack_require__.n = (module2) => {
              var getter = module2 && module2.__esModule ? (
                /******/
                () => module2["default"]
              ) : (
                /******/
                () => module2
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          (() => {
            __webpack_require__.d = (exports2, definition) => {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          (() => {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object")
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  return window;
              }
            }();
          })();
          (() => {
            __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
          })();
          (() => {
            __webpack_require__.r = (exports2) => {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          })();
          var __webpack_exports__ = {};
          (() => {
            __webpack_require__.r(__webpack_exports__);
            __webpack_require__.d(__webpack_exports__, {
              /* harmony export */
              "default": () => __WEBPACK_DEFAULT_EXPORT__,
              /* harmony export */
              loaders: () => (
                /* reexport module object */
                _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__
              )
              /* harmony export */
            });
            var _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
              /*! @lts/loaders/legacy/legacy */
              "../../../lts/loaders/src/legacy/legacy.ts"
            );
            const __WEBPACK_DEFAULT_EXPORT__ = _lts_loaders_legacy_legacy__WEBPACK_IMPORTED_MODULE_0__;
          })();
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        })()
      );
    });
  }
});
export default require_babylonjs_loaders();
/*! Bundled license information:

babylonjs-loaders/babylonjs.loaders.js:
  (*!**********************!*\
    !*** ./src/index.ts ***!
    \**********************)
*/
//# sourceMappingURL=babylonjs-loaders.js.map
